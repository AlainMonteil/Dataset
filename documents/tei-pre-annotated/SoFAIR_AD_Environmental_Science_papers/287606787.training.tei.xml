<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-24T15:15+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Data sets from long-read sequencing platforms (Oxford Background: Nanopore Technologies and Pacific Biosciences) allow for most prokaryote genomes to be completely assembled -one contig per chromosome or plasmid. However, the high per-read error rate of long-read sequencing necessitates different approaches to assembly than those used for short-read sequencing. Multiple assembly tools (assemblers) exist, which use a variety of algorithms for long-read assembly.</p>
        <p>We used 500 simulated read sets and 120 real read sets to Methods: assess the performance of six long-read assemblers (Canu, Flye, Miniasm/Minipolish, Raven, Redbean and Shasta) across a wide variety of genomes and read parameters. Assemblies were assessed on their structural accuracy/completeness, sequence identity, contig circularisation and computational resources used.</p>
        <p>Canu v1.9 produced moderately reliable assemblies but had the Results: longest runtimes of all assemblers tested. Flye v2.6 was more reliable and did particularly well with plasmid assembly. Miniasm/Minipolish v0.3 was the only assembler which consistently produced clean contig circularisation. Raven v0.0.5 was the most reliable for chromosome assembly, though it did not perform well on small plasmids and had circularisation issues. Redbean v2.5 and Shasta v0.3.0 were computationally efficient but more likely to produce incomplete assemblies.</p>
        <p>Of the assemblers tested, Flye, Miniasm/Minipolish and Conclusions: Raven performed best overall. However, no single tool performed well on all metrics, highlighting the need for continued development on long-read assembly algorithms.</p>
        <p>Genome assembly is the computational process of using shotgun whole-genome sequencing data (reads) to reconstruct an organism's true genomic sequence to the greatest extent possible 1 . Software tools which carry out assembly (assemblers) take sequencing reads as input and produce reconstructed contiguous pieces of the genome (contigs) as output.</p>
        <p>If a genome contains repetitive sequences (repeats) which are longer than the sequencing reads, then the underlying genome cannot be fully reconstructed without additional information; i.e. if no read spans a repeat in the genome, then that repeat cannot be resolved, limiting contig length 2 . Short-read sequencing platforms (e.g. those made by Illumina) produce reads hundreds of bases in length and tend to result in shorter contigs. In contrast, long-read platforms from Oxford Nanopore Technologies (ONT) and Pacific Biosciences (PacBio) can generate reads tens of thousands of bases in length which span more repeats and thus result in longer contigs 3 .</p>
        <p>Prokaryote genomes are simpler than eukaryote genomes in a few aspects relevant to assembly. First, they are smaller, most being less than 10 Mbp in size 4 . Second, they contain less repetitive content and their longest repeat sequences are often less than 10 kbp in length 5 . Third, prokaryote genomes are haploid and thus avoid assembly-related complications from diploidy/polyploidy 6 . These facts make prokaryote genome assembly a more tractable problem than eukaryote genome assembly, and in most cases a long-read set of sufficient depth should contain enough information to generate a complete assembly -each replicon in the genome being fully assembled into a single contig 7 . Prokaryote genomes also have two other features relevant to assembly: they may contain plasmids that differ from the chromosome in copy number and therefore read depth, and most prokaryote replicons are circular with no defined start/end point.</p>
        <p>In this study, we examine the performance of various long-read assemblers in the context of prokaryote whole genomes. We assessed each tool on its ability to generate complete assemblies using both simulated and real read sets. We also investigated prokaryote-specific aspects of assembly, such as performance on plasmids and the circularisation of contigs.</p>
        <p>Simulated read sets (read sequences generated in silico from reference genomes) offer some advantages over real read sets when assessing assemblers. They allow for a confident ground truth -i.e. the true underlying genome is known with certainty. They allow for large sample sizes, in practice limited only by computational resources. Also, a variety of genomes and read set parameters can be used to examine assembler performance over a wide range of scenarios. For this study, we simulated 500 read sets to test the assemblers, each using different parameters and a different prokaryote genome.</p>
        <p>To select reference genomes for the simulated read sets, we first downloaded all bacterial and archaeal RefSeq genomes using 
            <rs type="software">ncbi-genome-download</rs> v
            <rs type="version">0.2.10</rs> (14333 genomes at the time of download) 8 . We then performed some quality control steps: excluding genomes with a &gt;10 Mbp chromosome, a &lt;500 kbp chromosome, any &gt;300 kbp plasmid, any plasmid &gt;25% of the chromosome size or more than 9 plasmids (Extended data, Figure S1) 9 . We then ran 
            <rs type="software">Assembly Dereplicator</rs> v
            <rs type="version">0.1.0</rs> with a threshold of 0.1, resulting in 3153 unique genomes 10 .
        </p>
        <p>To produce a final set of 500 genomes with 500 plasmids, we randomly selected 250 genomes from those containing plasmids, repeating this selection until the genomes contained exactly 500 plasmids. We then added 250 genomes randomly selected from those without plasmids. Any ambiguous bases in the assemblies were replaced with 'A' to ensure that sequences contained only the four canonical DNA bases.</p>
        <p>We then used 
            <rs type="software">Badread</rs> v
            <rs type="version">0.1.5</rs> to generate one read set for each input genome 11 . The parameters for each set (controlling read depth, length, identity and errors) were randomly chosen to ensure a large amount of variability (Extended data, Figure S2) 9 .
        </p>
        <p>Note that not all of these read sets were sufficient to reconstruct the original genome (due to low depth or short read length), so even an ideal assembler would be incapable of completing an assembly for all 500 test sets.</p>
        <p>For genomes containing plasmids, the read depth of plasmids relative to the chromosome was also set randomly, with limits based on the plasmid size (Extended data, Figure S3) 9 . Large plasmids were simulated at depths close to that of the chromosome while small plasmids spanned a wider range of depth. This was done to model the observed pattern that small plasmids often have a high per-cell copy number (i.e. may be high read depth) but can be biased against in library preparations (i.e. may be low read depth) 12 . All replicons (chromosomes and plasmids) were treated as circular sequences in Badread, so the simulated read sets do not test assembler performance on linear sequences.</p>
        <p>Despite the advantages of simulated read sets, they can be unrealistic because read simulation tools (such as Badread) may not accurately model all relevant features: error profiles, read lengths, quality scores, etc. Real read sets are therefore also valuable when assessing assemblers. The challenge with real read sets is obtaining a ground truth genome against which assemblies can be checked. Since many reference genome sequences are produced using long-read assemblies, there is the risk of circular reasoning -if we use an assembly as our ground truth reference, our results will be biased in favour of whichever assembler produced the reference.</p>
        <p>To avoid this issue, we used the datasets produced in a recent study comparing ONT and PacBio data which also included Illumina reads for each isolate 13 . For each of the 20 bacterial isolates in that study, we conducted two hybrid assemblies using 
            <rs type="software">Unicycler</rs> v
            <rs type="version">0.4.7</rs>: Illumina+ONT and Illumina+PacBio 14 . 
            <rs type="software">Unicycler</rs> works by first generating an assembly graph using the Illumina reads, then using long-read alignments to scaffold the graph's contigs into a completed genome -a distinct approach from any of the long-read assemblers tested in this study. We ran the assemblies using Unicycler's --no_miniasm option so it skipped its Miniasm-based step which could bias the results in favour of Miniasm/Minipolish. We then excluded any isolate where either hybrid assembly failed to reach completion or where there were structural differences between the two assemblies as determined by a Minimap2 alignment 15 . This left six isolates for inclusion.
        </p>
        <p>The ONT and PacBio read sets for these isolates were quite deep (156× to 535×) so to increase the number of assembly tests, we produced ten random read subsets of each, ranging from 40× to 100× read depth. This resulted in 120 total read sets for testing the assemblers (6 genomes × 2 platforms × 10 read subsets). The Illumina+ONT hybrid assembly was used as ground truth for each isolate.</p>
        <p>All real and simulated read sets 16 and reference genomes 17 are available as Underlying data.</p>
        <p>We assembled each of the read sets using the current versions of six long-read assemblers: Canu v1.9, Flye v2.6, Miniasm/ Minipolish v0.3, Raven v0.0.5, Redbean v2.5 and Shasta v0.3.0. Default parameters were used except where stated, and exact commands for each tool are given in the Extended data, Figure S4 9 . Assemblers that only work on PacBio reads (i.e. not on ONT reads) were excluded (HGAP 18 , FALCON 19 , HINGE 20 and Dazzler 21 ), as were hybrid assemblers which also require short read input (Unicycler 14 and 
            <rs type="software">MaSuRCA</rs> 22 ).
        </p>
        <p>
            <rs type="software">Canu</rs> has the longest history of all the assemblers tested, with its first release dating back to 2015. It performs assembly by first correcting reads, then trimming reads (removing adapters and breaking chimeras) and finally assembling reads into contigs 23 . Its assembly strategy uses a modified version of the string graph algorithm 24 , sometimes referred to as the overlaplayout-consensus (OLC) approach.
        </p>
        <p>Flye takes a different approach to assembly: first combining reads into error-prone disjointigs, then collapsing repetitive sequences to make a repeat graph and finally resolving the graph's repeats to make the final contigs 25 . Of particular note to prokaryote assemblies, Flye has options for recovery of small plasmids (--plasmids) and uneven depth of coverage (--meta), both of which we used in this analysis.</p>
        <p>Miniasm builds a string graph from a set of read overlaps -i.e. it performs only the layout step of OLC. It does not perform read overlapping which must be done separately with Mini-map2, and it does not have a consensus step, so its assembly error rates are comparable to raw read error rates. A separate polishing tool such as Racon is therefore required to achieve high sequence identity 26 . For this study, we developed a tool called 
            <rs type="software">Minipolish</rs> to simplify this process by conducting Racon polishing (two rounds by default) on a Miniasm assembly graph. To ensure clean circularisation of prokaryote replicons, circular contigs are 'rotated' (have their starting position adjusted) between rounds. Minipolish also comes with a script (miniasm_and_minipolish.sh) which carries out all assembly steps (Minimap2 overlapping, Miniasm assembly and Minipolish consensus) in a single command, and subsequent references to 'Miniasm/Minipolish' refer to this entire pipeline.
        </p>
        <p>Raven (previously known as Ra) is another tool which takes an OLC approach to assembly 27 . Its overlapping step shares algorithms with Minimap2, and its consensus step is based on Racon, making it similar to Miniasm/Minipolish. It differs in its layout step which includes novel approaches to remove spurious overlaps from the graph, helping to improve assembly contiguity.</p>
        <p>Redbean (previously known as Wtdbg2) uses an approach to long-read assembly called a fuzzy Bruijn graph 28 . This is modelled on the De Bruijn graph concept widely used for short-read assembly 29 but modified to work with the inexact sequence matches present in noisy long reads.</p>
        <p>Shasta is an assembler designed for computational efficiency 30 .</p>
        <p>To achieve this, much of its assembly pipeline is performed not directly on read sequences but rather on a reduced representation of marker k-mers. These markers are used to find overlaps and build an assembly graph from which a consensus sequence is derived.</p>
        <p>All assemblies were run on Ubuntu 18.04 instances of Australia's Nectar Research Cloud which contained 32 vCPUs and 64 GB of RAM (m3.xxlarge flavour). To guard against performance variation caused by vCPU overcommit, the assemblers were limited to 16 threads (half the number of available vCPUs) in their options. Any assembly which exceeded 24 hours of runtime or 64 GB of memory usage was terminated.</p>
        <p>Our primary metric of assembly quality was contiguity, defined here as the longest single Minimap2 alignment between the assembly and the reference replicon, relative to the reference replicon length. Contiguity of exactly 100% indicates that the replicon was assembled completely with no missing or extra sequence (Extended data, Figure S5A) 9 . Contiguity of slightly less than 100% (e.g. 99.9%) indicates that the assembly was complete, but some bases were lost at the start/end of the contig (Extended data, Figure S5B) 9 . Contiguity of more than 100% (e.g. 101%) indicates that the contig contains duplicated sequence via start-end overlap (Extended data, Figure S5C) 9 . Much lower contiguity (e.g. 70%) indicates that the assembly was not complete due to fragmentation (Extended data, Figure S5D) 9 , missing sequence (Extended data, Figure S5E) 9 or misassembly (Extended data, Figure S5F) 9 . Contiguity values were determined by aligning the contigs to a tripled version of the reference replicon, necessary to ensure that contigs can fully align even with start-end overlap and regardless of their starting position relative to that of the linearised reference sequence (Extended data, Figure S6) 9 .</p>
        <p>Contiguity values were determined for each replicon in the assemblies -e.g. if a genome contained two plasmids, then the assemblies of that genome have three contiguity values: one for the chromosome and one for each plasmid. A status of 'fully complete' was assigned to assemblies where all replicons (the chromosome and any plasmids if present) achieved a contiguity of ≥99%. If an assembly had a chromosome with a contiguity of ≥99% but incomplete plasmids, it was given a status of 'complete chromosome'. If the chromosome had a contiguity of &lt;99%, the assembly was deemed 'incomplete'. If the assembly was empty or missing (possibly due to the assembler prematurely terminating with an error), it was given a status of 'empty'. If the assembly terminated due to exhausting the available RAM, it was given a status of 'out of memory'. Computational metrics were also observed for each assembly: time to complete and maximum RAM usage.</p>
        <p>Figure 1 and Figure 2 summarise the assembly results for the simulated and real read sets, respectively. Full tabulated results can be found in the Extended data 9 . The assemblies, times and terminal outputs generated by each assembler are available as Underlying data 31 .</p>
        <p>Figure 1A/Figure 2A shows the proportion of read sets with each assembly status. For the real read sets, a higher proportion of completed assemblies indicates a more reliable assemblerone which is likely to make a completed assembly given a typical set of input reads. For the simulated read sets, a higher proportion of completed assemblies indicates a more robust assembler -one which is able to tolerate a wide range of input read parameters. Extended data, Figure S7 9 plots assembly contiguity against specific read set parameters to give a more detailed assessment of robustness. Plasmid assembly status, plotted with plasmid length and read depth, is shown in Extended data, Figure S8 and Figure S9 9 for the simulated and real read sets, respectively.</p>
        <p>Figure 1B/Figure 2B shows the chromosome contiguity values for each assembly, focusing on the range near 100%. These plots show how well assemblers can circularise contigs -i.e. whether sequence is duplicated or missing at the contig start/end (Extended data, Figure S5) 9 . The closer contiguity is to 100% the better, with exactly 100% indicating perfect circularisation. Plasmid contiguity values are shown in Extended data, Figure S10 9 .</p>
        <p>Assembly identity (consensus identity) is a measure of the base-level accuracy of an assembled contig relative to the reference sequence (how few substitution and small indel errors are present) and is shown in Figure 1C/Figure 2C. The identity of assembled sequences is almost always higher than the identity of individual reads because errors can be 'averaged out' using read depth, producing more accurate consensus base calls. However, systematic read errors (e.g. mistakes in homopolymer length) can make perfect sequence identity difficult to achieve, regardless of assembly strategy 32 .</p>
        <p>Assembler resource usage is shown in terms of total runtime (Figure 1D/Figure 2D) and the maximum RAM usage during assembly (Figure 1E/Figure 2E).</p>
        <p>When considering only the chromosome, Raven was the most reliable assembler, closely followed by Flye -both were able to complete the chromosome in over three-quarters of the real read sets (Figure 2A). If plasmids are also considered, then Flye was the most reliable assembler. Miniasm/Minipolish and Canu were moderately reliable, completing over half of the real read set chromosomes. Redbean and Shasta were the least reliable and completed less than half of the chromosomes.</p>
        <p>Flye, Miniasm/Minipolish and Raven were the most robust assemblers, able to complete over half of the assemblies attempted with the simulated read sets (Figure 1A). Flye and Redbean performed best in cases of low read depth, able to complete assemblies down to ∼10× depth (Extended data, Figure S7A) 9 . Raven performed the best with low-identity read sets (Extended data, Figure S7B) 9 . The assemblers performed similarly with regards to read length, except for Shasta which required longer reads (Extended data, Figure S7C) 9 . The assemblers were similarly unaffected by random reads, junk reads, chimeric reads or adapter sequences (Extended data, Figure S7D-F) 9 . Read glitches (local breaks in continuity) were well-tolerated by the assemblers except for Redbean and Shasta (Extended data, Figure S7G) 9 .</p>
        <p>In our real read tests, Canu achieved high sequence identity on PacBio reads, Miniasm/Minipolish and Raven did well on ONT reads, and Flye did well on both platforms (Figure 2C). For each assembler, real PacBio reads resulted in higher identities than real ONT reads. For the simulated reads (which contain artificial error profiles), results were more erratic, with Canu, Miniasm/Minipolish and Raven performing best (Figure 1C).</p>
        <p>The nature of read errors depends on the sequencing platform and basecalling software used, so these results may not hold true for all read sets. Post-assembly polishing tools (including Racon 26 , Nanopolish 7 , Medaka 33 and Arrow 34 ) are routinely used to improve the accuracy of long-read assemblies 35 , and identity can be further increased by polishing with Illumina reads where available (e.g. with Pilon 36 ). Therefore, the sequence identity produced by the assembler itself is potentially unimportant for many users.</p>
        <p>
            <rs type="software">Canu</rs> was the slowest assembler tested on both real (Figure 2D) and simulated (Figure 1D) read sets, sometimes taking hours to complete. Its runtime was correlated with read accuracy and read set size, with low-accuracy and large read sets being more likely to result in a long runtime.
        </p>
        <p>Flye was typically faster than Canu, taking less than 15 minutes for the real read sets and usually less than an hour for the simulated read sets. It sometimes took multiple hours to assemble simulated read sets, and this was correlated with the amount of junk (low-complexity) reads, suggesting that removal of such reads via pre-assembly QC may be beneficial. Flye had the highest RAM usage of the tested assemblers and occasionally hit our 64 GB limit for simulated read sets. Its RAM usage was correlated with read N50 and read set size, with long and large read sets being more likely to result in high RAM usage.</p>
        <p>Miniasm/Minipolish, Raven and Redbean were comparable in performance, typically completing assemblies in less than 10 minutes and with less than 16 GB of RAM. While not tested in this study, Racon (which is used in Minipolish) and Raven can be run with GPU acceleration to further improve speed performance. Shasta was the fastest assembler and had the lowest memory usage.</p>
        <p>Of all assemblers tested, Miniasm/Minipolish was the only one to regularly achieve exact circularisation (contiguity=100%), due to Minipolish's polishing pipeline (Figure 1B/Figure 2B). Flye often excluded a small amount of sequence (tens of bases) from the start/end of circular contigs (contiguity &lt;100%), and Raven typically excluded moderate amounts of sequence (hundreds of bases). Canu's contiguities usually exceeded 100%, indicating a large amount (thousands of bases) of start/end overlap. The amount of overlap in a Canu assembly was correlated with the read N50 length (Extended data, Figure S7C) 9 . Redbean and Shasta were both erratic in their circularisation, often producing some sequence duplication (contiguity &gt;100%) but occasionally dropping sequence (contiguity &lt;100%).</p>
        <p>In addition to cleanly circularising contig sequences, it is valuable for a prokaryote genome assembler to clearly distinguish between circular and linear contigs. This can provide users with a clue as to whether or not the genome was assembled to completion. Flye, Miniasm/Minipolish and Shasta produce graph files of their final assembly which can indicate circularity. Canu indicates circularity via the 'suggestCircular' text in its contig headers. Raven and Redbean do not signal to users whether a contig is circular.</p>
        <p>Canu and Flye were the two assemblers most able to assemble plasmids at a broad range of size and depth (Extended data, Figures S8, S9) 9 . Miniasm/Minipolish also performed well, though it failed to assemble plasmids if they were very small or had a very high read depth. Raven was able to assemble most large plasmids but not small plasmids. Redbean and Shasta were least successful at plasmid assembly.</p>
        <p>Circularisation of plasmids followed the same pattern as for chromosomes, with only Miniasm/Minipolish consistently achieving clean circularisation (Extended data, Figure S10) 9 . For smaller plasmids, start/end overlap could sometimes result in contiguities of ∼200% -i.e. the plasmid sequence was duplicated in a single contig. This was most common with Canu, though it occurred with other assemblers as well.</p>
        <p>Ease of use All assemblers tested were relatively easy to use, either running with a single command (Canu, Flye, Raven and Shasta)</p>
        <p>or providing a convenience script to bundle the commands together (Miniasm/Minipolish and Redbean). All were able to take long reads in FASTQ format as input, with the exception of Shasta which required reads to first be converted to FASTA format (Extended data, Figure S4) 9 . We encountered no difficulty installing any of the tools by following the instructions provided.</p>
        <p>Some of the assemblers needed a predicted genome size as input (Canu, Flye and Redbean) while others (Miniasm/Minipolish, Raven and Shasta) did not. This requirement could be a nuisance when assembling unknown isolates, as it may be hard to specify a genome size before the species is known.</p>
        <p>While we ran our assemblies using default and/or recommended commands (Extended data, Figure S4) 9 , some of the assemblers have parameters which can be used to alter their behaviour. Raven was the least configurable assembler tested, with few options available to users. Flye offers some parameters, including overlap and coverage thresholds. Miniasm/Minipolish, Redbean and Shasta all offer more options, and Canu is the most configurable with hundreds of adjustable parameters. Many of the available parameters are arcane (e.g. Miniasm's 'max and min overlap drop ratio' or Shasta's 'pruneIterationCount'), and only experienced power users are likely to adjust them -most will likely stick with default settings or only adjust easier-tounderstand options. However, the presence of low-level parameters provides an opportunity to experiment and gain greater control over assemblies and are therefore appreciated even when unlikely to be used.</p>
        <p>Another aspect worth noting is whether an assembler produces useful files other than its final assembly. Canu stands out in this respect, as it creates corrected and trimmed reads in its pipeline which have low error rates and are mostly free of adapters and chimeric sequences. Canu can therefore be considered not just an assembler but also a long-read correction tool suitable for use in other analyses.</p>
        <p>Assembler summaries Canu v1.9 was the slowest assembler and not the most reliable or robust. Its strength is in its configurability, so power users who are willing to learn Canu's nuances may find that they can tune it to fit their needs. However, it is probably not the best choice for users wanting a quick and simple prokaryote genome assembly.</p>
        <p>Flye v2.6 was an overall strong performer in our tests: reliable, robust and good with plasmids. However, it requires a genome size parameter, tended to delete some sequence (usually on the order of tens of bases) when circularising contigs and could be excessive in its RAM usage when assembling simulated read sets.</p>
        <p>Miniasm/Minipolish v0.3 was not the most reliable assembler but was fairly robust to read set parameters. Its main strength is that it was the only assembler to consistently achieve perfect contig circularisation (as this is a specific goal of its polishing step). Also, it does not require a genome size parameter to run, which makes it easier to run than Canu, Flye or Redbean for unknown genomes.</p>
        <p>
            <rs type="software">Raven</rs> v0.0.5 was the most reliable and robust assembler for chromosome assembly. However, it suffered from worse circularisation problems than Flye (often deleting hundreds of bases) and wasn't good with small plasmids. Like Miniasm/Minipolish, it does not require a genome size parameter.
        </p>
        <p>Redbean v2.5 assemblies tended to have glitches in the sequence which caused breaks in contiguity, making it perform poorly in both reliability and robustness. This, combined with its erratic circularisation performance and requirement to specify genome size, make it a less-than ideal choice for long-read prokaryote read sets. 
            <rs type="software">Shasta</rs> v0.3.0 was the fastest assembler tested and used the least RAM, but it had the worst reliability and robustness. It is therefore more suited to assembly of large genomes in resourcelimited settings (the use case for which it was designed) than it is for prokaryote genome assembly.
        </p>
        <p>Each of the different assemblers has pros and cons, and while no single assembler emerged as an ideal choice for prokaryote genome long-read assembly, the overall best performers were Flye, Miniasm/Minipolish and Raven. Flye was very reliable, especially for plasmid assembly, and was the best performing assembler at low read depths. Miniasm/Minipolish was the only assembler to reliably achieve clean contig circularisation. Raven was the most reliable for chromosome assembly and the most tolerant of low-identity read sets.</p>
        <p>For users looking to achieve an optimal assembly, we recommend trying multiple different tools and comparing the results. This will provide the opportunity for validation -confidence in an assembly is greater when it is in agreement with other independent assemblies. It also offers a chance to detect and repair circularisation issues, as different assemblers are likely to give different contig start/end positions for a circular replicon.</p>
        <p>An ideal prokaryotic long-read assembler would reliably complete assemblies, be robust against read set problems, be easy to use, have low computational requirements, cleanly circularise contigs and assemble plasmids of any size. The importance of long-read assembly will continue to grow as long-read sequencing becomes more commonplace in microbial genomics, and so development of assemblers towards this ideal is crucial.</p>
        <p>Underlying data Figshare: Read sets. https://doi.org/10.26180/5df6f5d06cf04 16 .</p>
        <p>These files contain the input read sets (both simulated and real) for assembly.</p>
        <p>Figshare: Reference genomes. https://doi.org/10.26180/ 5df6e99ff3eed 17 . This file contains the reference genomes against which the long-read assemblies were compared. For the simulated read sets, these genomes were the source sequence from which the reads were generated. Figshare: Assemblies. https://doi.org/10.26180/5df6e2864a658 31 .</p>
        <p>These files contain assemblies (in FASTA format), times and terminal outputs for each of the assemblers.</p>
        <p>Zenodo: Long-read-assembler-comparison. https://doi.org/10.5281/ zenodo.2702442 9 . This project contains the following extended data:</p>
        <p>• Results (tables of results data, (including information on eachreference genome, read set parameters and metrics foreach assembly).</p>
        <p>• 
            <rs type="software">Scripts</rs> (
            <rs type="software">scripts</rs> used to generate plots).
        </p>
        <p>• Figure S1. Distributions of chromosome sizes (A), plasmid sizes (B) and per-genome plasmid counts (C) for the reference genomes used to make the simulated read sets.</p>
        <p>• Figure S2. Badread parameter histograms for the simulated read sets. (A) Mean read depths were sampled from a uniform distribution ranging from 5× to 200×. (B) mean read lengths were sampled from a uniform distribution ranging from 100 to 20000 bp. C: read length standard deviations were sampled from a uniform distribution ranging from 100 to twice that set's mean length (up to 40000 bp). D: mean read identities were sampled from a uniform distribution ranging from 80% to 99%. (E) Max read identities were sampled from a uniform distribution ranging from that set's mean identity plus 1% to 100%. (F) Read identity standard deviations were sampled from a uniform distribution ranging from 1% to the max identity minus the mean identity. (G, H and I) Junk, random and chimera rates were all sampled from an exponential distribution with a mean of 2%. (J) Glitch sizes/skips were sampled from a uniform distribution ranging from 0 to 100. (K) Glitch rates for each set were calculated from the size/skip according to this formula: 100000/1.6986 s/10 . (L) Adapter lengths were sampled from an exponential distribution with a mean of 50.</p>
        <p>• Figure S3. Top: the target simulated depth of each replicon relative to the chromosome. The smaller the plasmid, the wider the range of possible depths. Bottom: the absolute read set of each replicon after read simulation.</p>
        <p>• Figure S4. Commands used for each of the six assemblers tested.</p>
        <p>• The authors compare six long read genome assemblers using simulated and real data (PacBio and Nanopore). They find that there is no single best method, and that each offers distinct advantages and disadvantages. I enjoyed reading this paper. It was well written and clearly presented. As I understand, the authors plan to continually update the benchmarking is a fantastic step forward and considerably improves the utility of such a publication. This should be noted more explicitly in the manuscript.</p>
        <p>Major comments: P.3 "Real Read Sets". Could the authors note which fraction of the PacBio reads were CCS / HiFi reads?</p>
        <p>p.4 para.1: We then excluded any isolate where either hybrid assembly failed to reach completion or where there were structural differences between the two assemblies as determined by a Minimap2 alignment. I wonder if this biases the genomes that were used such that they were easier to assemble than the genomes that were left out. I do not have a big problem with this, but it could be mentioned. It would also be good to provide slightly more detail on what precisely "structural differences between the two assemblies" means -e.g. does this include large indels (size range), inversions, etc.</p>
        <p>P.5 para.4: Figure 1B/Figure 2B shows the chromosome contiguity values for each assembly.</p>
        <p>There are some interesting patterns in 1B and 2B. First is the large number of Shasta assemblies have precisely 100.005% contiguity (looks to be mostly ONT assemblies). I am also surprised by the sort of bimodality in 1C/2C flye assemblies (and somewhat the miniasm assemblies). I would expect an even spread, but instead it looks like some assemblies have similar to 99% identity, whereas others have ~ 2-fold lower error rate (99.5% identity, my guesstimate). Is there an explanation for either of these patterns? P.5 Discussion of Identity. The authors could note the level generally achieved by polishing, which P.5 Discussion of Identity. The authors could note the level generally achieved by polishing, which for ONT I think is around 99.98% (I am sure the authors are more aware than I am).</p>
        <p>Is the study design appropriate and is the work technically sound? Yes</p>
        <p>Are sufficient details of methods and analysis provided to allow replication by others? Yes</p>
        <p>Are all the source data underlying the results available to ensure full reproducibility? Yes</p>
        <p>No competing interests were disclosed.</p>
        <p>Reviewer Expertise: Microbial genomics and evolution, transcription, metagenomics I confirm that I have read this submission and believe that I have an appropriate level of expertise to confirm that it is of an acceptable scientific standard.</p>
        <p>Department of Computer Science and Engineering, University of California San Diego, La Jolla, USA The article presents the benchmarking of the current popular long-read assemblers (Canu, Flye, Miniasm/Minipolish, Raven, Redbean and Shasta) on various prokaryotic genomes. Wick &amp; Holt have simulated 500 long-read datasets to reflect various genomic features (such as repeat length and complexity) as well as different sequencing parameters (depth, read length, sequencing artifacts etc). In addition, the authors test the assemblers on 160 real PacBio and Oxford Nanopore datasets. For each benchmarked algorithm, Wick &amp; Holt summarize the important assembly metrics, such as contiguity or base-level accuracy (measured against the corresponding references), as well as overall user experience.</p>
        <p>The manuscript is well-written, and the study design is sound. The presented benchmarks will be a 1.</p>
        <p>3.</p>
        <p>The manuscript is well-written, and the study design is sound. The presented benchmarks will be a valuable resource for the long-read genomics community, both for developers and users. Importantly, the authors have made all data sets and benchmarking pipelines freely available. I only have the following minor suggestions:</p>
        <p>In my view, the evaluation pipeline designed by the authors could be highlighted more in the main text. E.g. how can a developer test a different assembler using the described benchmarks? Is it quick to reproduce? What would be the resource requirements?</p>
        <p>It would be useful to compare the pros and cons of this work with the other assembly evaluation methods (such as QUAST) in a short discussion.</p>
        <p>On Figure 2, triangles and circles are somewhat difficult to distinguish. Is there a way to better visually separate PacBio and ONT data points (maybe color tones or background pattern)?</p>
        <p>For the sake of completeness, it is worth mentioning the minimap2 alignment identity threshold that is used for contiguity evaluation.</p>
        <p>DOI links to read sets and generated assemblies seem to have an unneeded space that break the URLs.</p>
        <p>Generating the assembly with a hybrid approach which is different from all benchmarked assemblers is a good approach, but is there a possibility to analyse in details datasets which have reference genomes assembled with Sanger sequencing (such as CFT073 and MGH78578 datasets used in )? De Maio N, Shaw LP, Hubbard A, et al.</p>
        <p>As minipolish is a new pipeline introduced in this paper, I would suggest describing it a bit more in detail.</p>
        <p>Ra assembler has been published as a conference proceedings . here</p>
        <p>Are all the source data underlying the results available to ensure full reproducibility?</p>
        <p>No competing interests were disclosed.</p>
        <p>Reviewer 
            <rs type="software">Expertise</rs>: Sequence alignment, de novo assembly, algorithms, machine learning
        </p>
        <p>We confirm that we have read this submission and believe that we have an appropriate level of expertise to confirm that it is of an acceptable scientific standard.</p>
        <p>We just have a couple of minor suggestions:</p>
        <p>Reliability vs. robustness: the authors summarized their findings using the terms "reliability" for performance on real data sets, and "robustness" on simulated data sets. These terms might be a bit misleading to some readers. Reliability can be defined as consistent performance with good results, and robustness (in contrast) might be the ability to perform well under adverse conditions. The real data sets do vary in quality and coverage, although not as much as the simulated data. But it seems that both reliability and robustness can be evaluated on both types of data. If they want to use the term "robustness," perhaps they could also plot the number of successful assemblies (or contiguity) vs the read error rate for each assembler. In this respect, a high error rate might be considered an adverse condition.</p>
        <p>Figure 1 is excellent, and provides a really nice summary of the performance on simulated data. 2. Figure 1 is excellent, and provides a really nice summary of the performance on simulated data. However, only 1 of the programs, 
            <rs type="software">Flye</rs>, failed due to running out of memory, which was limited to 64 GB of RAM. Flye was otherwise one of the best performers. RAM is fairly inexpensive today, and it's not hard to find a server with &gt;64 GB. The Figure doesn't show how much more memory Flye would need, and it would be really helpful to know that. Would 128GB allow it to complete in all cases? We suggest they run those failed assemblies on a larger-memory server and report what was needed.
        </p>
        <p>Another consideration here, though, is that depending on overcommit ratio and swap parameters, processes may be killed or slowed down long before they reach the 64GB physical memory limit.</p>
        <p>The impact of swap space on performance is an unknown here as well. For a clean evaluation, they should be sure (and maybe they did this, we can't tell) that swap was disabled and that the overcommit ratio was set to 97% to allow a process to use essentially all avaliable RAM. (There's more information about memory overcommit settings ) If swapping came into play on any of here these jobs, then it would drastically increase runtime.</p>
        <p>If applicable, is the statistical analysis and its interpretation appropriate? Not applicable Are all the source data underlying the results available to ensure full reproducibility? Yes</p>
        <p>No competing interests were disclosed.</p>
        <p>Reviewer Expertise: Genomics, computational biology</p>
        <p>We confirm that we have read this submission and believe that we have an appropriate level of expertise to confirm that it is of an acceptable scientific standard.</p>
        <p>Your article is published within days, with no editorial bias You can publish traditional articles, null/negative results, case reports, data notes and more</p>
        <p>F1000Research 2019, 8:2138 Last updated:30 JAN 2020</p>
        <p>This research was supported by use of the Nectar Research Cloud, a collaborative Australian research platform supported by the National Collaborative Research Infrastructure Strategy (NCRIS).</p>
        <p>This work was supported by the Bill &amp; Melinda Gates Foundation, Seattle (grant number OPP1175797) and an Australian Grant information: Government Research Training Program Scholarship. KEH is supported by a Senior Medical Research Fellowship from the Viertel Foundation of Victoria.</p>
        <p>The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</p>
        <p>with missing bases leading to a gapped circularisation. (C) Complete assembly but with duplicated bases leading to overlapping circularisation. (D) Incomplete assembly due to fragmentation (multiple contigs per replicon). (E) Incomplete assembly due to missing sequence. (F) Incomplete assembly due to misassembly (noncontiguous sequence in the contig).</p>
        <p>• Figure S6. Reference triplication for assembly assessment.</p>
        <p>(A) Due to the ambiguous starting position of a circular replicon, a completely-assembled contig will typically not align to the reference in a single unbroken alignment. (B) Doubling the reference sequence will allow for a single alignment, regardless of starting position.</p>
        <p>(C) However, if the contig contains start/end overlap (i.e. contiguity &gt;100%) then even a doubled reference may not be sufficient to achieve a single alignment, depending on the starting position. (D) A tripled reference allows for an unbroken alignment, regardless of starting position, even in cases of &gt;100% contiguity. Percentages in the plot titles give the proportion of plasmids which were completely assembled.</p>
        <p>• Figure S10. The relative contiguity of the plasmids for each real read set assembly (A) and simulated read set assembly (B).</p>
        <p>Extended data are also available on GitHub.</p>
        <p>Data are available under the terms of the Creative Commons Attribution 4.0 International license (CC-BY 4.0).</p>
        <p>Your article is indexed in PubMed after passing peer review Dedicated customer support at every stage For pre-submission enquiries, contact research@f1000.com</p>
    </text>
</tei>
