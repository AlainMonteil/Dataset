<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-14T14:42+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Blind quantum computing (BQC) allows a client to have a server carry out a quantum computation for them such that the client's input, output, and computation remain private. A desirable property for any BQC protocol is verification, whereby the client can verify with high probability whether the server has followed the instructions of the protocol or if there has been some deviation resulting in a corrupted output state. A verifiable BQC protocol can be viewed as an interactive proof system leading to consequences for complexity theory. We previously proposed [A.Blind quantum computing (BQC) allows a client to have a server carry out a quantum computation for them such that the client's input, output, and computation remain private. A desirable property for any BQC protocol is verification, whereby the client can verify with high probability whether the server has followed the instructions of the protocol or if there has been some deviation resulting in a corrupted output state. A verifiable BQC protocol can be viewed as an interactive proof system leading to consequences for complexity theory. We previously proposed [A.</p>
        <p>Scalable quantum computing has proven extremely difficult to achieve, and when the technology to build large-scale quantum computers does become available it is likely that they will appear initially in small numbers at a handful of centers. How will a user interface securely with such a quantum computer? A solution to this problem is offered by blind quantum computing, which enables a classical client (Alice) with limited quantum technology to delegate a computation to the quantum server(s) (Bob) in such a way that the privacy of the computation is preserved [1][2][3][4][5][6].Scalable quantum computing has proven extremely difficult to achieve, and when the technology to build large-scale quantum computers does become available it is likely that they will appear initially in small numbers at a handful of centers. How will a user interface securely with such a quantum computer? A solution to this problem is offered by blind quantum computing, which enables a classical client (Alice) with limited quantum technology to delegate a computation to the quantum server(s) (Bob) in such a way that the privacy of the computation is preserved [1][2][3][4][5][6].</p>
        <p>Blind classical computing (the notion of computing with encrypted data) was proposed by Feigenbaum [7] and then extended by Abadi et al. in a client server setting [8]. They showed that a randomized classical polynomial time client can encrypt and delegate general instances of certain problems in NP 1 to a powerful but untrusted server. Remarkably, they also proved that the decision of no NP-hard function can be encrypted in this way if unconditional security is required, 2unless the polynomial hierarchy collapses at the third level. The idea of computing known circuits on encrypted data, while requiring the encryption and decryption procedures be independent of the complexity of the function to be evaluated, was introduced earlier by Rivest, Adleman, and Dertouzous in a scenario restricted to computational security [9] shortly after the invention of RSA [10]. The problem of creating such a scheme, known as fully homomorphic encryption, remained open for 30 years before being settled by Gentry [11], leading to one of the most active areas of research in modern cryptography [12]. 3The first example of blind quantum computation was proposed by Childs [1] based on the idea of encrypting input qubits with a quantum one-time pad [19,20]. At each step, the client sends the encrypted qubits to the server, which applies a known quantum gate. Finally, the server returns the quantum state for the client to decrypt with their key. Cycling through a fixed set of universal gates ensures that the server learns nothing about the circuit. The next quantum blind protocol with the possibility of detecting a cheating server was proposed by Arrighi and Salvail [2]. In their scheme, the client gives the server multiple quantum inputs, most of which are decoys (not intended to be part of the desired computation), but rather are used to detect the server's deviation. This leads to a trade-off on the server side between gaining information and not disturbing the system and achieves cheat-sensitive security against individual attacks for a set of classical functions called random verifiable, where it is possible for the client to efficiently generate random input-output pairs. Extending these results, together with Broadbent, we presented a universal blind quantum computing (UBQC) protocol [3] in the measurementbased model [21,22], where the only requirement for the client is a classical computing machine and a very weak quantum instrument, a random single-qubit generator, a currently available technology as we have demonstrated recently [23]. Aside from the cryptographic scenario, a scheme based on a quantum authentication protocol 4 was proposed by Aharonov et al. [4], showing that any language in BQP has an interactive proof system with a verifier accessing a constant-size quantum computer. This work was complemented by a recent result of Reichardt et al. on the command of quantum systems via rigidity of CHSH games [5], leading to further work on deviceindependent verifiable blind quantum computing [24,25].Blind classical computing (the notion of computing with encrypted data) was proposed by Feigenbaum [7] and then extended by Abadi et al. in a client server setting [8]. They showed that a randomized classical polynomial time client can encrypt and delegate general instances of certain problems in NP 1 to a powerful but untrusted server. Remarkably, they also proved that the decision of no NP-hard function can be encrypted in this way if unconditional security is required, 2unless the polynomial hierarchy collapses at the third level. The idea of computing known circuits on encrypted data, while requiring the encryption and decryption procedures be independent of the complexity of the function to be evaluated, was introduced earlier by Rivest, Adleman, and Dertouzous in a scenario restricted to computational security [9] shortly after the invention of RSA [10]. The problem of creating such a scheme, known as fully homomorphic encryption, remained open for 30 years before being settled by Gentry [11], leading to one of the most active areas of research in modern cryptography [12]. 3The first example of blind quantum computation was proposed by Childs [1] based on the idea of encrypting input qubits with a quantum one-time pad [19,20]. At each step, the client sends the encrypted qubits to the server, which applies a known quantum gate. Finally, the server returns the quantum state for the client to decrypt with their key. Cycling through a fixed set of universal gates ensures that the server learns nothing about the circuit. The next quantum blind protocol with the possibility of detecting a cheating server was proposed by Arrighi and Salvail [2]. In their scheme, the client gives the server multiple quantum inputs, most of which are decoys (not intended to be part of the desired computation), but rather are used to detect the server's deviation. This leads to a trade-off on the server side between gaining information and not disturbing the system and achieves cheat-sensitive security against individual attacks for a set of classical functions called random verifiable, where it is possible for the client to efficiently generate random input-output pairs. Extending these results, together with Broadbent, we presented a universal blind quantum computing (UBQC) protocol [3] in the measurementbased model [21,22], where the only requirement for the client is a classical computing machine and a very weak quantum instrument, a random single-qubit generator, a currently available technology as we have demonstrated recently [23]. Aside from the cryptographic scenario, a scheme based on a quantum authentication protocol 4 was proposed by Aharonov et al. [4], showing that any language in BQP has an interactive proof system with a verifier accessing a constant-size quantum computer. This work was complemented by a recent result of Reichardt et al. on the command of quantum systems via rigidity of CHSH games [5], leading to further work on deviceindependent verifiable blind quantum computing [24,25].</p>
        <p>Recent years have seen an explosion of interest in the topic of blind quantum computing. This includes, for example, the extension of measurement-based UBQC to various settings [26][27][28][29][30], addressing key questions regarding the effect of the noise [31,32], the creation of protocols to optimize communications requirements [33][34][35], the development of privacy amplification techniques, similar to those applicable to quantum key distribution, to combat the adverse effect of imperfect devices on blindness [36], experimental demonstrations [23,37,38], and cryptographic applications [6,39].Recent years have seen an explosion of interest in the topic of blind quantum computing. This includes, for example, the extension of measurement-based UBQC to various settings [26][27][28][29][30], addressing key questions regarding the effect of the noise [31,32], the creation of protocols to optimize communications requirements [33][34][35], the development of privacy amplification techniques, similar to those applicable to quantum key distribution, to combat the adverse effect of imperfect devices on blindness [36], experimental demonstrations [23,37,38], and cryptographic applications [6,39].</p>
        <p>A desirable property for any UBQC protocol is verifiability, whereby the client has a mechanism to verify the correctness of a delegated computation. The motivation for this stems from the broad range of computations that can be performed on a quantum computer. For problems that are in NP, the solution can be efficiently verified, at least in principle, using a witness. However, for other problems that can be efficiently computed using quantum computation, such as quantum simulation [40], a dishonest server cannot be detected in such a way. The ability to compute with encrypted data, while hiding the underlying function, has opened up alternative approaches to the problem of verification [3][4][5]. The main contributions of the present paper are to make rigorous the foundations of measurement-based UBQC and to present a verification protocol that we prove to be secure against the most general adversarial behavior of the server. Using this protocol, the client can verify with high probability whether Bob has followed the instructions of the protocol and the output state is indeed in the correct form or if there has been a deviation resulting in an incorrect output state. The central idea is based on the insertion of randomly prepared single qubits (called traps), blindly isolated from the actual computation, which can act as such a witness. Here, even the computation of the test (measurement of the qubits) can be performed blindly by an untrusted server as we have demonstrated recently [38].A desirable property for any UBQC protocol is verifiability, whereby the client has a mechanism to verify the correctness of a delegated computation. The motivation for this stems from the broad range of computations that can be performed on a quantum computer. For problems that are in NP, the solution can be efficiently verified, at least in principle, using a witness. However, for other problems that can be efficiently computed using quantum computation, such as quantum simulation [40], a dishonest server cannot be detected in such a way. The ability to compute with encrypted data, while hiding the underlying function, has opened up alternative approaches to the problem of verification [3][4][5]. The main contributions of the present paper are to make rigorous the foundations of measurement-based UBQC and to present a verification protocol that we prove to be secure against the most general adversarial behavior of the server. Using this protocol, the client can verify with high probability whether Bob has followed the instructions of the protocol and the output state is indeed in the correct form or if there has been a deviation resulting in an incorrect output state. The central idea is based on the insertion of randomly prepared single qubits (called traps), blindly isolated from the actual computation, which can act as such a witness. Here, even the computation of the test (measurement of the qubits) can be performed blindly by an untrusted server as we have demonstrated recently [38].</p>
        <p>The verification scheme we present here makes use of similar elements as suggested in [3]: Trap computations are used to detect errors and a fault-tolerant encoding of the computation is used to amplify the detection rate. While the proof sketch for the effectiveness of verification in the original UBQC paper did not consider the most general adversary, we prove that the modified scheme we present here detects or corrects any possible deviation by the server, except with probability that is exponentially suppressed. In order to do so we introduce universal resource states beyond the original brickwork state introduced in [3]. The first such family is a simple modification of the brickwork state that allows for the embedding of an arbitrary trap qubit, which leads to an inverse polynomial probability of detecting a deviation from the computation. In order to achieve a higher rate of detection, we introduce a second resource state that overcomes the locality limitations inherent in the brickwork state. This allows for the inclusion of a polynomial number of trap qubits and fault-tolerant implementation of the target computation based on the topological scheme of Raussendorf et al. [41]. Together, these two features allow for the probability of failing to detect or correct a deviation from the protocol to be made exponentially small. In this work we deal only with the stand-alone security definitions, as composable security follows from recent follow-up work by Dunjko et al. [42].The verification scheme we present here makes use of similar elements as suggested in [3]: Trap computations are used to detect errors and a fault-tolerant encoding of the computation is used to amplify the detection rate. While the proof sketch for the effectiveness of verification in the original UBQC paper did not consider the most general adversary, we prove that the modified scheme we present here detects or corrects any possible deviation by the server, except with probability that is exponentially suppressed. In order to do so we introduce universal resource states beyond the original brickwork state introduced in [3]. The first such family is a simple modification of the brickwork state that allows for the embedding of an arbitrary trap qubit, which leads to an inverse polynomial probability of detecting a deviation from the computation. In order to achieve a higher rate of detection, we introduce a second resource state that overcomes the locality limitations inherent in the brickwork state. This allows for the inclusion of a polynomial number of trap qubits and fault-tolerant implementation of the target computation based on the topological scheme of Raussendorf et al. [41]. Together, these two features allow for the probability of failing to detect or correct a deviation from the protocol to be made exponentially small. In this work we deal only with the stand-alone security definitions, as composable security follows from recent follow-up work by Dunjko et al. [42].</p>
        <p>The remainder of the paper is organized as follows. Sections II and III summarize various required concepts from measurement-based quantum computing and also the original UBQC scheme presented in [3]. In order to construct our verifiable UBQC protocol we first introduce the concept of dummy qubits in Sec. IV, where we assume Alice now can prepare a qubit randomly chosen not only in the equatorial plain, as in the original UBQC scheme, but also from the set {|0 ,|1 }. The latter qubits are called dummy qubits as they have no effect on the actual underlying computation. However, they permit the blind construction of isolated trap qubits in the state |+ θ as explained in Sec. VI, where the core concept of verification is introduced. In order to deal with both universality and verification, in Sec. V we introduce two resource states called the cylinder brickwork and dotted-complete graph states. The use of this scheme is expected to lead to substantially increased thresholds for fault-tolerant computing in the blind setting. A threshold for fault-tolerant blind computation in the absence of verification based on this fault-tolerance scheme was previously calculated as 4.3×10 -3 by Morimae and Fujii [31]. As shown in Sec. VI, introduction of a single blind isolated trap qubit leads to a verifiable blind quantum computing protocol with security polynomial in the total number of qubits. In order to boost the security while maintaining universality a different scheme has to be constructed. This is done in Sec. VII, where we put together various constructions of the previous sections to present the main result of this paper, a universal exponentially secure verifiable blind quantum computing protocol.The remainder of the paper is organized as follows. Sections II and III summarize various required concepts from measurement-based quantum computing and also the original UBQC scheme presented in [3]. In order to construct our verifiable UBQC protocol we first introduce the concept of dummy qubits in Sec. IV, where we assume Alice now can prepare a qubit randomly chosen not only in the equatorial plain, as in the original UBQC scheme, but also from the set {|0 ,|1 }. The latter qubits are called dummy qubits as they have no effect on the actual underlying computation. However, they permit the blind construction of isolated trap qubits in the state |+ θ as explained in Sec. VI, where the core concept of verification is introduced. In order to deal with both universality and verification, in Sec. V we introduce two resource states called the cylinder brickwork and dotted-complete graph states. The use of this scheme is expected to lead to substantially increased thresholds for fault-tolerant computing in the blind setting. A threshold for fault-tolerant blind computation in the absence of verification based on this fault-tolerance scheme was previously calculated as 4.3×10 -3 by Morimae and Fujii [31]. As shown in Sec. VI, introduction of a single blind isolated trap qubit leads to a verifiable blind quantum computing protocol with security polynomial in the total number of qubits. In order to boost the security while maintaining universality a different scheme has to be constructed. This is done in Sec. VII, where we put together various constructions of the previous sections to present the main result of this paper, a universal exponentially secure verifiable blind quantum computing protocol.</p>
        <p>Measurement-based quantum computing (MBQC) [21,22] is a form of quantum information processing where the key twin notions that distinguish quantum information processing from its classical counterpart, entanglement (creating nonlocal correlations between quantum elements) and measurement (observing a quantum system), are the explicit driving force of computation. More precisely, a measurement-based computation consists of a phase in which a collection of qubits is set up in a standard entangled state. Measurements are then made on individual qubits and the outcomes of the measurements may be used to determine further adaptive measurements. Finally, again depending on measurement outcomes, local adaptive unitary operators, called corrections, are applied to some qubits; this allows the elimination of the indeterminacy introduced by measurements. Conceptually MBQC separates the quantum and classical aspects of computation; thus it clarifies, in particular, the interplay between classical control and the quantum evolution process. The UBQC protocol explores this unique feature of MBQC as it has been proven to be conceptually enlightening to reason about distributed computing tasks using this approach [43]. We begin by describing all the required elements for an MBQC protocol and then move to the particular family of distributed MBQC protocols for hiding various aspects of a given computation.Measurement-based quantum computing (MBQC) [21,22] is a form of quantum information processing where the key twin notions that distinguish quantum information processing from its classical counterpart, entanglement (creating nonlocal correlations between quantum elements) and measurement (observing a quantum system), are the explicit driving force of computation. More precisely, a measurement-based computation consists of a phase in which a collection of qubits is set up in a standard entangled state. Measurements are then made on individual qubits and the outcomes of the measurements may be used to determine further adaptive measurements. Finally, again depending on measurement outcomes, local adaptive unitary operators, called corrections, are applied to some qubits; this allows the elimination of the indeterminacy introduced by measurements. Conceptually MBQC separates the quantum and classical aspects of computation; thus it clarifies, in particular, the interplay between classical control and the quantum evolution process. The UBQC protocol explores this unique feature of MBQC as it has been proven to be conceptually enlightening to reason about distributed computing tasks using this approach [43]. We begin by describing all the required elements for an MBQC protocol and then move to the particular family of distributed MBQC protocols for hiding various aspects of a given computation.</p>
        <p>A formal language to describe in a compact way the operations needed for the MBQC model was proposed in [22]. In this framework every MBQC algorithm (usually referred to as an MBQC pattern) involves a sequence of operations such as entangling gates, measurements, and feedforwarding of outcome results to determine further measurement bases. A measurement pattern, or simply a pattern, is defined by a choice of a set of working qubits (V ), a subset of input qubits (I ), another subset of output qubits (O), and a finite sequence of commands acting on qubits in V . Therefore, we consider patterns associated with the so-called open graphs. Following the terminology of [22], a single-party MBQC protocol consists of three elements.A formal language to describe in a compact way the operations needed for the MBQC model was proposed in [22]. In this framework every MBQC algorithm (usually referred to as an MBQC pattern) involves a sequence of operations such as entangling gates, measurements, and feedforwarding of outcome results to determine further measurement bases. A measurement pattern, or simply a pattern, is defined by a choice of a set of working qubits (V ), a subset of input qubits (I ), another subset of output qubits (O), and a finite sequence of commands acting on qubits in V . Therefore, we consider patterns associated with the so-called open graphs. Following the terminology of [22], a single-party MBQC protocol consists of three elements.</p>
        <p>(i) A uniform family of open graph states {(G n,m ,I n ,O n )} n over m vertices is associated with individual qubits, where n is the size of the input and output space of the underlying computation. In this paper we deal only with those MBQC protocols that implement a unitary operator over their input space and hence the size of the output space is the same as the input space, but this is not a restriction and we can extend this treatment to any general completely positive trace preserving map by padding the input and output spaces. Further, for simplicity, we will assume that the input is always a pure state, though again this treatment can be extended to the general case. We usually assume that |I | = |O| = n, however sometimes n is taken to be strictly larger than the dimension of the input and output Hilbert space due to the existence of auxiliary input or output qubits (as in later protocols that incorporate trap qubits). In order to have uniform notation, for the latter case, we will still use I (O) to be the set of all nonprepared (nonmeasured) qubits where it is strictly larger than the class of all input (output) qubits. By the term "uniform family" we simply mean that for any protocol there exists a classical Turing machine that for a given input of the size n describes the required graph over m n vertices. If the underlying geometry of the graph is regular, for example, being one-dimensional lines, two-dimensional regular lattices, or brickwork graphs (as we describe later), then instead of referring to the Turing machine to define the uniform family we simply use fixed parameters such as the size of the line or lattice to specify the graphs. For any fixed input size n the graph G n,m describes the initial quantum state of the protocol. Given an arbitrary state of the input qubits corresponding to the input vertices of the graph, one prepares mn qubits in the state |+ = 1 √ 2 (|0 + |1 ) corresponding to all noninput qubits (I c ) in the graph and then apply CTRL-Z operator between qubits i and j , if the corresponding vertices in G n,m are connected. Note that since the CTRL-Z gate is symmetric the direction of the edge is not important and hence we are working with undirected graphs. We will usually refer to the obtained quantum state based on the graph G n,m as the graph state G n,m , unless a different notation is more appropriate; also for simplicity we drop the indices.(i) A uniform family of open graph states {(G n,m ,I n ,O n )} n over m vertices is associated with individual qubits, where n is the size of the input and output space of the underlying computation. In this paper we deal only with those MBQC protocols that implement a unitary operator over their input space and hence the size of the output space is the same as the input space, but this is not a restriction and we can extend this treatment to any general completely positive trace preserving map by padding the input and output spaces. Further, for simplicity, we will assume that the input is always a pure state, though again this treatment can be extended to the general case. We usually assume that |I | = |O| = n, however sometimes n is taken to be strictly larger than the dimension of the input and output Hilbert space due to the existence of auxiliary input or output qubits (as in later protocols that incorporate trap qubits). In order to have uniform notation, for the latter case, we will still use I (O) to be the set of all nonprepared (nonmeasured) qubits where it is strictly larger than the class of all input (output) qubits. By the term "uniform family" we simply mean that for any protocol there exists a classical Turing machine that for a given input of the size n describes the required graph over m n vertices. If the underlying geometry of the graph is regular, for example, being one-dimensional lines, two-dimensional regular lattices, or brickwork graphs (as we describe later), then instead of referring to the Turing machine to define the uniform family we simply use fixed parameters such as the size of the line or lattice to specify the graphs. For any fixed input size n the graph G n,m describes the initial quantum state of the protocol. Given an arbitrary state of the input qubits corresponding to the input vertices of the graph, one prepares mn qubits in the state |+ = 1 √ 2 (|0 + |1 ) corresponding to all noninput qubits (I c ) in the graph and then apply CTRL-Z operator between qubits i and j , if the corresponding vertices in G n,m are connected. Note that since the CTRL-Z gate is symmetric the direction of the edge is not important and hence we are working with undirected graphs. We will usually refer to the obtained quantum state based on the graph G n,m as the graph state G n,m , unless a different notation is more appropriate; also for simplicity we drop the indices.</p>
        <p>(ii) A set of angles φ i ∈ A, where A ⊆ [0, 2π ) for all nonoutput qubits, describes a collection of single-qubit (X,Y ) measurements, that is, measurement in the bases 1 √ 2 (|0 ± e iφ i |1 ). For the specific class of MBQC protocols that we discuss in this paper we require the angles to specify a collection of measurement bases such that individual measurements are unbiased with respect to the initial state. This is an essential ingredient for the blindness property that we define later. Without loss of generality, we can fix the set from which the angles are chosen to be A = {0,π/4,2π/4, . . . ,7π/4}. We will discuss later how this combination of angles and particular families of graph states leads to approximate universality.(ii) A set of angles φ i ∈ A, where A ⊆ [0, 2π ) for all nonoutput qubits, describes a collection of single-qubit (X,Y ) measurements, that is, measurement in the bases 1 √ 2 (|0 ± e iφ i |1 ). For the specific class of MBQC protocols that we discuss in this paper we require the angles to specify a collection of measurement bases such that individual measurements are unbiased with respect to the initial state. This is an essential ingredient for the blindness property that we define later. Without loss of generality, we can fix the set from which the angles are chosen to be A = {0,π/4,2π/4, . . . ,7π/4}. We will discuss later how this combination of angles and particular families of graph states leads to approximate universality.</p>
        <p>(iii) The last ingredient is the structure of the dependence among the measurements. It is known that despite the probabilistic nature of the measurements, an MBQC protocol can implement a unitary computation over the input space by introducing a causal structure over the measurements. This is done by allowing any measurement on qubit i to be dependent on the result of some (possibly none) previously measured qubits. Let s i ∈ {0,1} be the classical result of the measurement at qubit i. There are two type of dependences, called X and Z dependences. If a measurement at qubit i is X or Z dependent on the s j where qubit j has already been measured, then the actual angle of the measurement of qubit i during the protocol run is (-1) s j φ i or φ i + s j π , respectively. Naturally one needs a noncyclic structure to be able to run such dependences and for an arbitrary graph such construction (if it exists) is formalized by the notion of the flow of the graph [44,45]. Intuitively, flow captures the propagation of quantum information as the resource state is measured, identifying the locations where measurementdependent corrections should be made (see Fig. 1). A flow is defined by a function (f : O c → I c ) from the measured qubits to noninput qubits and a partial order ( ) over the vertices of the graph such that i f (i)∀i and i j ∀j ∈ N G (f (i)), where N G (k) denotes the neighborhood of vertex k in G. This last property enforces f to be one to one. Each qubit k is X dependent on f -1 (k) and Z dependent on all qubits l such that k ∈ N G (f (l)). Note that if the dependence set is empty, that is, there is no qubit q such that q = f -1 (k) or q ∈ N G (f (l)), FIG. 1. Open graph state with flow. The boxed vertices are the output (nonmeasured) qubits and the circular vertices are the measured qubits. The flow function is represented as arrows (representing the X dependence between measured qubits) and the partial order on the vertices (measurement order) is given by the dotted partition sets. One can see easily how the flow highlights the underlying circuit implemented by the measurement pattern.(iii) The last ingredient is the structure of the dependence among the measurements. It is known that despite the probabilistic nature of the measurements, an MBQC protocol can implement a unitary computation over the input space by introducing a causal structure over the measurements. This is done by allowing any measurement on qubit i to be dependent on the result of some (possibly none) previously measured qubits. Let s i ∈ {0,1} be the classical result of the measurement at qubit i. There are two type of dependences, called X and Z dependences. If a measurement at qubit i is X or Z dependent on the s j where qubit j has already been measured, then the actual angle of the measurement of qubit i during the protocol run is (-1) s j φ i or φ i + s j π , respectively. Naturally one needs a noncyclic structure to be able to run such dependences and for an arbitrary graph such construction (if it exists) is formalized by the notion of the flow of the graph [44,45]. Intuitively, flow captures the propagation of quantum information as the resource state is measured, identifying the locations where measurementdependent corrections should be made (see Fig. 1). A flow is defined by a function (f : O c → I c ) from the measured qubits to noninput qubits and a partial order ( ) over the vertices of the graph such that i f (i)∀i and i j ∀j ∈ N G (f (i)), where N G (k) denotes the neighborhood of vertex k in G. This last property enforces f to be one to one. Each qubit k is X dependent on f -1 (k) and Z dependent on all qubits l such that k ∈ N G (f (l)). Note that if the dependence set is empty, that is, there is no qubit q such that q = f -1 (k) or q ∈ N G (f (l)), FIG. 1. Open graph state with flow. The boxed vertices are the output (nonmeasured) qubits and the circular vertices are the measured qubits. The flow function is represented as arrows (representing the X dependence between measured qubits) and the partial order on the vertices (measurement order) is given by the dotted partition sets. One can see easily how the flow highlights the underlying circuit implemented by the measurement pattern.</p>
        <p>then we set the convention that the corresponding value of s q is zero and hence we can use the same formulas [(-1) s j φ i or φ i + s j π ] to compute the dependent angles. For a given graph, once the input and output qubits have been labeled, the flow, if it exists, is uniquely determined.then we set the convention that the corresponding value of s q is zero and hence we can use the same formulas [(-1) s j φ i or φ i + s j π ] to compute the dependent angles. For a given graph, once the input and output qubits have been labeled, the flow, if it exists, is uniquely determined.</p>
        <p>The above describes only a nondistributed (single-party) MBQC protocol, that is, a protocol where a party both prepares the graph state and performs the sequence of the dependent measurements according to the order given by the flow (see [21,22] for more details on MBQC computation). One can easily extend the above definition to the distributed setting where different elements of the protocol are accessible and known only to specific parties and through classical-quantum communication the parties collaborate to perform a specific computation. Consider a simple two-party example where Alice has the information about the angles and Bob has the information about the graph and hence he can calculate the flow. Then they can collaborate to perform the corresponding computation as follows. First Bob prepares the required graph state and asks Alice to send him the classical information about the angles of the measurement. Bob then computes the dependence and performs the measurement and so forth. The purpose of this paper is to describe a family of such distributed protocols where, despite the communication, Alice can keep the measurement angles hidden from Bob. We then show that, for certain carefully chosen graph families, hiding these angles is sufficient to hide the full underlying computation together with the input and outputs.The above describes only a nondistributed (single-party) MBQC protocol, that is, a protocol where a party both prepares the graph state and performs the sequence of the dependent measurements according to the order given by the flow (see [21,22] for more details on MBQC computation). One can easily extend the above definition to the distributed setting where different elements of the protocol are accessible and known only to specific parties and through classical-quantum communication the parties collaborate to perform a specific computation. Consider a simple two-party example where Alice has the information about the angles and Bob has the information about the graph and hence he can calculate the flow. Then they can collaborate to perform the corresponding computation as follows. First Bob prepares the required graph state and asks Alice to send him the classical information about the angles of the measurement. Bob then computes the dependence and performs the measurement and so forth. The purpose of this paper is to describe a family of such distributed protocols where, despite the communication, Alice can keep the measurement angles hidden from Bob. We then show that, for certain carefully chosen graph families, hiding these angles is sufficient to hide the full underlying computation together with the input and outputs.</p>
        <p>We define a specific family of two-party (Alice and Bob) MBQC protocols (which we term hiding protocols) that can be shown to be "blind" in the sense that Alice can hide information from Bob. For simplicity, instead of working with a family of graphs representing the computation over an arbitrary size input, we fix the input size to be n and we define by m n the total number of vertices in the graph and hence the total number of qubits in the equivalent single-party protocol. Note that if we desire to have an efficient protocol, then we restrict the computation of the protocol to be of the polynomial size by requiring that m = Poly(n). However, blindness is independent of any complexity assumptions, so we do not, in general, restrict the size of m.We define a specific family of two-party (Alice and Bob) MBQC protocols (which we term hiding protocols) that can be shown to be "blind" in the sense that Alice can hide information from Bob. For simplicity, instead of working with a family of graphs representing the computation over an arbitrary size input, we fix the input size to be n and we define by m n the total number of vertices in the graph and hence the total number of qubits in the equivalent single-party protocol. Note that if we desire to have an efficient protocol, then we restrict the computation of the protocol to be of the polynomial size by requiring that m = Poly(n). However, blindness is independent of any complexity assumptions, so we do not, in general, restrict the size of m.</p>
        <p>The protocol will be interactive, having mn steps if the output is quantum or m steps if the output is classical, where at each step a single qubit is measured. In practice, we can parallelize the protocol to D steps, where D is the depth of the partial order of the flow of the graph [46,47]. This is due to the special structure of the partial order of the qubits defined by the flow function whereby all the qubits in the same class of the partial order are independent of each other and hence can be measured in parallel, i.e., at the same time. However, this parallelization will make no difference to the concept of blindness that we are concerned with, so we keep the simple convention that at each step only one qubit is measured. Furthermore, we assume for the case of classical output that all of the output qubits are measured in the final step with a Pauli X measurement. Again, this is simply a convention for the discussion in our paper and in general the output qubits could be measured with any angles and in different steps depending on the flow construction. Such a convention does not affect universality, as the circuit being implemented can simply be modified to replace measurements in arbitrary bases with measurements in fixed bases preceded by an appropriate local rotation.The protocol will be interactive, having mn steps if the output is quantum or m steps if the output is classical, where at each step a single qubit is measured. In practice, we can parallelize the protocol to D steps, where D is the depth of the partial order of the flow of the graph [46,47]. This is due to the special structure of the partial order of the qubits defined by the flow function whereby all the qubits in the same class of the partial order are independent of each other and hence can be measured in parallel, i.e., at the same time. However, this parallelization will make no difference to the concept of blindness that we are concerned with, so we keep the simple convention that at each step only one qubit is measured. Furthermore, we assume for the case of classical output that all of the output qubits are measured in the final step with a Pauli X measurement. Again, this is simply a convention for the discussion in our paper and in general the output qubits could be measured with any angles and in different steps depending on the flow construction. Such a convention does not affect universality, as the circuit being implemented can simply be modified to replace measurements in arbitrary bases with measurements in fixed bases preceded by an appropriate local rotation.</p>
        <p>We will denote by s a sequence of length mn with value in {0,1} describing the result of the nonoutput measurements performed so far. In the case of classical output, where output qubits are measured as the last n steps, s is a sequence of length m. The value associated with a qubit that is not yet measured is set to 0 and hence at the beginning of the protocol before any measurement being performed we set s = 0,0, . . . ,0. We will denote by s i the prefix of length i of s and elements of s are denoted by s i . Whenever adding the values of s i and s j we define their sum modulo 2. All the qubits in the protocol are enumerated in such a way that at position i all qubits with label less than i are measured before measuring qubit i. Any total ordering of the qubits consistent with partial ordering of the flow will work and as a result the measurement at qubit i will depend only on the string s &lt;i .We will denote by s a sequence of length mn with value in {0,1} describing the result of the nonoutput measurements performed so far. In the case of classical output, where output qubits are measured as the last n steps, s is a sequence of length m. The value associated with a qubit that is not yet measured is set to 0 and hence at the beginning of the protocol before any measurement being performed we set s = 0,0, . . . ,0. We will denote by s i the prefix of length i of s and elements of s are denoted by s i . Whenever adding the values of s i and s j we define their sum modulo 2. All the qubits in the protocol are enumerated in such a way that at position i all qubits with label less than i are measured before measuring qubit i. Any total ordering of the qubits consistent with partial ordering of the flow will work and as a result the measurement at qubit i will depend only on the string s &lt;i .</p>
        <p>We describe first a generic hiding protocol with quantum input and output (Protocol 1) and one with classical input and output (Protocol 2) and then formalize various derivatives of them to obtain universal, blind, and verifiable protocols. Protocol 2 is exactly the same as Protocol 1 except that the steps for encoding input are removed and all the output qubits are measured in the Pauli X basis. We retain the common text between the protocols so that they can be understood individually. Note that the reason we choose the measurement of the output qubits to be in the Pauli X basis is purely for simplicity of presentation so that the same evaluation function C of the nonoutput measurements, in Protocol 1, can be used for the output qubits. However, one could add a separate evaluation function for the output qubit measurement to perform Pauli Z measurement over them.We describe first a generic hiding protocol with quantum input and output (Protocol 1) and one with classical input and output (Protocol 2) and then formalize various derivatives of them to obtain universal, blind, and verifiable protocols. Protocol 2 is exactly the same as Protocol 1 except that the steps for encoding input are removed and all the output qubits are measured in the Pauli X basis. We retain the common text between the protocols so that they can be understood individually. Note that the reason we choose the measurement of the output qubits to be in the Pauli X basis is purely for simplicity of presentation so that the same evaluation function C of the nonoutput measurements, in Protocol 1, can be used for the output qubits. However, one could add a separate evaluation function for the output qubit measurement to perform Pauli Z measurement over them.</p>
        <p>The outline of the main protocol is as follows. Alice has in mind a unitary operator U that is implemented with a measurement pattern on some graph state G with its unique flow function f and measurement angles in A = {0,π/4,2π/4, . . . ,7π/4}. This pattern could have been designed either directly within the MBQC framework or via translation from a circuit construction. The pattern assigns a measurement angle φ i to each qubit in G; however, during the execution of the pattern, the actual measurement angle φ i is a modification of φ i that depends on previous measurement outcomes instructed by f in the following way [44,45]:The outline of the main protocol is as follows. Alice has in mind a unitary operator U that is implemented with a measurement pattern on some graph state G with its unique flow function f and measurement angles in A = {0,π/4,2π/4, . . . ,7π/4}. This pattern could have been designed either directly within the MBQC framework or via translation from a circuit construction. The pattern assigns a measurement angle φ i to each qubit in G; however, during the execution of the pattern, the actual measurement angle φ i is a modification of φ i that depends on previous measurement outcomes instructed by f in the following way [44,45]:</p>
        <p>As said before, in a standard MBQC pattern all the noninput qubits are prepared in the state |+ and all the input qubits in the desired input state |I . Considering such quantum input allows for the possibility of Alice having additional capabilities allowing her to produce arbitrary input states or for the possibility that the input state is supplied on Alice's behalf by a third party.As said before, in a standard MBQC pattern all the noninput qubits are prepared in the state |+ and all the input qubits in the desired input state |I . Considering such quantum input allows for the possibility of Alice having additional capabilities allowing her to produce arbitrary input states or for the possibility that the input state is supplied on Alice's behalf by a third party.</p>
        <p>In our protocols, in order to hide the information about the angles some randomness has to be added to the preparation and consequently the measurements have to be adjusted to compensate for this initial randomness to obtain the correct outcome. This randomization has three components: (i) a set of random angles θ used to hide the true measurement angles φ, (ii) a set of random bits r used to hide measurement outcomes, and (iii) a set of random bits x used, along with θ , to hide any quantum input via a one-time pad.In our protocols, in order to hide the information about the angles some randomness has to be added to the preparation and consequently the measurements have to be adjusted to compensate for this initial randomness to obtain the correct outcome. This randomization has three components: (i) a set of random angles θ used to hide the true measurement angles φ, (ii) a set of random bits r used to hide measurement outcomes, and (iii) a set of random bits x used, along with θ , to hide any quantum input via a one-time pad.</p>
        <p>Alice prepares all the noninput qubits inAlice prepares all the noninput qubits in</p>
        <p>) for some randomly chosen θ i ∈ A and also applies a modified version of a full quantum one-time pad encryption over the input qubits using random keys x i ∈ {0,1} and θ i ∈ A as) for some randomly chosen θ i ∈ A and also applies a modified version of a full quantum one-time pad encryption over the input qubits using random keys x i ∈ {0,1} and θ i ∈ A as</p>
        <p>|I before sending all qubits to Bob. After that, Bob entangles qubits according to G. Note that this unavoidably reveals upper bounds on the dimensions of the underlying quantum computation, corresponding to the length of the input and depth of the computation. The computation stage involves interaction: For each qubit, Alice sends Bob a classical message δ i ∈ A to tell him in which basis [in the (X,Y ) plane] he should measure the qubit. This angle is computed in such a way as to correct for the one-time padding of the input qubits and the random rotation of the noninput qubits as|I before sending all qubits to Bob. After that, Bob entangles qubits according to G. Note that this unavoidably reveals upper bounds on the dimensions of the underlying quantum computation, corresponding to the length of the input and depth of the computation. The computation stage involves interaction: For each qubit, Alice sends Bob a classical message δ i ∈ A to tell him in which basis [in the (X,Y ) plane] he should measure the qubit. This angle is computed in such a way as to correct for the one-time padding of the input qubits and the random rotation of the noninput qubits as</p>
        <p>where the last term r i π , with a randomly chosen r i ∈ {0,1}, is added to hide the correct classical outcome of the measurement from Bob without affecting the overall computation (see the correctness proof below). Bob then performs the measurement and communicates the outcome b i to Alice. Alice's choice of angles in future rounds will depend on these values, hence she will correct the obtained outcome by setting s i := b i ⊕ r i . If Alice is computing a classical function, the protocol finishes when all qubits are measured (Protocol 2), as the classical outputs are encoded in the measurement outcomes sent to Alice. If she is computing a quantum function, Bob returns to her the final qubits (Protocol 1) and it is taken that the quantum output is encoded in these qubits. Note that in Protocol 2 we take the input to be |+ ⊗where the last term r i π , with a randomly chosen r i ∈ {0,1}, is added to hide the correct classical outcome of the measurement from Bob without affecting the overall computation (see the correctness proof below). Bob then performs the measurement and communicates the outcome b i to Alice. Alice's choice of angles in future rounds will depend on these values, hence she will correct the obtained outcome by setting s i := b i ⊕ r i . If Alice is computing a classical function, the protocol finishes when all qubits are measured (Protocol 2), as the classical outputs are encoded in the measurement outcomes sent to Alice. If she is computing a quantum function, Bob returns to her the final qubits (Protocol 1) and it is taken that the quantum output is encoded in these qubits. Note that in Protocol 2 we take the input to be |+ ⊗</p>
        <p>For classical input there is no need for a full one-time padding of the input, hence no need for the x i random variables as θ i rotation completely hides the input. The above explanation is the basis for the correctness of all of the protocols presented in this paper.For classical input there is no need for a full one-time padding of the input, hence no need for the x i random variables as θ i rotation completely hides the input. The above explanation is the basis for the correctness of all of the protocols presented in this paper.</p>
        <p>Definition 2. A hiding protocol with quantum input is correct if the quantum output state is U |I or if the classical outputs are the result of Pauli X measurements on the state U |I , where U is the unitary operator corresponding to the implementation of the measurement pattern of the hiding protocol. Similarly, one could define correctness for protocols with classical input.Definition 2. A hiding protocol with quantum input is correct if the quantum output state is U |I or if the classical outputs are the result of Pauli X measurements on the state U |I , where U is the unitary operator corresponding to the implementation of the measurement pattern of the hiding protocol. Similarly, one could define correctness for protocols with classical input.</p>
        <p>Theorem 1 (correctness). Assume Alice and Bob follow the steps of Protocols 1 and 2. Then the outcome is correct.Theorem 1 (correctness). Assume Alice and Bob follow the steps of Protocols 1 and 2. Then the outcome is correct.</p>
        <p>Proof. The correctness of these protocol follows from the correctness of standard measurement-based quantum computation [22], as we now show. We explicitly give a proof only for the case of quantum input and output, as the remaining cases have virtually identical proofs. The protocol deviates in three ways from the standard implementation of the desired measurement pattern defined by a graph state G with measurement angles φ i : a random Z(θ i ) rotation over all qubits, a random X x i rotation over the input qubits, and measuring with angles δ i . However, since CTRL-Z commutes with Z rotations, Alice's preparation does not change the underlying graph state; only the phase of each qubit is locally changed and it is as if Bob had done the Z rotation after the CTRL-Z. Let φ i be the adapted angles of the measurement φ i according to the flow structure of the desired measurement pattern defined by G. Note that a measurement in the {|+ φ i ,|φ i } basis on a state |ψ is the same as a measurement in the {|+ φ i +θ i ,|φ i +θ i } basis on Z(θ i )|ψ . Also a measurement in the {|+ φ i ,|φ i } basis on a state |ψ is the same as a measurement in the {|+ -φ i ,|--φ i } basis on X|ψ . Finally, since δ i = (-1) x i φ i + θ i + πr i , if r i = 0, Bob's measurement has the same effect as Alice's target measurement; if r i = 1, all Alice needs to do is to flip the outcome. Therefore, all the deviation from the actual implementation of the measurement pattern are corrected and the quantum output is the desired state corresponding to the action of the unitary operator implemented by the graph state G over the input state.Proof. The correctness of these protocol follows from the correctness of standard measurement-based quantum computation [22], as we now show. We explicitly give a proof only for the case of quantum input and output, as the remaining cases have virtually identical proofs. The protocol deviates in three ways from the standard implementation of the desired measurement pattern defined by a graph state G with measurement angles φ i : a random Z(θ i ) rotation over all qubits, a random X x i rotation over the input qubits, and measuring with angles δ i . However, since CTRL-Z commutes with Z rotations, Alice's preparation does not change the underlying graph state; only the phase of each qubit is locally changed and it is as if Bob had done the Z rotation after the CTRL-Z. Let φ i be the adapted angles of the measurement φ i according to the flow structure of the desired measurement pattern defined by G. Note that a measurement in the {|+ φ i ,|φ i } basis on a state |ψ is the same as a measurement in the {|+ φ i +θ i ,|φ i +θ i } basis on Z(θ i )|ψ . Also a measurement in the {|+ φ i ,|φ i } basis on a state |ψ is the same as a measurement in the {|+ -φ i ,|--φ i } basis on X|ψ . Finally, since δ i = (-1) x i φ i + θ i + πr i , if r i = 0, Bob's measurement has the same effect as Alice's target measurement; if r i = 1, all Alice needs to do is to flip the outcome. Therefore, all the deviation from the actual implementation of the measurement pattern are corrected and the quantum output is the desired state corresponding to the action of the unitary operator implemented by the graph state G over the input state.</p>
        <p>Note that, in practice, if Alice has the description of a unitary V such that V (⊗ i |+ ) = |I , then trivially a hiding protocol that blindly computes UV over the input states ⊗ i |+ will prepare the desired output state of the form U |I . Therefore, for such a scenario Alice can follow the step of Protocol 1 with classical input without having to prepare the encoded state X x 1 1 Z 1 (θ 1 ) ⊗ • • • ⊗ X x n n Z n (θ n )|I herself. However, we have presented the full protocol for an arbitrary, possibly unknown, quantum input state, since the general scheme proved useful for dealing with input supplied by a third party [39].Note that, in practice, if Alice has the description of a unitary V such that V (⊗ i |+ ) = |I , then trivially a hiding protocol that blindly computes UV over the input states ⊗ i |+ will prepare the desired output state of the form U |I . Therefore, for such a scenario Alice can follow the step of Protocol 1 with classical input without having to prepare the encoded state X x 1 1 Z 1 (θ 1 ) ⊗ • • • ⊗ X x n n Z n (θ n )|I herself. However, we have presented the full protocol for an arbitrary, possibly unknown, quantum input state, since the general scheme proved useful for dealing with input supplied by a third party [39].</p>
        <p>We say a hiding protocol is blind if Bob cannot tell anything relating to the angles of measurements. In considering this it is worth noting that Bob can run the protocol only once with fixed values for Alice's parameters φ i , θ i , r i , and x i . Later we will show how for generic graphs this will lead to hiding the output of the computation as well. Following the convention of [8], we use the notation of a leakage function, denoted by L(X), to formalize what Bob learns during the interaction. We present a stand-alone security definition that is equivalent to the original definition of blindness provided in [3].We say a hiding protocol is blind if Bob cannot tell anything relating to the angles of measurements. In considering this it is worth noting that Bob can run the protocol only once with fixed values for Alice's parameters φ i , θ i , r i , and x i . Later we will show how for generic graphs this will lead to hiding the output of the computation as well. Following the convention of [8], we use the notation of a leakage function, denoted by L(X), to formalize what Bob learns during the interaction. We present a stand-alone security definition that is equivalent to the original definition of blindness provided in [3].</p>
        <p>Definition 3. A hiding protocol P with input X is blind while leaking at most L(X) if the distribution of messages obtained by Bob in P is dependent only on L(X).Definition 3. A hiding protocol P with input X is blind while leaking at most L(X) if the distribution of messages obtained by Bob in P is dependent only on L(X).</p>
        <p>Theorem 2 (blindness). Protocol 1 is blind while leaking at most G and n and Protocol 2 is blind while leaking at most G.Theorem 2 (blindness). Protocol 1 is blind while leaking at most G and n and Protocol 2 is blind while leaking at most G.</p>
        <p>Proof. We first give a proof for the blindness of Protocol 1. We show that given G and n and independent of the actions of Bob, the message registers he receives are always in a maximally mixed state. We begin by introducing a new variable θ i = θ i + r i π for all i. Thus, any quantum input received by Bob during a run of the protocol is given by |eProof. We first give a proof for the blindness of Protocol 1. We show that given G and n and independent of the actions of Bob, the message registers he receives are always in a maximally mixed state. We begin by introducing a new variable θ i = θ i + r i π for all i. Thus, any quantum input received by Bob during a run of the protocol is given by |e</p>
        <p>, while the remaining qubits he receives are in states |+ θ i +r i π for n &lt; i m. Expressed in terms of θ i , δ i becomes independent of r i for all i, since, while the remaining qubits he receives are in states |+ θ i +r i π for n &lt; i m. Expressed in terms of θ i , δ i becomes independent of r i for all i, since</p>
        <p>Thus, only the ith qubit received by Bob is dependent on r i and so tracing over the secret values r simply dephases every qubit in the computational basis. Similarly, only qubit i is dependent on x i for 1 i n and so tracing over x completes the depolarization of the quantum input. Thus every qubit received by Bob is in the maximally mixed state and uncorrelated with all other qubits.Thus, only the ith qubit received by Bob is dependent on r i and so tracing over the secret values r simply dephases every qubit in the computational basis. Similarly, only qubit i is dependent on x i for 1 i n and so tracing over x completes the depolarization of the quantum input. Thus every qubit received by Bob is in the maximally mixed state and uncorrelated with all other qubits.</p>
        <p>Next consider the classical communication used to convey measurement angles during the protocol. The computation of δ i is composed of three terms. The first two terms (-1) s f -1 (i) φ i and j : i∈N G (f (j )) s j π may depend implicitly on b k and δ k for k &lt; i, and on r and x. However, note that the communication received up to step i is independent of θ i , the third term of δ i . Since θ i is uniformly random over A, δ i must also be uniformly random and uncorrelated with previous communication sent to Bob. Thus, all communication in the protocol is uniformly random and uncorrelated, once the random keys (x, r, and θ ) are traced out, independent of the actions of Bob. An identical argument holds for Protocol 2, except that all m qubits are assigned measurements, and hence n is not revealed.Next consider the classical communication used to convey measurement angles during the protocol. The computation of δ i is composed of three terms. The first two terms (-1) s f -1 (i) φ i and j : i∈N G (f (j )) s j π may depend implicitly on b k and δ k for k &lt; i, and on r and x. However, note that the communication received up to step i is independent of θ i , the third term of δ i . Since θ i is uniformly random over A, δ i must also be uniformly random and uncorrelated with previous communication sent to Bob. Thus, all communication in the protocol is uniformly random and uncorrelated, once the random keys (x, r, and θ ) are traced out, independent of the actions of Bob. An identical argument holds for Protocol 2, except that all m qubits are assigned measurements, and hence n is not revealed.</p>
        <p>We note that the above definition is equivalent to a simulator-based definition, since once L(X) is fixed, the distribution of messages Bob receives is also fixed. Hence, Alice could be replaced by a simulator with access only to L(X) and this substitution could not be detected by Bob. A more detailed treatment of simulator-based definitions and composable security can be found in [42].We note that the above definition is equivalent to a simulator-based definition, since once L(X) is fixed, the distribution of messages Bob receives is also fixed. Hence, Alice could be replaced by a simulator with access only to L(X) and this substitution could not be detected by Bob. A more detailed treatment of simulator-based definitions and composable security can be found in [42].</p>
        <p>In order to obtain an intuitive method for achieving verification, we construct an extension of Protocol 1 where Alice can also prepare qubits in the state |z where z is chosen uniformly at random from {0,1}. These qubits are called dummy qubits, as they will not be part of actual computation. A dummy qubit remains disentangled from the rest of the qubits of the graph state and, as we prove later, the addition of these dummy qubits does not affect the correctness or blindness of the hiding protocol. These dummy qubits are measured with random angles, which again will not affect the actual computation due to the fact that they are disentangled from the rest of the qubits. However, as we demonstrate in the next section, these dummy qubits allow Alice to easily create isolated trap qubits within the resource state to enable verification of the computation. Note that Alice must keep the position of the dummy qubits hidden from Bob (i.e., part of the secret) in order to keep the position of any trap qubits hidden. The addition of the dummy qubits can also be viewed as a method for the blind implementation of the Pauli Z basis measurements. This is due to the fact that their position is hidden from Bob and from his point of view they are measured in the (X,Y ) plane as well. However, due to their preparation state (|0 or |1 ) through the entangling step, they have the same effect of measuring the corresponding qubit in the Pauli Z basis. Therefore, we use the term blind Pauli Z measurement interchangeably with dummy qubits in the rest of the paper. Due to the addition of dummy qubits, we will assume from now on that n is an upper bound over the number of the input or output qubits. This is required to allow the possibility of having hidden trap or dummy qubits as part of the input or output system. Therefore, in the design of the measurement pattern, auxiliary qubits are added to the input and output space in such a way that the actual computation remains intact. Protocol 1. Generic hiding protocol with quantum input and output.In order to obtain an intuitive method for achieving verification, we construct an extension of Protocol 1 where Alice can also prepare qubits in the state |z where z is chosen uniformly at random from {0,1}. These qubits are called dummy qubits, as they will not be part of actual computation. A dummy qubit remains disentangled from the rest of the qubits of the graph state and, as we prove later, the addition of these dummy qubits does not affect the correctness or blindness of the hiding protocol. These dummy qubits are measured with random angles, which again will not affect the actual computation due to the fact that they are disentangled from the rest of the qubits. However, as we demonstrate in the next section, these dummy qubits allow Alice to easily create isolated trap qubits within the resource state to enable verification of the computation. Note that Alice must keep the position of the dummy qubits hidden from Bob (i.e., part of the secret) in order to keep the position of any trap qubits hidden. The addition of the dummy qubits can also be viewed as a method for the blind implementation of the Pauli Z basis measurements. This is due to the fact that their position is hidden from Bob and from his point of view they are measured in the (X,Y ) plane as well. However, due to their preparation state (|0 or |1 ) through the entangling step, they have the same effect of measuring the corresponding qubit in the Pauli Z basis. Therefore, we use the term blind Pauli Z measurement interchangeably with dummy qubits in the rest of the paper. Due to the addition of dummy qubits, we will assume from now on that n is an upper bound over the number of the input or output qubits. This is required to allow the possibility of having hidden trap or dummy qubits as part of the input or output system. Therefore, in the design of the measurement pattern, auxiliary qubits are added to the input and output space in such a way that the actual computation remains intact. Protocol 1. Generic hiding protocol with quantum input and output.</p>
        <p>(1) Alice's resources (i) Graph G over m vertices where labeling of vertices is in such a way that the first n qubits are input and the last n qubits are output.(1) Alice's resources (i) Graph G over m vertices where labeling of vertices is in such a way that the first n qubits are input and the last n qubits are output.</p>
        <p>(iv) m random variables θ i with values taken uniformly at random from A.(iv) m random variables θ i with values taken uniformly at random from A.</p>
        <p>(v) n random variables x i and mn random variables r i with values taken uniformly at random from {0,1}.(v) n random variables x i and mn random variables r i with values taken uniformly at random from {0,1}.</p>
        <p>(vi) A fixed function C G that for each nonoutput qubit i (1 i mn) computes the angle of the measurement of qubit i to be sent to Bob. This function depends on φ i ,θ i , r i , x i , and the result of the measurements that have been performed so far (s &lt;i ). The function C G also depends on the flow (f, ) of the graph G. However, since the flow of the graph G is unique (if it exists), we need not take flow as a parameter of the function C G . We have(vi) A fixed function C G that for each nonoutput qubit i (1 i mn) computes the angle of the measurement of qubit i to be sent to Bob. This function depends on φ i ,θ i , r i , x i , and the result of the measurements that have been performed so far (s &lt;i ). The function C G also depends on the flow (f, ) of the graph G. However, since the flow of the graph G is unique (if it exists), we need not take flow as a parameter of the function C G . We have</p>
        <p>where x k for n + 1 k m and also s k for any nondefined value of k is set to zero. (2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Next she sends m qubits in the order of the labeling of the vertices of the graph as follows: First, Alice encodes the n-qubit input state aswhere x k for n + 1 k m and also s k for any nondefined value of k is set to zero. (2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Next she sends m qubits in the order of the labeling of the vertices of the graph as follows: First, Alice encodes the n-qubit input state as</p>
        <p>)|I and sends them as the first n qubits to Bob. She then prepares mn single qubits in the state |+ θ i (n + 1 i m) and sends them to Bob as the remaining qubits. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i:)|I and sends them as the first n qubits to Bob. She then prepares mn single qubits in the state |+ θ i (n + 1 i m) and sends them to Bob as the remaining qubits. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i:</p>
        <p>) and sends it to Bob.) and sends it to Bob.</p>
        <p>(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .</p>
        <p>(iii) Alice's move: Alice sets the value of(iii) Alice's move: Alice sets the value of</p>
        <p>Theorem 3. Assume Alice and Bob follow the steps of Protocol 3. Then the outcome obtained is the same as if the computation took place over the graph G after removal of the dummy vertices in D, the set of positions of dummy qubits in G.Theorem 3. Assume Alice and Bob follow the steps of Protocol 3. Then the outcome obtained is the same as if the computation took place over the graph G after removal of the dummy vertices in D, the set of positions of dummy qubits in G.</p>
        <p>where s k for any nondefined value of k is set to zero and also φ i = 0 for mn + 1 i m.where s k for any nondefined value of k is set to zero and also φ i = 0 for mn + 1 i m.</p>
        <p>(2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Next she sends m qubits in the order of the labeling of the vertices of the graph as follows: First, Alice encodes the n-bit string classical input c 1 , . . . ,c n as state(2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Next she sends m qubits in the order of the labeling of the vertices of the graph as follows: First, Alice encodes the n-bit string classical input c 1 , . . . ,c n as state</p>
        <p>sends them as the first n qubits to Bob. She then prepares mn single qubits in the state |+ θ i (n + 1 i m) and sends them to Bob as the remaining qubits. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i: 1 i m (i) Alice's move: Alice computes the angle δ i = C G (i,φ i ,θ i ,r i ,s) and sends it to Bob.sends them as the first n qubits to Bob. She then prepares mn single qubits in the state |+ θ i (n + 1 i m) and sends them to Bob as the remaining qubits. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i: 1 i m (i) Alice's move: Alice computes the angle δ i = C G (i,φ i ,θ i ,r i ,s) and sends it to Bob.</p>
        <p>(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .</p>
        <p>(iii) Alice's move: Alice sets the value of s i in s to be b i ⊕ r i .(iii) Alice's move: Alice sets the value of s i in s to be b i ⊕ r i .</p>
        <p>Proof. The proof is similar to the proof of Theorem 1; the only new element is the effect of the dummy qubits. If a dummy qubit is in the state |0 , then in the entangling step this qubit does not affect the state of the other qubits. However, if the dummy qubit is in the state |1 then the entangling operation will introduce a Pauli Z rotation on all the neighboring qubits in G. Hence a qubit i ∈ D will be affected by the operator j ∈N G (i)∩D Z d j . In the initial step, Alice already applied the operation j ∈N G (i)∩D Z d j over the prepared qubits and therefore all qubits i ∈ D are in the desired Protocol 3. Generic hiding protocol with quantum input and output and dummy qubits.Proof. The proof is similar to the proof of Theorem 1; the only new element is the effect of the dummy qubits. If a dummy qubit is in the state |0 , then in the entangling step this qubit does not affect the state of the other qubits. However, if the dummy qubit is in the state |1 then the entangling operation will introduce a Pauli Z rotation on all the neighboring qubits in G. Hence a qubit i ∈ D will be affected by the operator j ∈N G (i)∩D Z d j . In the initial step, Alice already applied the operation j ∈N G (i)∩D Z d j over the prepared qubits and therefore all qubits i ∈ D are in the desired Protocol 3. Generic hiding protocol with quantum input and output and dummy qubits.</p>
        <p>(1) Alice's resources (i) Graph G over m vertices where labeling of vertices is in such a way that all the l input qubits are located among the first n l qubits and all the l output qubits are located among the last n qubits.(1) Alice's resources (i) Graph G over m vertices where labeling of vertices is in such a way that all the l input qubits are located among the first n l qubits and all the l output qubits are located among the last n qubits.</p>
        <p>(ii) An l-qubit input state |I .(ii) An l-qubit input state |I .</p>
        <p>(iii) The dummy qubits positions, set D, chosen among all possible vertices except the l input and l output qubits. (iv) A sequence of nonoutput measurement angles φ = (φ i ) 1 i (m-n) with φ i ∈ A, where φ i = 0 for all i ∈ D.(iii) The dummy qubits positions, set D, chosen among all possible vertices except the l input and l output qubits. (iv) A sequence of nonoutput measurement angles φ = (φ i ) 1 i (m-n) with φ i ∈ A, where φ i = 0 for all i ∈ D.</p>
        <p>(v) m random variables θ i with values taken uniformly at random from A.(v) m random variables θ i with values taken uniformly at random from A.</p>
        <p>(vi) l random variables x i , mn random variables r i , and |D| random variables d i with values taken uniformly at random from {0,1}.(vi) l random variables x i , mn random variables r i , and |D| random variables d i with values taken uniformly at random from {0,1}.</p>
        <p>(vii) A fixed function C G that for each nonoutput qubit i (1 i mn) computes the angle of the measurement of qubit i to be sent to Bob,(vii) A fixed function C G that for each nonoutput qubit i (1 i mn) computes the angle of the measurement of qubit i to be sent to Bob,</p>
        <p>where x k for n + 1 k m and s k for any nondefined value of k are set to zero. (2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Alice encodes the l-qubit input state aswhere x k for n + 1 k m and s k for any nondefined value of k are set to zero. (2) Initial step (i) Alice's move: Alice sends Bob the graph G and sets all the values in s to be 0. Alice encodes the l-qubit input state as</p>
        <p>)|I and positions them among the first n qubits. She then prepares the remaining qubits in the following form:)|I and positions them among the first n qubits. She then prepares the remaining qubits in the following form:</p>
        <p>Then Alice sends Bob all m qubits in the order of the labeling of the vertices of the graph. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i: (ii) Alice's move: Alice applies X s f -1 (i) Z j : i∈N G (f (j )) s j Z(θ i ) to qubit i.Then Alice sends Bob all m qubits in the order of the labeling of the vertices of the graph. (ii) Bob's move: Bob receives m single qubits and entangles them according to G. (3) Step i: (ii) Alice's move: Alice applies X s f -1 (i) Z j : i∈N G (f (j )) s j Z(θ i ) to qubit i.</p>
        <p>state |+ θ i , since Z operator is self-inverse. Moreover, all the dummy qubits are unentangled with the rest of qubits and are measured in a random basis with no consequences for the part of the computation taking place over the graph G after removing vertices D. Theorem 4. The hiding protocol with dummy qubits, Protocol 3, is blind while leaking G and n.state |+ θ i , since Z operator is self-inverse. Moreover, all the dummy qubits are unentangled with the rest of qubits and are measured in a random basis with no consequences for the part of the computation taking place over the graph G after removing vertices D. Theorem 4. The hiding protocol with dummy qubits, Protocol 3, is blind while leaking G and n.</p>
        <p>Proof. Proof follows along similar lines of Theorem 2. We define θ i = θ i + πr i + π j ∈N G (i)∩D d i . Alice's total communication to Bob consists of the initial quantum states, which we can rewrite as |+ θ i -πr i if the qubit is not a dummy qubit or ∈ R {|0 ,|1 } if it is a dummy qubit, and the measurement angles, which are set to beProof. Proof follows along similar lines of Theorem 2. We define θ i = θ i + πr i + π j ∈N G (i)∩D d i . Alice's total communication to Bob consists of the initial quantum states, which we can rewrite as |+ θ i -πr i if the qubit is not a dummy qubit or ∈ R {|0 ,|1 } if it is a dummy qubit, and the measurement angles, which are set to be</p>
        <p>As before, the values of δ i are uniformly random since θ i are uniformly random, and for any fixed values of δ i tracing over all r i , we obtain the initial quantum state for each qubit as either 1 2As before, the values of δ i are uniformly random since θ i are uniformly random, and for any fixed values of δ i tracing over all r i , we obtain the initial quantum state for each qubit as either 1 2</p>
        <p>if the qubit was a dummy. Hence the qubits obtained by Bob are always in the maximally mixed state and are not correlated with each other.if the qubit was a dummy. Hence the qubits obtained by Bob are always in the maximally mixed state and are not correlated with each other.</p>
        <p>During a hiding protocol Bob learns the graph of entanglement G; however, it was shown in [3] that it is possible for Alice to choose a family of graphs corresponding to what were termed brickwork states such that blindness of the angles, as defined before, will permit Alice to hide the unitary operator that the protocol is implementing, revealing only an upper bound on the dimensions of the circuit required to implement it. The key element to achieve this is the use of those universal resources for MBQC [48] that are generic, hence revealing no information about the structure of the underlying computation, except the bounds on the size of input and the depth of the computation. Moreover, to make the protocol practical from Alice's point, it is desirable to restrict the class of measurement angles so that the required class of random qubits prepared by Alice is also restricted. Note that exact universal blind quantum computing could be achieved if Alice could prepare separable single-qubit states |+ θ with θ chosen randomly in FIG. 2. Brickwork state G 6×21 . Qubits are arranged according to layer x and row y, corresponding to the vertices in the above graph, and are originally in state |+ . CTRL-Z gates are then performed between qubits that are joined by an edge. A similar resource state was proposed in [50].During a hiding protocol Bob learns the graph of entanglement G; however, it was shown in [3] that it is possible for Alice to choose a family of graphs corresponding to what were termed brickwork states such that blindness of the angles, as defined before, will permit Alice to hide the unitary operator that the protocol is implementing, revealing only an upper bound on the dimensions of the circuit required to implement it. The key element to achieve this is the use of those universal resources for MBQC [48] that are generic, hence revealing no information about the structure of the underlying computation, except the bounds on the size of input and the depth of the computation. Moreover, to make the protocol practical from Alice's point, it is desirable to restrict the class of measurement angles so that the required class of random qubits prepared by Alice is also restricted. Note that exact universal blind quantum computing could be achieved if Alice could prepare separable single-qubit states |+ θ with θ chosen randomly in FIG. 2. Brickwork state G 6×21 . Qubits are arranged according to layer x and row y, corresponding to the vertices in the above graph, and are originally in state |+ . CTRL-Z gates are then performed between qubits that are joined by an edge. A similar resource state was proposed in [50].</p>
        <p>[0,2π ) and if Bob could make any measurement with angles in [0,2π ). Such a model requires Alice to communicate random real angles to Bob and hence such a setting is unattractive from a communications resources point of view. Similar to the quantum circuit scenario, by the Solovay-Kitaev theorem, a finite set of angles (for instance, a set that corresponds to Hadamard and π 8 -phase gates) can be used to efficiently approximate any single-qubit unitary operator. 5 For the rest of this paper we will restrict our attention to approximate universality and we use the fact that a large family of graph states is approximately universal if one restricts the set of angles to be in the set {0, ± π/4, ± π/2} [49]. We give two such examples below. Definition 4. A brickwork state G n×m , where m ≡ 5 or 1 (mod 8), is an entangled state of n×m qubits constructed as follows.[0,2π ) and if Bob could make any measurement with angles in [0,2π ). Such a model requires Alice to communicate random real angles to Bob and hence such a setting is unattractive from a communications resources point of view. Similar to the quantum circuit scenario, by the Solovay-Kitaev theorem, a finite set of angles (for instance, a set that corresponds to Hadamard and π 8 -phase gates) can be used to efficiently approximate any single-qubit unitary operator. 5 For the rest of this paper we will restrict our attention to approximate universality and we use the fact that a large family of graph states is approximately universal if one restricts the set of angles to be in the set {0, ± π/4, ± π/2} [49]. We give two such examples below. Definition 4. A brickwork state G n×m , where m ≡ 5 or 1 (mod 8), is an entangled state of n×m qubits constructed as follows.</p>
        <p>(i) Prepare all qubits in state |+ and assign to each qubit an index (i,j ), i being a row (i ∈ [n]) and j being a column (j ∈ [m]).(i) Prepare all qubits in state |+ and assign to each qubit an index (i,j ), i being a row (i ∈ [n]) and j being a column (j ∈ [m]).</p>
        <p>(ii) For each row, apply the operator CTRL-Z on qubits (i,j ) and (i,j + 1) where 1 j m -1.(ii) For each row, apply the operator CTRL-Z on qubits (i,j ) and (i,j + 1) where 1 j m -1.</p>
        <p>(iii) For each column j ≡ 3 (mod 8) and each odd row i, apply the operator CTRL-Z on qubits (i,j ) and (i + 1,j ) and also on qubits (i,j + 2) and (i + 1,j + 2).(iii) For each column j ≡ 3 (mod 8) and each odd row i, apply the operator CTRL-Z on qubits (i,j ) and (i + 1,j ) and also on qubits (i,j + 2) and (i + 1,j + 2).</p>
        <p>(iv) For each column j ≡ 7 (mod 8) and each even row i, apply the operator CTRL-Z on qubits (i,j ) and (i + 1,j ) and also on qubits (i,j + 2) and (i + 1,j + 2).(iv) For each column j ≡ 7 (mod 8) and each even row i, apply the operator CTRL-Z on qubits (i,j ) and (i + 1,j ) and also on qubits (i,j + 2) and (i + 1,j + 2).</p>
        <p>We will refer to the underlying graph of a brickwork state as the brickwork graph and denote it with the same notation by G n×m (see Fig. 2).We will refer to the underlying graph of a brickwork state as the brickwork graph and denote it with the same notation by G n×m (see Fig. 2).</p>
        <p>Theorem 5 (universality). The brickwork state G n×m is universal for quantum computation. Furthermore, we only require single-qubit measurements under the angles {0, ± π/4, ± π/2} to achieve approximate universality [3] and measurements can be done layer by layer.Theorem 5 (universality). The brickwork state G n×m is universal for quantum computation. Furthermore, we only require single-qubit measurements under the angles {0, ± π/4, ± π/2} to achieve approximate universality [3] and measurements can be done layer by layer.</p>
        <p>Proof. The proof is straightforward (see details in [3]) based on constructing measurement patterns for elements of an approximate set of universal gates that could be tiled together as brickwork states as depicted in Fig. 3.Proof. The proof is straightforward (see details in [3]) based on constructing measurement patterns for elements of an approximate set of universal gates that could be tiled together as brickwork states as depicted in Fig. 3.</p>
        <p>Let us denote vertices of a brickwork graph G n×m by (i,j ) (where 1 i n,1 j m). Then it is easy to verify that the unique flow function of G is defined byLet us denote vertices of a brickwork graph G n×m by (i,j ) (where 1 i n,1 j m). Then it is easy to verify that the unique flow function of G is defined by</p>
        <p>That is to say, the flow of each vertex in the graph is from its immediate left neighbor in the same row. The corresponding partial order ≺ G is defined as the collection of sets L j of all vertices in the j th column of the brickwork graphThat is to say, the flow of each vertex in the graph is from its immediate left neighbor in the same row. The corresponding partial order ≺ G is defined as the collection of sets L j of all vertices in the j th column of the brickwork graph</p>
        <p>Now suppose Alice has in mind a unitary operator U of size 2 n ×2 n and the n-qubit input state |I . Due to Theorem 5 there exist an integer m and angles {φ i,j } 1 i n,1 j m ∈ A such that the measurement pattern with angles {φ i,j } over the brickwork state G n×m , where the first n qubits are set to be in the state |I , approximates U |I . Therefore, the last n qubits after the measurements of the first mn qubits and application of the corresponding corrections induced by flow are in a state that can be made arbitrarily close to U |I . We can simply adapt the generic hiding protocol to implement this measurement pattern blindly as presented in [3].Now suppose Alice has in mind a unitary operator U of size 2 n ×2 n and the n-qubit input state |I . Due to Theorem 5 there exist an integer m and angles {φ i,j } 1 i n,1 j m ∈ A such that the measurement pattern with angles {φ i,j } over the brickwork state G n×m , where the first n qubits are set to be in the state |I , approximates U |I . Therefore, the last n qubits after the measurements of the first mn qubits and application of the corresponding corrections induced by flow are in a state that can be made arbitrarily close to U |I . We can simply adapt the generic hiding protocol to implement this measurement pattern blindly as presented in [3].</p>
        <p>As mentioned in Sec. IV, in order to construct a verification scheme we make use of dummy qubits. While this presents a simple mechanism to achieve isolated trap qubits, the presence of trap and dummy qubits disrupts the computation. However, this can be fixed through a simple modification of the brickwork state. Definition 5. A cylinder brickwork state G C n×m is a modification of the brickwork state of size n×m, for even n, where the first and the last rows are connected such that the regular brickwork structure is preserved, while introducing rotational symmetry. We will refer to the underlying graph of a cylinder brickwork state as the cylinder brickwork graph and denote it with the same notation by G C n×m (see Fig. 4). A tape T i in a cylinder brickwork graph is the subgraph induced by all the nodes of ith and (i + 1)th rows.As mentioned in Sec. IV, in order to construct a verification scheme we make use of dummy qubits. While this presents a simple mechanism to achieve isolated trap qubits, the presence of trap and dummy qubits disrupts the computation. However, this can be fixed through a simple modification of the brickwork state. Definition 5. A cylinder brickwork state G C n×m is a modification of the brickwork state of size n×m, for even n, where the first and the last rows are connected such that the regular brickwork structure is preserved, while introducing rotational symmetry. We will refer to the underlying graph of a cylinder brickwork state as the cylinder brickwork graph and denote it with the same notation by G C n×m (see Fig. 4). A tape T i in a cylinder brickwork graph is the subgraph induced by all the nodes of ith and (i + 1)th rows.</p>
        <p>The cylinder brickwork state allows for a simple construction for trap-based verification, as discussed in Sec. VI. Next we introduce another generic family called dotted-complete graph states (see Fig. 5), which enables significant amplification of the probability of detecting deviations from the computation, particularly in the case of quantum output, as discussed in Sec. VII. The basic idea behind this universal resource state is that it can be partitioned blindly into smaller universal resource states, one of which will be used for the computation, while the others will be used as traps for verification purposes. To begin with, we need to introduce the graphs that we will use and prove that they have some special properties. Definition 6. We define the operator ∼(G) on graph G to be the operator that transforms a graph G to a new graph denoted by G by replacing every edge in G with a new vertex connected to the two vertices originally joined by that edge. Let K N denote the complete graph of N vertices. We call the quantum state corresponding to the graph KN the dotted-complete graphThe cylinder brickwork state allows for a simple construction for trap-based verification, as discussed in Sec. VI. Next we introduce another generic family called dotted-complete graph states (see Fig. 5), which enables significant amplification of the probability of detecting deviations from the computation, particularly in the case of quantum output, as discussed in Sec. VII. The basic idea behind this universal resource state is that it can be partitioned blindly into smaller universal resource states, one of which will be used for the computation, while the others will be used as traps for verification purposes. To begin with, we need to introduce the graphs that we will use and prove that they have some special properties. Definition 6. We define the operator ∼(G) on graph G to be the operator that transforms a graph G to a new graph denoted by G by replacing every edge in G with a new vertex connected to the two vertices originally joined by that edge. Let K N denote the complete graph of N vertices. We call the quantum state corresponding to the graph KN the dotted-complete graph</p>
        <p>5. Example of the relationship between a complete graph K 4 and the corresponding dotted-complete graph K4 . The vertices in black in K4 denote the set P ( K4 ), while the white vertices correspond to A( K4 ). state denoted by KN . We denote the set of vertices of KN previously inherited from K N by P ( KN ) and the vertices added by the ∼( ) operation by A( KN ). The number of the vertices in the KN graph is then equal to N (N + 1)/2.5. Example of the relationship between a complete graph K 4 and the corresponding dotted-complete graph K4 . The vertices in black in K4 denote the set P ( K4 ), while the white vertices correspond to A( K4 ). state denoted by KN . We denote the set of vertices of KN previously inherited from K N by P ( KN ) and the vertices added by the ∼( ) operation by A( KN ). The number of the vertices in the KN graph is then equal to N (N + 1)/2.</p>
        <p>The following definition and lemmas will be used in manipulation of dotted-complete graph states.The following definition and lemmas will be used in manipulation of dotted-complete graph states.</p>
        <p>Definition 7. We define the bridge operator on a vertex v of degree 2 on graph G to be the operator that connects the two neighbors of v and then removes vertex v and any associated edges from G. We define the break operator on a vertex v of graph G to be the operator that removes vertex v and any associated edges from G. Let G be a graph on m vertices. Then we say that G is n universal, for n m, if and only if any graph of n vertices can be obtained from G through a sequence of bridges and breaks.Definition 7. We define the bridge operator on a vertex v of degree 2 on graph G to be the operator that connects the two neighbors of v and then removes vertex v and any associated edges from G. We define the break operator on a vertex v of graph G to be the operator that removes vertex v and any associated edges from G. Let G be a graph on m vertices. Then we say that G is n universal, for n m, if and only if any graph of n vertices can be obtained from G through a sequence of bridges and breaks.</p>
        <p>Lemma 1. KN is N universal and the bridge and break operations used to obtain a target graph need only be performed on vertices in A( KN ).Lemma 1. KN is N universal and the bridge and break operations used to obtain a target graph need only be performed on vertices in A( KN ).</p>
        <p>Proof. Given any graph G on N vertices, associate each vertex u i in G with a vertex v i in P ( KN ). Each pair of vertices (v i ,v j ) in P ( KN ) is connected through an intermediate vertex of degree 2 in A( KN ). Thus, by bridging over the intermediate vertex if u i and u j are joined by an edge and breaking the intermediate vertex otherwise, KN reduces to G. As this is true for all graphs G on N vertices, KN is N universal.Proof. Given any graph G on N vertices, associate each vertex u i in G with a vertex v i in P ( KN ). Each pair of vertices (v i ,v j ) in P ( KN ) is connected through an intermediate vertex of degree 2 in A( KN ). Thus, by bridging over the intermediate vertex if u i and u j are joined by an edge and breaking the intermediate vertex otherwise, KN reduces to G. As this is true for all graphs G on N vertices, KN is N universal.</p>
        <p>Lemma 2. Given a partitioning of the vertices P ( KN ) into n sets {P i } containing N i vertices, respectively, by applying a sequence of break operations only, it is possible to transform KN into n disconnected graphs ki such that each one of them is of the form KN i and P ( ki ) = P i .Lemma 2. Given a partitioning of the vertices P ( KN ) into n sets {P i } containing N i vertices, respectively, by applying a sequence of break operations only, it is possible to transform KN into n disconnected graphs ki such that each one of them is of the form KN i and P ( ki ) = P i .</p>
        <p>Proof. As the vertices P ( KN ) are associated with a corresponding vertex in K N , the vertices of K N can be partitioned into the sets {P i }. As K N is the complete graph the vertices within each partition P i form a clique. Thus, by removing edges between the partitions the resulting graph is composed of n disconnected graphs {k i = K N i } such that the vertices in k i are the vertices in P i . As removing an edge before applying the ∼( ) operator is equivalent to applying a break operation after the ∼( ) operator there exists a corresponding sequence of break operations such that the resulting graph is ∼({k i }) = { ki }. As ki =∼(k i ), it follows that P ( ki ) = P i and since k i = K N i then ki = KN i as required.Proof. As the vertices P ( KN ) are associated with a corresponding vertex in K N , the vertices of K N can be partitioned into the sets {P i }. As K N is the complete graph the vertices within each partition P i form a clique. Thus, by removing edges between the partitions the resulting graph is composed of n disconnected graphs {k i = K N i } such that the vertices in k i are the vertices in P i . As removing an edge before applying the ∼( ) operator is equivalent to applying a break operation after the ∼( ) operator there exists a corresponding sequence of break operations such that the resulting graph is ∼({k i }) = { ki }. As ki =∼(k i ), it follows that P ( ki ) = P i and since k i = K N i then ki = KN i as required.</p>
        <p>Lemma 3. Given a graph KN , by applying break operators to every vertex in P ( KN ) or A( KN ), the resulting graph is composed of the vertices of A( KN ) or P ( KN ), respectively, and contains no edges.Lemma 3. Given a graph KN , by applying break operators to every vertex in P ( KN ) or A( KN ), the resulting graph is composed of the vertices of A( KN ) or P ( KN ), respectively, and contains no edges.</p>
        <p>Proof. As the ∼( ) operation only introduces vertices connected to vertices in P ( KN ), every vertex in A( KN ) shares edges only with vertices in P ( KN ). Thus, when the vertices in P ( KN ) and their associated edges are removed by the break operators, the vertices in A( KN ) become disconnected. Similarly, since ∼( ) removes all edges between vertices in P ( KN ), every vertex in P ( KN ) shares edges only with vertices in A( KN ). Thus, when the vertices in A( KN ) and their associated edges are removed by the break operators, the vertices in P ( KN ) become disconnected.Proof. As the ∼( ) operation only introduces vertices connected to vertices in P ( KN ), every vertex in A( KN ) shares edges only with vertices in P ( KN ). Thus, when the vertices in P ( KN ) and their associated edges are removed by the break operators, the vertices in A( KN ) become disconnected. Similarly, since ∼( ) removes all edges between vertices in P ( KN ), every vertex in P ( KN ) shares edges only with vertices in A( KN ). Thus, when the vertices in A( KN ) and their associated edges are removed by the break operators, the vertices in P ( KN ) become disconnected.</p>
        <p>We now extend these results to graph states. Lemma 4. Given two graph states |ψ G 1 and |ψ G 2 corresponding to graphs G 1 and G 2 , respectively, if it is possible to obtain G 2 from G 1 through a sequence of bridge and break operations, then it is possible to obtain |ψ G 2 from |ψ G 1 through a sequence of Pauli measurements and local rotations about the Z axis through angles from the set {0, π 2 ,π, 3π 2 }. Proof. By measuring any qubit in a graph state with a Pauli Z operator, we obtain a state equivalent up to local Pauli Z corrections to the graph state obtained from the graph when that vertex and its associated edges are removed. To see this, we consider the operations this qubit undergoes: It is first prepared in a state |+ , then it interacts with its neighbors via CTRL-Z gates, and then it is measured in the Z basis. As the measurement commutes with the entangling operation, this result is identical to the case where the CTRL-Z gates are applied to the measured eigenstate of Z. Thus, when the complete sequence of events is taken into account, this operation is equivalent to the identity when the measurement outcome is 0 and equivalent to local Pauli Z operators applied to the neighbors of the measured site when the measurement outcome is 1. This is then the graph state equivalent of the break operation defined on the associated graph.We now extend these results to graph states. Lemma 4. Given two graph states |ψ G 1 and |ψ G 2 corresponding to graphs G 1 and G 2 , respectively, if it is possible to obtain G 2 from G 1 through a sequence of bridge and break operations, then it is possible to obtain |ψ G 2 from |ψ G 1 through a sequence of Pauli measurements and local rotations about the Z axis through angles from the set {0, π 2 ,π, 3π 2 }. Proof. By measuring any qubit in a graph state with a Pauli Z operator, we obtain a state equivalent up to local Pauli Z corrections to the graph state obtained from the graph when that vertex and its associated edges are removed. To see this, we consider the operations this qubit undergoes: It is first prepared in a state |+ , then it interacts with its neighbors via CTRL-Z gates, and then it is measured in the Z basis. As the measurement commutes with the entangling operation, this result is identical to the case where the CTRL-Z gates are applied to the measured eigenstate of Z. Thus, when the complete sequence of events is taken into account, this operation is equivalent to the identity when the measurement outcome is 0 and equivalent to local Pauli Z operators applied to the neighbors of the measured site when the measurement outcome is 1. This is then the graph state equivalent of the break operation defined on the associated graph.</p>
        <p>If a vertex is of degree 2, then measuring the associated qubit with the Pauli Y operator yields the graph state corresponding to the graph obtained by applying a bridge operation to that vertex, up to local Z rotations through an angle ± π 2 . To see this, we again consider the sequence of operations the qubit undergoes: It is prepared in the state |+ , interacts with its neighbors, and then is measured in the Y basis. Immediately prior to measurement, the net operator applied is 1If a vertex is of degree 2, then measuring the associated qubit with the Pauli Y operator yields the graph state corresponding to the graph obtained by applying a bridge operation to that vertex, up to local Z rotations through an angle ± π 2 . To see this, we again consider the sequence of operations the qubit undergoes: It is prepared in the state |+ , interacts with its neighbors, and then is measured in the Y basis. Immediately prior to measurement, the net operator applied is 1</p>
        <p>where the subscripts 1 and 2 denote the neighbors of the measured qubit. Thus, if the measurement result is 0, then this is equivalent to directly applying the operator e i(π/4)Z 1 ⊗Z 2 to the neighboring qubits, whereas if the measurement result is 1 this is equivalent to applying the operator e -i(π/4)Z 1 ⊗Z 2 to these qubits. Since the CTRL-Z gate can be written as either e i(π/4)(I-Z⊗I-I⊗Z+Z⊗Z) or e -i(π/4)(I-Z⊗I-I⊗Z+Z⊗Z) , the effect on the neighboring qubits is equivalent to a CTRL-Z, up to local Z rotations by π 2 (for a measurement result of 0) or -π 2 (for a measurement result of 1). This could also be derived via the stabilizer formalism. For a more detailed discussion of the effect of Pauli measurements in the measurement-based model, the reader is referred to [51].where the subscripts 1 and 2 denote the neighbors of the measured qubit. Thus, if the measurement result is 0, then this is equivalent to directly applying the operator e i(π/4)Z 1 ⊗Z 2 to the neighboring qubits, whereas if the measurement result is 1 this is equivalent to applying the operator e -i(π/4)Z 1 ⊗Z 2 to these qubits. Since the CTRL-Z gate can be written as either e i(π/4)(I-Z⊗I-I⊗Z+Z⊗Z) or e -i(π/4)(I-Z⊗I-I⊗Z+Z⊗Z) , the effect on the neighboring qubits is equivalent to a CTRL-Z, up to local Z rotations by π 2 (for a measurement result of 0) or -π 2 (for a measurement result of 1). This could also be derived via the stabilizer formalism. For a more detailed discussion of the effect of Pauli measurements in the measurement-based model, the reader is referred to [51].</p>
        <p>Theorem 6 (universality). The dotted-complete graph state KN is universal for quantum computation. Furthermore, we only require single-qubit measurements under the angles {0, ± π/4, ± π/2} and in the Pauli Z basis to achieve approximate universality, and measurements can be done layer-by-layer.Theorem 6 (universality). The dotted-complete graph state KN is universal for quantum computation. Furthermore, we only require single-qubit measurements under the angles {0, ± π/4, ± π/2} and in the Pauli Z basis to achieve approximate universality, and measurements can be done layer-by-layer.</p>
        <p>Proof. Due to Lemmas 1 and 4, by choosing N big enough, we could construct the brickwork state G n×m from KN using only Pauli measurements. Hence, from Theorem 5 we obtain the universality of dotted-complete graph states and approximate universality with only single-qubit measurements under the angles {0, ± π/4, ± π/2} (which include the Pauli Y measurements required to implement bridge operations) and the Pauli Z basis measurements required to implement break operations.Proof. Due to Lemmas 1 and 4, by choosing N big enough, we could construct the brickwork state G n×m from KN using only Pauli measurements. Hence, from Theorem 5 we obtain the universality of dotted-complete graph states and approximate universality with only single-qubit measurements under the angles {0, ± π/4, ± π/2} (which include the Pauli Y measurements required to implement bridge operations) and the Pauli Z basis measurements required to implement break operations.</p>
        <p>From this result we can construct a new universal hiding protocol based on dotted-complete graph states, as given in Protocol 4. Interestingly, in the case of classical input and output this new protocol does not even reveal the circuit dimensions, but instead a single integer that is an upper bound on the number of qubits required to implement the computation in the measurement-based model. (1) Alice's resources (i) Parameter N such that the desired computation could be obtained from the state KN after a sequence of break and bridge operators (Theorem 6). The labeling of vertices is in such a way that the first n qubits are input and the last n qubits are output.From this result we can construct a new universal hiding protocol based on dotted-complete graph states, as given in Protocol 4. Interestingly, in the case of classical input and output this new protocol does not even reveal the circuit dimensions, but instead a single integer that is an upper bound on the number of qubits required to implement the computation in the measurement-based model. (1) Alice's resources (i) Parameter N such that the desired computation could be obtained from the state KN after a sequence of break and bridge operators (Theorem 6). The labeling of vertices is in such a way that the first n qubits are input and the last n qubits are output.</p>
        <p>(ii) The dummy qubits position, set D, is set to be the position of all the qubits that are required to be Pauli Z measured for performing the break operators. (iii) A sequence of nonoutput measurement angles φ = (φ i ) 1 i (m-n) with φ i ∈ A, where φ i = π 2 for all i ∈ D and also for all the qubits that are required to be Pauli Y measured to perform the bridge operators. (iv) The rest of the resources are the same as Protocol 3. Follow the steps of Protocol 3 where G is replaced with KN .(ii) The dummy qubits position, set D, is set to be the position of all the qubits that are required to be Pauli Z measured for performing the break operators. (iii) A sequence of nonoutput measurement angles φ = (φ i ) 1 i (m-n) with φ i ∈ A, where φ i = π 2 for all i ∈ D and also for all the qubits that are required to be Pauli Y measured to perform the bridge operators. (iv) The rest of the resources are the same as Protocol 3. Follow the steps of Protocol 3 where G is replaced with KN .</p>
        <p>Theorem 7. Protocol 4 is blind, while leaking at most n and N.Theorem 7. Protocol 4 is blind, while leaking at most n and N.</p>
        <p>Proof. As Bob entangles according to KN , clearly the parameter N is leaked. Additionally, in the case of quantum output, Bob must be instructed how many qubits to return to Alice and hence knows n. However, fixing these parameters, due to Theorem 2, all the measurement angles including the measurements for the bridge operators are blind to Bob. Similarly, from Theorem 4 we have blindness for the measurement corresponding to the break operators. Together these guarantee the blindness of the operations required to prepare a brickwork state from KN . Finally, Theorem 2 proved the blindness of the remaining measurements performed on the prepared brickwork state.Proof. As Bob entangles according to KN , clearly the parameter N is leaked. Additionally, in the case of quantum output, Bob must be instructed how many qubits to return to Alice and hence knows n. However, fixing these parameters, due to Theorem 2, all the measurement angles including the measurements for the bridge operators are blind to Bob. Similarly, from Theorem 4 we have blindness for the measurement corresponding to the break operators. Together these guarantee the blindness of the operations required to prepare a brickwork state from KN . Finally, Theorem 2 proved the blindness of the remaining measurements performed on the prepared brickwork state.</p>
        <p>This section deals with another property of the hiding protocol called verification. This property requires that Alice can verify with high probability whether Bob has followed the instructions of the protocol and hence if the quantum or classical output state is indeed in the correct form or whether there has been a deviation and she should therefore reject the output state. The main idea is to exploit blindness so that Alice can expand the protocol to include trap qubits where Alice knows in advance the classical outcome of these specific measurements (i.e., the correct message from Bob for these measurements), where the blindness ensures that the position of these traps remains hidden from Bob. At the end Alice will accept the quantum or classical output only if Bob has produced all of the expected outcomes for these trap qubits measurements. The subtlety in verification is to prove that the accepted quantum or classical output is indeed correct.This section deals with another property of the hiding protocol called verification. This property requires that Alice can verify with high probability whether Bob has followed the instructions of the protocol and hence if the quantum or classical output state is indeed in the correct form or whether there has been a deviation and she should therefore reject the output state. The main idea is to exploit blindness so that Alice can expand the protocol to include trap qubits where Alice knows in advance the classical outcome of these specific measurements (i.e., the correct message from Bob for these measurements), where the blindness ensures that the position of these traps remains hidden from Bob. At the end Alice will accept the quantum or classical output only if Bob has produced all of the expected outcomes for these trap qubits measurements. The subtlety in verification is to prove that the accepted quantum or classical output is indeed correct.</p>
        <p>It is essential that Alice keeps the position of these trap qubits unknown to Bob so that he cannot attempt to interfere with the actual computation of U while keeping the trap qubits untouched. We will present a protocol where every qubit of the underlying graph could potentially be an isolated (unentangled) trap qubit in an unknown state |+ θ for θ ∈ A. In order to do so, it is enough to prepare all the neighboring vertices of the trap qubit as dummy qubits; hence these dummy qubits together with the trap qubits remain disentangled from the rest of the graph during the preparation stage. Building on this simple construction, by adding more traps and adding error detection elements, we will present a final protocol in which the probability of not detecting an incorrect outcome is exponentially small.It is essential that Alice keeps the position of these trap qubits unknown to Bob so that he cannot attempt to interfere with the actual computation of U while keeping the trap qubits untouched. We will present a protocol where every qubit of the underlying graph could potentially be an isolated (unentangled) trap qubit in an unknown state |+ θ for θ ∈ A. In order to do so, it is enough to prepare all the neighboring vertices of the trap qubit as dummy qubits; hence these dummy qubits together with the trap qubits remain disentangled from the rest of the graph during the preparation stage. Building on this simple construction, by adding more traps and adding error detection elements, we will present a final protocol in which the probability of not detecting an incorrect outcome is exponentially small.</p>
        <p>In order to first demonstrate the main idea of this method of verification, we ignore the universality property and only later will we present a concrete universal blind quantum computing protocol with the verification property. Hence, to obtain a generic hiding protocol with a random unknown trap it is sufficient to use Protocol 3, where Alice chooses a random position t to be an isolated trap qubit (Protocol 5).In order to first demonstrate the main idea of this method of verification, we ignore the universality property and only later will we present a concrete universal blind quantum computing protocol with the verification property. Hence, to obtain a generic hiding protocol with a random unknown trap it is sufficient to use Protocol 3, where Alice chooses a random position t to be an isolated trap qubit (Protocol 5).</p>
        <p>Protocol 5. Generic hiding quantum computation for unitary with dummy, trap, and quantum input and output.Protocol 5. Generic hiding quantum computation for unitary with dummy, trap, and quantum input and output.</p>
        <p>(1) Alice's resources (i) Graph G over m vertices and a random position t among the vertices of G.(1) Alice's resources (i) Graph G over m vertices and a random position t among the vertices of G.</p>
        <p>(ii) The rest of the resources are the same as Protocol 3, where φ i = 0 for i = t and i ∈ D, where D contains the set of all neighbors of position t in the original graph to create an isolated trap qubit at position t. (2) Follow the steps of Protocol 3.(ii) The rest of the resources are the same as Protocol 3, where φ i = 0 for i = t and i ∈ D, where D contains the set of all neighbors of position t in the original graph to create an isolated trap qubit at position t. (2) Follow the steps of Protocol 3.</p>
        <p>(3) Accept or reject (i) After obtaining all the output qubits from Bob, if the trap qubit t is an output qubit, Alice measures it with angle δ t = θ t + r t π to obtain b t .(3) Accept or reject (i) After obtaining all the output qubits from Bob, if the trap qubit t is an output qubit, Alice measures it with angle δ t = θ t + r t π to obtain b t .</p>
        <p>(ii) Alice accepts if b t = r t .(ii) Alice accepts if b t = r t .</p>
        <p>Theorem 4 directly implies that Protocol 5 is blind and the position of the trap qubits t remains unknown to Bob. Recall that at each stage i only qubit i is measured. We present some intermediate definitions before formalizing the definition of verification. All the protocols presented so far describe the expected behavior of Alice and Bob in a hiding protocol. Since we are concerned with the secrecy of Alice's resources we can assume that Alice always follows the steps of the protocol. In fact, after the initial step when Alice draws all the random variables θ i and r i her behavior, for a fixed run of the protocol, is deterministic. This means that at each step the next move of Alice is determined completely by the past; however; a malicious Bob might deviate in any way he desires. We will define a run of protocol to be honest (Bob has behaved as expected) or correct (the output is correct despite Bob's deviations) based on the outcome of all measurements and the quantum output state if it exists.Theorem 4 directly implies that Protocol 5 is blind and the position of the trap qubits t remains unknown to Bob. Recall that at each stage i only qubit i is measured. We present some intermediate definitions before formalizing the definition of verification. All the protocols presented so far describe the expected behavior of Alice and Bob in a hiding protocol. Since we are concerned with the secrecy of Alice's resources we can assume that Alice always follows the steps of the protocol. In fact, after the initial step when Alice draws all the random variables θ i and r i her behavior, for a fixed run of the protocol, is deterministic. This means that at each step the next move of Alice is determined completely by the past; however; a malicious Bob might deviate in any way he desires. We will define a run of protocol to be honest (Bob has behaved as expected) or correct (the output is correct despite Bob's deviations) based on the outcome of all measurements and the quantum output state if it exists.</p>
        <p>Recall that in a generic hiding protocol with quantum input and output the messages sent by Bob to Alice depend on a collection of outcome measurements, s i ∈ {0,1}. In fact, Bob will send the outcome value b i and then Alice, depending on r i , will reset them to their corrected values s i . In what follows we will deal with the corrected outcome measurement, that is, s i . Similarly, at the end of the protocol Bob will send Alice some quantum output state in the output Hilbert space H O that needs to be corrected depending on all the measurements outcomes. In what follows we consider the corrected quantum output state ρ. Note that the values of s i and ρ depend on Alice's specific random choices and also Bob's general strategy of deviation. We treat this information as a single density operator to deal uniformly with both classical and quantum output. Finally, in order to consider the most general deviation that Bob can perform during a run of protocol we consider a collection of unitary operators, each acting at a stage of the protocol on the private qubits of Bob and all the other qubits and classical bits sent by Alice to Bob. Definition 8. Consider a particular run of a generic hiding protocol, where all the following parameters are fixed: Alice's angles of measurements φ = (φ i ) 1 i (m-n) ; Alice's random variables x = (x i ) 1 i n , r = (r i ) 1 i (m-n) , θ = (θ i ) 1 i m , and d = (d i ) i∈D ; Alice's input state |I ; the number of Bob's private qubits B; and Bob's deviation unitaries at each stage of the protocol U = {U i } 0 i m+1 acting on all quantum and classical messages. We define the outcome density operator (of all classical and quantum messages sent by Bob to Alice) as follows:Recall that in a generic hiding protocol with quantum input and output the messages sent by Bob to Alice depend on a collection of outcome measurements, s i ∈ {0,1}. In fact, Bob will send the outcome value b i and then Alice, depending on r i , will reset them to their corrected values s i . In what follows we will deal with the corrected outcome measurement, that is, s i . Similarly, at the end of the protocol Bob will send Alice some quantum output state in the output Hilbert space H O that needs to be corrected depending on all the measurements outcomes. In what follows we consider the corrected quantum output state ρ. Note that the values of s i and ρ depend on Alice's specific random choices and also Bob's general strategy of deviation. We treat this information as a single density operator to deal uniformly with both classical and quantum output. Finally, in order to consider the most general deviation that Bob can perform during a run of protocol we consider a collection of unitary operators, each acting at a stage of the protocol on the private qubits of Bob and all the other qubits and classical bits sent by Alice to Bob. Definition 8. Consider a particular run of a generic hiding protocol, where all the following parameters are fixed: Alice's angles of measurements φ = (φ i ) 1 i (m-n) ; Alice's random variables x = (x i ) 1 i n , r = (r i ) 1 i (m-n) , θ = (θ i ) 1 i m , and d = (d i ) i∈D ; Alice's input state |I ; the number of Bob's private qubits B; and Bob's deviation unitaries at each stage of the protocol U = {U i } 0 i m+1 acting on all quantum and classical messages. We define the outcome density operator (of all classical and quantum messages sent by Bob to Alice) as follows:</p>
        <p>where ν collectively denotes Alice's choice of variables t, x, r, θ , and d; j ranges over Bob's choices B and U; s ranges over all possible values of the corrected values {s i } of the measurement outcomes {b i } sent by Bob to Alice; and ρ s ν,j is the reduced density operator for the nonmeasured qubits with the corresponding correction operators for the measurement outcomes s has been applied. We call the outcome density operator B 0 (ν), obtained from a run of the protocol where all U i are set to be the identity operator, the exact outcome density operator. This is the outcome density operator obtained from a run where Bob exactly follows the step of the protocol.where ν collectively denotes Alice's choice of variables t, x, r, θ , and d; j ranges over Bob's choices B and U; s ranges over all possible values of the corrected values {s i } of the measurement outcomes {b i } sent by Bob to Alice; and ρ s ν,j is the reduced density operator for the nonmeasured qubits with the corresponding correction operators for the measurement outcomes s has been applied. We call the outcome density operator B 0 (ν), obtained from a run of the protocol where all U i are set to be the identity operator, the exact outcome density operator. This is the outcome density operator obtained from a run where Bob exactly follows the step of the protocol.</p>
        <p>Note that if we were dealing only with a deterministic pattern over a connected graph state then the outcome density operator could have been simplified to a fixed pure state of the output qubits, independent of the measurement outcomes. Moreover, in such a scenario the probability of each branch of the computation would have been the same. However, the above definition aims to capture any general deviation by Bob that could affect the determinism and probability of the branches. Also, since we will have dummy and trap qubits, then not all the possible branches will be equally probable. The outcome density operator, depending on all the random choices of Alice and Bob, can be classified as follows below. Although not all mentioned categories will be used in the remainder of the paper, we give them here for completeness and to highlight the subtle differences between possible outcomes. Definition 9. We say the outcome density operator B j (ν) is honest if it is indistinguishable from the exact outcome density operatorNote that if we were dealing only with a deterministic pattern over a connected graph state then the outcome density operator could have been simplified to a fixed pure state of the output qubits, independent of the measurement outcomes. Moreover, in such a scenario the probability of each branch of the computation would have been the same. However, the above definition aims to capture any general deviation by Bob that could affect the determinism and probability of the branches. Also, since we will have dummy and trap qubits, then not all the possible branches will be equally probable. The outcome density operator, depending on all the random choices of Alice and Bob, can be classified as follows below. Although not all mentioned categories will be used in the remainder of the paper, we give them here for completeness and to highlight the subtle differences between possible outcomes. Definition 9. We say the outcome density operator B j (ν) is honest if it is indistinguishable from the exact outcome density operator</p>
        <p>where • tr denotes the trace norm. It is called correct if the quantum output state and the trap outcome measurement is indistinguishable from the corresponding value of the exact outcome density operator:where • tr denotes the trace norm. It is called correct if the quantum output state and the trap outcome measurement is indistinguishable from the corresponding value of the exact outcome density operator:</p>
        <p>It is called lucky if b t = r t and finally it is called incorrect if it is lucky but the quantum output state Tr i ∈{O\{t}} [B j (ν)] is orthogonal to the corresponding subsystem of the exact outcome density operator. Note that for the classical output scenario, any bit flip implies orthogonality.It is called lucky if b t = r t and finally it is called incorrect if it is lucky but the quantum output state Tr i ∈{O\{t}} [B j (ν)] is orthogonal to the corresponding subsystem of the exact outcome density operator. Note that for the classical output scenario, any bit flip implies orthogonality.</p>
        <p>Alice should not care if Bob's deviation leads to a correct outcome density operator, as the final quantum or classical output is in the correct state. Therefore, in the definition of a verifiable blind quantum computation we aim to bound the probability of Alice being fooled, i.e., the probability of Alice accepting an incorrect outcome density operator. Any outcome density operator either results in s t = r t or is contained within the subspace of correct and incorrect outcome states. Hence, intuitively, a protocol is defined to be verifiable if the corresponding outcome state is far from any incorrect outcome states. Following the approach of [52], we first define the notion of correctness. Recall that for simplicity we have assumed that the computation is deterministic and the input is in a pure state and hence the ideal output will necessarily be a pure state. This restriction to pure states mirrors the approach of [52].Alice should not care if Bob's deviation leads to a correct outcome density operator, as the final quantum or classical output is in the correct state. Therefore, in the definition of a verifiable blind quantum computation we aim to bound the probability of Alice being fooled, i.e., the probability of Alice accepting an incorrect outcome density operator. Any outcome density operator either results in s t = r t or is contained within the subspace of correct and incorrect outcome states. Hence, intuitively, a protocol is defined to be verifiable if the corresponding outcome state is far from any incorrect outcome states. Following the approach of [52], we first define the notion of correctness. Recall that for simplicity we have assumed that the computation is deterministic and the input is in a pure state and hence the ideal output will necessarily be a pure state. This restriction to pure states mirrors the approach of [52].</p>
        <p>Definition 10. Let P ν incorrect be the projection onto the subspace of all the possible incorrect outcome density operators for the fixed choice of Alice's random variables ν. It will be convenient to divide ν into two subsets depending on whether the secret variables correspond to the trap setting or the remainder of the computation. Thus we define ν T = {t,r t ,θ t } and ν C = ν/ν T . When the output state is a pure state, P ν incorrect is given byDefinition 10. Let P ν incorrect be the projection onto the subspace of all the possible incorrect outcome density operators for the fixed choice of Alice's random variables ν. It will be convenient to divide ν into two subsets depending on whether the secret variables correspond to the trap setting or the remainder of the computation. Thus we define ν T = {t,r t ,θ t } and ν C = ν/ν T . When the output state is a pure state, P ν incorrect is given by</p>
        <p>] and where |η ν T t = |+ θ t when t ∈ O and |η ν T t = |r t otherwise. Let p(ν) be the probability of Alice choosing random variables parametrized by ν, that is, the probability of choosing a particular vertex, among all possible vertices of the graph, to be the trap position (denoted by a random variable t) and the probability of choosing random variables r, x, θ , and d (as defined in Definition 8). Given 0 &lt; 1, we define a protocol to be verifiable if for any choice of Bob's strategy (defined as in Definition 8 and denoted by the index j ) the probability of Alice accepting an incorrect outcome density operator is bounded by : Tr ν p(ν)P ν incorrect B j (ν) .] and where |η ν T t = |+ θ t when t ∈ O and |η ν T t = |r t otherwise. Let p(ν) be the probability of Alice choosing random variables parametrized by ν, that is, the probability of choosing a particular vertex, among all possible vertices of the graph, to be the trap position (denoted by a random variable t) and the probability of choosing random variables r, x, θ , and d (as defined in Definition 8). Given 0 &lt; 1, we define a protocol to be verifiable if for any choice of Bob's strategy (defined as in Definition 8 and denoted by the index j ) the probability of Alice accepting an incorrect outcome density operator is bounded by : Tr ν p(ν)P ν incorrect B j (ν) .</p>
        <p>Recall that B 0 (ν) is the output density operator of an honest run after the corrections have been performed. Hence, in the above definition | ideal is independent of ν, since for an honest run of the protocol the output state is independent of Alice's secret parameters, via the correctness theorem.Recall that B 0 (ν) is the output density operator of an honest run after the corrections have been performed. Hence, in the above definition | ideal is independent of ν, since for an honest run of the protocol the output state is independent of Alice's secret parameters, via the correctness theorem.</p>
        <p>Theorem 8. Protocol 5 is 1 -1 2m verifiable in general, and in the special case of purely classical output the protocol is also 1 -1 m verifiable, where m is the total number of qubits in the protocol.Theorem 8. Protocol 5 is 1 -1 2m verifiable in general, and in the special case of purely classical output the protocol is also 1 -1 m verifiable, where m is the total number of qubits in the protocol.</p>
        <p>Proof. At the beginning of the protocol, Alice chooses the independent and uniform random variables for ν. Next Alice prepares the input qubits in the formProof. At the beginning of the protocol, Alice chooses the independent and uniform random variables for ν. Next Alice prepares the input qubits in the form</p>
        <p>)|I and positions them among the first n qubits. Recall that n &gt; |I | and hence the trap qubit might be among this set of qubits. She then prepares the remaining qubits in the form (where D is the index of the dummy qubits))|I and positions them among the first n qubits. Recall that n &gt; |I | and hence the trap qubit might be among this set of qubits. She then prepares the remaining qubits in the form (where D is the index of the dummy qubits)</p>
        <p>and sends all m qubits in the order of the labeling of the vertices of the graph. We represent the whole m qubit state as |M ν . We can treat all the measurement angles δ i as orthogonal quantum states |δ i . For a fixed choice of Alice's random variables (ν) and Bob's strategy (j ), Bob's output from the computation can be written in the form of the output of a circuit computation as depicted in Fig. 6. Note that this is the state of the system before the relevant corrections for Alice's secret key have been applied to yield the outcome density operator B j (ν). While in the actual protocol, at step i, Alice computes δ i as a function of s &lt;i , which in turn is calculated from b &lt;i and r &lt;i , we can rewrite the circuit from Fig. 6 in such a way that the values δ i are part of the initial state, without affecting causality as they do not interact with anything until after the corresponding b i has been generated. This intuition is made rigorous in Eq. ( 1) via the inclusion of projections to ensure consistency. This will allow us to reorder all the operators U i to the end to obtain the new circuit shown in Fig. 7. Note that Fig. 7 is not an actual run of the protocol; it is a mathematical equivalent of Fig. 6 where the values of b i have been fixed to permit us to commute the operators as depicted. However, in the following proof we have considered any general deviation performed by Bob, that is to say, we consider any arbitrary U i operators.and sends all m qubits in the order of the labeling of the vertices of the graph. We represent the whole m qubit state as |M ν . We can treat all the measurement angles δ i as orthogonal quantum states |δ i . For a fixed choice of Alice's random variables (ν) and Bob's strategy (j ), Bob's output from the computation can be written in the form of the output of a circuit computation as depicted in Fig. 6. Note that this is the state of the system before the relevant corrections for Alice's secret key have been applied to yield the outcome density operator B j (ν). While in the actual protocol, at step i, Alice computes δ i as a function of s &lt;i , which in turn is calculated from b &lt;i and r &lt;i , we can rewrite the circuit from Fig. 6 in such a way that the values δ i are part of the initial state, without affecting causality as they do not interact with anything until after the corresponding b i has been generated. This intuition is made rigorous in Eq. ( 1) via the inclusion of projections to ensure consistency. This will allow us to reorder all the operators U i to the end to obtain the new circuit shown in Fig. 7. Note that Fig. 7 is not an actual run of the protocol; it is a mathematical equivalent of Fig. 6 where the values of b i have been fixed to permit us to commute the operators as depicted. However, in the following proof we have considered any general deviation performed by Bob, that is to say, we consider any arbitrary U i operators.</p>
        <p>In the rest of this proof we will use t to represent both the random variable and also the position of the trap qubit. We define by = U m-n U m-n-1 • • • U 1 the overall action of Bob's deviation and by P = [ 1 i m-n H i Z i (δ i )]E G the action of the exact protocol prior to measurement. Here and in Fig. 7 we have taken U i = P i U i P † i , where P i = i+1 j m-n H j Z j (δ j ). Further we define byIn the rest of this proof we will use t to represent both the random variable and also the position of the trap qubit. We define by = U m-n U m-n-1 • • • U 1 the overall action of Bob's deviation and by P = [ 1 i m-n H i Z i (δ i )]E G the action of the exact protocol prior to measurement. Here and in Fig. 7 we have taken U i = P i U i P † i , where P i = i+1 j m-n H j Z j (δ j ). Further we define by</p>
        <p>FIG. 6. Run of protocol together with Bob's deviation represented as U i operators. The entangling operator E G is the collection of all the required CTRL-Z operators corresponding to the graph edges. Note that in Definition 8 we also considered an operator U 0 representing Bob's initial deviation. In the figure, for simplicity, we have commuted U 0 and combined it with U 1 . Trivially, if all the U i operators are set to be identity the above circuit converges to the exact run of the protocol, where a measurement in the basis |± δ i is implemented using the controlled Z rotation followed by a Hadamard gate and finally a Pauli Z basis (computation basis) measurement on the corresponding qubits.FIG. 6. Run of protocol together with Bob's deviation represented as U i operators. The entangling operator E G is the collection of all the required CTRL-Z operators corresponding to the graph edges. Note that in Definition 8 we also considered an operator U 0 representing Bob's initial deviation. In the figure, for simplicity, we have commuted U 0 and combined it with U 1 . Trivially, if all the U i operators are set to be identity the above circuit converges to the exact run of the protocol, where a measurement in the basis |± δ i is implemented using the controlled Z rotation followed by a Hadamard gate and finally a Pauli Z basis (computation basis) measurement on the corresponding qubits.</p>
        <p>The fact that any U j in Fig. 6 is independent of all δ i&gt;j allows us to reposition the deviation to the end of the circuit as shown above. Hence we can rewrite Bob's deviation as U i = P i U i P † i , whereThe fact that any U j in Fig. 6 is independent of all δ i&gt;j allows us to reposition the deviation to the end of the circuit as shown above. Hence we can rewrite Bob's deviation as U i = P i U i P † i , where</p>
        <p>where (c r ) i = r i for all i = t, (c r ) t = 0, and the subscript B denotes that the partial trace is taken over Bob's private register. Here c r is used to compactly deal with the fact that in the protocol all measured qubits are decrypted by applying an XOR operation with r, except for the trap qubit, which remains uncorrected. Note that, in the above, the operator b| We take P ⊥ to be the projection onto the subspace of incorrect states for the nontrap qubits, after Alice's final corrections have been applied to any quantum output. Hencewhere (c r ) i = r i for all i = t, (c r ) t = 0, and the subscript B denotes that the partial trace is taken over Bob's private register. Here c r is used to compactly deal with the fact that in the protocol all measured qubits are decrypted by applying an XOR operation with r, except for the trap qubit, which remains uncorrected. Note that, in the above, the operator b| We take P ⊥ to be the projection onto the subspace of incorrect states for the nontrap qubits, after Alice's final corrections have been applied to any quantum output. Hence</p>
        <p>Here we use the subscript on the ket to identify the relevant qubit. Thus we haveHere we use the subscript on the ket to identify the relevant qubit. Thus we have</p>
        <p>As Bob's private register is traced out, the net result of is to apply a completely positive trace preserving map of the other qubits. Taking the Kraus operators associated with this operator to be {χ k }, with k χ k χ † k = I, we haveAs Bob's private register is traced out, the net result of is to apply a completely positive trace preserving map of the other qubits. Taking the Kraus operators associated with this operator to be {χ k }, with k χ k χ † k = I, we have</p>
        <p>Since any Kraus operator can be written as a linear combination of Pauli operators with complex coefficients, we haveSince any Kraus operator can be written as a linear combination of Pauli operators with complex coefficients, we have</p>
        <p>where k i α ki α * ki = 1 and σ i is a Pauli operator acting on the joint quantum state of the system. Therefore, the above equation can be written aswhere k i α ki α * ki = 1 and σ i is a Pauli operator acting on the joint quantum state of the system. Therefore, the above equation can be written as</p>
        <p>In order to determine which σ i terms have a nonzero contribution in the above sum after the projection operator is taken into account, it will be necessary to look at the structure of each such Pauli operator. To this end, we will denote by σ i|γ the action of σ i on qubit γ and hence σ i|γ ∈ {I,X,Y,Z}. For simplicity, we assume each δ i is encoded across three qubits (since there are only eight possible angles). Thus, we have 1 γ m + 3(mn), where 1 γ m identifies qubits received from Alice and the remaining γ values identify the qubits containing δ i . Without loss of generality, we can assume that the qubits representing the values of δ remain unchanged by Bob's deviation and hence we can take σ i|γ ∈ {I,Z} for all m &lt; γ .In order to determine which σ i terms have a nonzero contribution in the above sum after the projection operator is taken into account, it will be necessary to look at the structure of each such Pauli operator. To this end, we will denote by σ i|γ the action of σ i on qubit γ and hence σ i|γ ∈ {I,X,Y,Z}. For simplicity, we assume each δ i is encoded across three qubits (since there are only eight possible angles). Thus, we have 1 γ m + 3(mn), where 1 γ m identifies qubits received from Alice and the remaining γ values identify the qubits containing δ i . Without loss of generality, we can assume that the qubits representing the values of δ remain unchanged by Bob's deviation and hence we can take σ i|γ ∈ {I,Z} for all m &lt; γ .</p>
        <p>The probability of Alice accepting an incorrect outcome density operator is given byThe probability of Alice accepting an incorrect outcome density operator is given by</p>
        <p>This can be calculated via the expression for Tr[P ν incorrect B j (ν)] obtained earlier,This can be calculated via the expression for Tr[P ν incorrect B j (ν)] obtained earlier,</p>
        <p>By noting that |b j + c r j commutes with | ν,b ν,b | for all j = t, the above expression can be rewritten asBy noting that |b j + c r j commutes with | ν,b ν,b | for all j = t, the above expression can be rewritten as</p>
        <p>In order to obtain an upper bound for the above expression we make use of sets of indices γ of qubits such that the action of σ i at that position σ i|γ is a particular Pauli operator, which we define as follows:In order to obtain an upper bound for the above expression we make use of sets of indices γ of qubits such that the action of σ i at that position σ i|γ is a particular Pauli operator, which we define as follows:</p>
        <p>Note that in the above we restrict attention to the set of qubits originally sent from Alice to Bob (which is why 1 γ m) and disregard the action on Bob's private qubits. Additionally, we will make use of a superscript O to denote subsets of the above sets subject to the constraint that γ is an output qubit (mn &lt; γ ). Thus, for example, D O i = {γ : σ i|γ = Z, mn + 1 γ m}. We note that only σ i and σ j operators for which Tr(P ⊥ σ i P| ν,b ν,b |P † σ j ) = 0 contribute to p incorrect . With the above definitions in place, we can express succinctly a necessary condition for this to hold asNote that in the above we restrict attention to the set of qubits originally sent from Alice to Bob (which is why 1 γ m) and disregard the action on Bob's private qubits. Additionally, we will make use of a superscript O to denote subsets of the above sets subject to the constraint that γ is an output qubit (mn &lt; γ ). Thus, for example, D O i = {γ : σ i|γ = Z, mn + 1 γ m}. We note that only σ i and σ j operators for which Tr(P ⊥ σ i P| ν,b ν,b |P † σ j ) = 0 contribute to p incorrect . With the above definitions in place, we can express succinctly a necessary condition for this to hold as</p>
        <p>. That is to say, one or both of the following has happened: σ i (σ j ) has produced an incorrect outcome for one or more of the measurement results and hence. That is to say, one or both of the following has happened: σ i (σ j ) has produced an incorrect outcome for one or more of the measurement results and hence</p>
        <p>or σ i (σ j ) acts nontrivially on the quantum output and henceor σ i (σ j ) acts nontrivially on the quantum output and hence</p>
        <p>. Using this set notion and by taking the trace over the subspace of the measurement results except for the trap qubit we obtain. Using this set notion and by taking the trace over the subspace of the measurement results except for the trap qubit we obtain</p>
        <p>where we take |b t to have have unit dimension if t ∈ O. The reason for doing this is to allow a uniform treatment of trap qubits independent of whether or not the trap occurs on a measured qubit. Taking b = {b i } i =t , a substring of b that excludes the value for the trap measurement, the above equation can be written aswhere we take |b t to have have unit dimension if t ∈ O. The reason for doing this is to allow a uniform treatment of trap qubits independent of whether or not the trap occurs on a measured qubit. Taking b = {b i } i =t , a substring of b that excludes the value for the trap measurement, the above equation can be written as</p>
        <p>Note in the above that if the trap is measured we haveNote in the above that if the trap is measured we have</p>
        <p>Hence we haveHence we have</p>
        <p>where the inequality follows from the fact that the projector P ⊥ acts on a positive semidefinite matrix and the last equality follows from the fact that both remaining projectors act as the identity on qubits in O.where the inequality follows from the fact that the projector P ⊥ acts on a positive semidefinite matrix and the last equality follows from the fact that both remaining projectors act as the identity on qubits in O.</p>
        <p>Next we attempt to show that a necessary requirement for a term in the above summation over i and j to be nonzero is that i = j . As per the proof of blindness, summing over ν C yields the maximally mixed state of the system received from Alice. Hence we haveNext we attempt to show that a necessary requirement for a term in the above summation over i and j to be nonzero is that i = j . As per the proof of blindness, summing over ν C yields the maximally mixed state of the system received from Alice. Hence we have</p>
        <p>As all Pauli matrices other than the identity are traceless, any terms in the sum that are nonzero necessarily have σ i|γ = σ j |γ everywhere except for γ = t and the corresponding δ register. We then consider separately the two cases corresponding to whether the trap is located in the quantum output or not. If t ∈ O then the δ register does not exist and using the fact that θ t ,r t Tr( η ν T t |σ i |η ν T t η ν T t |σ j |η ν T t ) = 0, unless σ i|t = σ j |t , we arrive at the conclusion that the only terms that contribute to p incorrect are those where σ i = σ j . If, on the other hand, t / ∈ O, then averaging over r t alone is sufficient to give Tr( η ν T t |σ i |η ν T t η ν T t |σ j |η ν T t ) = 0 and hence σ i|t = σ j |t . In this case, averaging over θ yields the δ t register in the maximally mixed state and hence, as before, σ i and σ j must act identically on these qubits too, in order to avoid contributing zero to the value of p incorrect . Consequently, the only terms that contribute are those for which σ i = σ j . Using this identity with our previous expression for p incorrect , we obtainAs all Pauli matrices other than the identity are traceless, any terms in the sum that are nonzero necessarily have σ i|γ = σ j |γ everywhere except for γ = t and the corresponding δ register. We then consider separately the two cases corresponding to whether the trap is located in the quantum output or not. If t ∈ O then the δ register does not exist and using the fact that θ t ,r t Tr( η ν T t |σ i |η ν T t η ν T t |σ j |η ν T t ) = 0, unless σ i|t = σ j |t , we arrive at the conclusion that the only terms that contribute to p incorrect are those where σ i = σ j . If, on the other hand, t / ∈ O, then averaging over r t alone is sufficient to give Tr( η ν T t |σ i |η ν T t η ν T t |σ j |η ν T t ) = 0 and hence σ i|t = σ j |t . In this case, averaging over θ yields the δ t register in the maximally mixed state and hence, as before, σ i and σ j must act identically on these qubits too, in order to avoid contributing zero to the value of p incorrect . Consequently, the only terms that contribute are those for which σ i = σ j . Using this identity with our previous expression for p incorrect , we obtain</p>
        <p>This can be further simplified, sinceThis can be further simplified, since</p>
        <p>for the general case. However, for the specific case of only classical output, this bound can be made tighter by performing the simplification in a different way, sincefor the general case. However, for the specific case of only classical output, this bound can be made tighter by performing the simplification in a different way, since</p>
        <p>This single trap construction will be generalized in the next section to allow for exponential suppression of the probability of accepting an incorrect outcome even in the case of quantum output. We finish this section by showing that even this simple construction can be used to verify universal quantum computation, using the cylinder brickwork state presented in Sec. V.This single trap construction will be generalized in the next section to allow for exponential suppression of the probability of accepting an incorrect outcome even in the case of quantum output. We finish this section by showing that even this simple construction can be used to verify universal quantum computation, using the cylinder brickwork state presented in Sec. V.</p>
        <p>It is easy to verify that if Alice chooses a random row of a cylinder graph G C n×m (Fig. 4) and prepares all the qubits of that row in the states |z i where z i ∈ R {0,1} and the rest of nodes in the state |+ , then after entangling according to the cylinder brickwork graph the obtained state is G (n-1)×m m i=1 |z i . By choosing a random trap location and a dummy tape that contains its neighborhood we can construct a single-trap verifiable universal blind quantum computing protocol, given by Protocol 6 and illustrated in Fig. 8.It is easy to verify that if Alice chooses a random row of a cylinder graph G C n×m (Fig. 4) and prepares all the qubits of that row in the states |z i where z i ∈ R {0,1} and the rest of nodes in the state |+ , then after entangling according to the cylinder brickwork graph the obtained state is G (n-1)×m m i=1 |z i . By choosing a random trap location and a dummy tape that contains its neighborhood we can construct a single-trap verifiable universal blind quantum computing protocol, given by Protocol 6 and illustrated in Fig. 8.</p>
        <p>Corollary 1. Protocol 6 is universal, blind while leaking at most m and n, and 1 -1 2m verifiable in general and 1 -1 m verifiable in the case of classical output.Corollary 1. Protocol 6 is universal, blind while leaking at most m and n, and 1 -1 2m verifiable in general and 1 -1 m verifiable in the case of classical output.</p>
        <p>Tape Tape FIG. 8. Single-trap verifiable universal blind quantum computation using the cylinder brickwork state. (a) A random qubit is chosen to be the trap qubit, the (red) filled node. (b) All other vertices in the tape containing the trap qubit, the solid (black) nodes, are set to be dummy qubits. (c) This results in an isolated trap qubit in the state |+ θ together with many dummy qubits after entanglement operations are applied by the server. (d) The net result, after discarding the dummy qubits, is a disentangled trap qubit in a product state with a brickwork state.Tape Tape FIG. 8. Single-trap verifiable universal blind quantum computation using the cylinder brickwork state. (a) A random qubit is chosen to be the trap qubit, the (red) filled node. (b) All other vertices in the tape containing the trap qubit, the solid (black) nodes, are set to be dummy qubits. (c) This results in an isolated trap qubit in the state |+ θ together with many dummy qubits after entanglement operations are applied by the server. (d) The net result, after discarding the dummy qubits, is a disentangled trap qubit in a product state with a brickwork state.</p>
        <p>Proof. Since the dummy qubits are prepared in eigenstates of the Pauli Z operator, they remain in a product state with the rest of the system after the entangling operations are applied by Bob. The result, as depicted in Fig. 8, is that the trap qubit also remains in a product state and a brickwork state is prepared in the subsystem excluding T . The universality property then follows directly from the universality of the brickwork state from Theorem 5. As Protocol 6 is a special case of Protocol 3, the blindness property follows directly from Theorem 4 and therefore the angles of measurement φ i remain secret from Bob. Moreover, the universality of the cylinder brickwork state guarantees that Bob's knowledge of G C n×m does not reveal anything about the underlying computation except n and m. As Protocol 6 is also a special case of Protocol 5, the verifiability property follows directly from Theorem 8.Proof. Since the dummy qubits are prepared in eigenstates of the Pauli Z operator, they remain in a product state with the rest of the system after the entangling operations are applied by Bob. The result, as depicted in Fig. 8, is that the trap qubit also remains in a product state and a brickwork state is prepared in the subsystem excluding T . The universality property then follows directly from the universality of the brickwork state from Theorem 5. As Protocol 6 is a special case of Protocol 3, the blindness property follows directly from Theorem 4 and therefore the angles of measurement φ i remain secret from Bob. Moreover, the universality of the cylinder brickwork state guarantees that Bob's knowledge of G C n×m does not reveal anything about the underlying computation except n and m. As Protocol 6 is also a special case of Protocol 5, the verifiability property follows directly from Theorem 8.</p>
        <p>In the preceding section we presented a very simple verifiable protocol where the probability of Bob succeeding in making Alice accept an incorrect outcome density operator was strictly less than 1. Building upon that simple construction, by adding more traps and making the computation fault tolerant, we can make the probability of Alice accepting an incorrect outcome density operator as Protocol 6. Single-trap verifiable universal blind quantum computation.In the preceding section we presented a very simple verifiable protocol where the probability of Bob succeeding in making Alice accept an incorrect outcome density operator was strictly less than 1. Building upon that simple construction, by adding more traps and making the computation fault tolerant, we can make the probability of Alice accepting an incorrect outcome density operator as Protocol 6. Single-trap verifiable universal blind quantum computation.</p>
        <p>(1) Alice's resources (i) A graph G = G C n×m and a randomly chosen vertex t of G. (ii) The rest of the resources are the same as Protocol 3, where φ i = 0 for i = t and i ∈ D, where D contains the set of all vertices in a tape T that contains position t and all of its neighbors.(1) Alice's resources (i) A graph G = G C n×m and a randomly chosen vertex t of G. (ii) The rest of the resources are the same as Protocol 3, where φ i = 0 for i = t and i ∈ D, where D contains the set of all vertices in a tape T that contains position t and all of its neighbors.</p>
        <p>(2) Follow the steps of Protocol 3.(2) Follow the steps of Protocol 3.</p>
        <p>(3) Accept or reject (i) After obtaining all the output qubits from Bob, if the trap qubit t is an output qubit, Alice measures it with angle δ t = θ t + r t π to obtain b t .(3) Accept or reject (i) After obtaining all the output qubits from Bob, if the trap qubit t is an output qubit, Alice measures it with angle δ t = θ t + r t π to obtain b t .</p>
        <p>(ii) Alice accepts if b t = r t .(ii) Alice accepts if b t = r t .</p>
        <p>small as required. The central idea is to design a protocol with O(N ) many traps in essentially random locations, where N is the number of qubits in the protocol, to increase the probability of any local error being detected. The fault tolerance is added to increase the minimum weight of any operator that leads to an incorrect outcome and hence further increase the probability of detection. Here and in what follows, the weight of a Pauli operator is defined to be the number of qubits upon which it acts nontrivially. First, given such a protocol, we show how it amplifies the verification parameter. We then present the central contribution of this paper, a universal verifiable blind quantum computing protocol that achieves the probability amplification without any such assumptions. Theorem 9. Let P be a blind quantum computing protocol on N qubits with N T isolated traps in the states |+ θ t at a set of positions T chosen uniformly at random. Let N T /N be a constant c. Take σ = {σ i } to be a set of Pauli operators such that for at most d distinct indices i we have σ i ∈ {X,Y,Z} and for the remaining indices σ i = I . Assume that the underlying computation of P is encoded in such a way that for any such σ , if each measurement result or unmeasured qubit i is modified by applying σ i , then either the computation is correct or an error is detected when the output is decoded. Then the protocol is ( 1 -c 2 ) d verifiable in general and (1c) d verifiable in the case of purely classical output.small as required. The central idea is to design a protocol with O(N ) many traps in essentially random locations, where N is the number of qubits in the protocol, to increase the probability of any local error being detected. The fault tolerance is added to increase the minimum weight of any operator that leads to an incorrect outcome and hence further increase the probability of detection. Here and in what follows, the weight of a Pauli operator is defined to be the number of qubits upon which it acts nontrivially. First, given such a protocol, we show how it amplifies the verification parameter. We then present the central contribution of this paper, a universal verifiable blind quantum computing protocol that achieves the probability amplification without any such assumptions. Theorem 9. Let P be a blind quantum computing protocol on N qubits with N T isolated traps in the states |+ θ t at a set of positions T chosen uniformly at random. Let N T /N be a constant c. Take σ = {σ i } to be a set of Pauli operators such that for at most d distinct indices i we have σ i ∈ {X,Y,Z} and for the remaining indices σ i = I . Assume that the underlying computation of P is encoded in such a way that for any such σ , if each measurement result or unmeasured qubit i is modified by applying σ i , then either the computation is correct or an error is detected when the output is decoded. Then the protocol is ( 1 -c 2 ) d verifiable in general and (1c) d verifiable in the case of purely classical output.</p>
        <p>Proof. In order to exploit Theorem 8, we notionally partition the qubits into independent sets with one single trap qubit in each set. These partitions amount to extra information about the location of the trap qubits and hence their inclusion can only serve to increase the probability of Bob convincing Alice to accept an incorrect state. Thus the bound we obtain with this additional information is still an upper bound on the probability of Alice accepting an incorrect output when these partitions are unknown. There are N T many such sets S γ with 1/c many qubits in each set. We adopt a similar proof strategy to that used to prove Theorem 8, takingProof. In order to exploit Theorem 8, we notionally partition the qubits into independent sets with one single trap qubit in each set. These partitions amount to extra information about the location of the trap qubits and hence their inclusion can only serve to increase the probability of Bob convincing Alice to accept an incorrect state. Thus the bound we obtain with this additional information is still an upper bound on the probability of Alice accepting an incorrect output when these partitions are unknown. There are N T many such sets S γ with 1/c many qubits in each set. We adopt a similar proof strategy to that used to prove Theorem 8, taking</p>
        <p>as the projection onto the subspace of incorrect outcomes.as the projection onto the subspace of incorrect outcomes.</p>
        <p>As in the proof of Theorem 8, only those Pauli operators contribute to p incorrect where one or both of the following has happened: σ i has produced an incorrect outcome for some of the measurement results b i or σ i acts nontrivially on the quantum output. Now due to the error-detection property of the encoding assumed in the statement of the theorem, we need to consider only those σ i whereAs in the proof of Theorem 8, only those Pauli operators contribute to p incorrect where one or both of the following has happened: σ i has produced an incorrect outcome for some of the measurement results b i or σ i acts nontrivially on the quantum output. Now due to the error-detection property of the encoding assumed in the statement of the theorem, we need to consider only those σ i where</p>
        <p>Following the steps of the proof of Theorem 8, we obtainFollowing the steps of the proof of Theorem 8, we obtain</p>
        <p>Here we can exploit the structure we have introduced through the sets S γ p incorrectHere we can exploit the structure we have introduced through the sets S γ p incorrect</p>
        <p>where t γ is taken to be the location of the trap qubit in set S γ . Rearranging the above and substituting in the values of p(t γ ), p(θ t γ ), and p(r t γ ), we obtainwhere t γ is taken to be the location of the trap qubit in set S γ . Rearranging the above and substituting in the values of p(t γ ), p(θ t γ ), and p(r t γ ), we obtain</p>
        <p>Note that within each set the position of the trap is chosen uniformly at random and so the probability of detection by that trap corresponds to the bound obtained for Theorem 8. Going through the steps of the proof of Theorem 8, we obtainNote that within each set the position of the trap is chosen uniformly at random and so the probability of detection by that trap corresponds to the bound obtained for Theorem 8. Going through the steps of the proof of Theorem 8, we obtain</p>
        <p>where we use the additional γ subscript on sets |A iγ |, . . . ,|D iγ | to indicate subsets of the respective sets, subject to the restriction that the elements are also in S γ . For convenience we definewhere we use the additional γ subscript on sets |A iγ |, . . . ,|D iγ | to indicate subsets of the respective sets, subject to the restriction that the elements are also in S γ . For convenience we define</p>
        <p>We now make use of the fact that, for any positive a, 1We now make use of the fact that, for any positive a, 1</p>
        <p>. As w iγ is a non-negative integer, we can recursively apply this identity to obtain In the case of purely classical output this bound can be improved, since. As w iγ is a non-negative integer, we can recursively apply this identity to obtain In the case of purely classical output this bound can be improved, since</p>
        <p>Going through the same steps with this additional constraint givesGoing through the same steps with this additional constraint gives</p>
        <p>We can now present the final contribution of this paper, a scheme for blind quantum computing that has all the previously described properties: correctness, universality, blindness of angles, input, output, computation, and more importantly verifiability with exponentially small probability of error. Roughly speaking, universality and correctness will be obtained by using dotted-complete graph states (similar to Protocol 4). In order to achieve verification we exploit the idea of dummy qubits (similar to Protocol 3) to create, blindly, out of a dotted-complete graph state K3N three disconnected smaller dotted-complete graph states KN . Then we use two of these graph states to create O(N) isolated trap qubits at random positions (similar to Protocol 5). The final step is to perform the actual computation over the remaining dotted-complete graph state in such a way that the stated property in Theorem 9 is also satisfied, that is, to have the measurement pattern encoded in such a way that any Pauli error with weight less than d will be either corrected or detected. Such an encoding exists through the fault-tolerant one-way quantum computing scheme of [41]. All that is needed is to create a three-dimensional cluster state from the dotted-complete graph state and proceed with the fault-tolerant computation scheme of Raussendorf et al. [41,53]. 6We first give a concrete protocol for choosing the required parameters for the Raussendorf et al. scheme, given the desired security threshold for the verification (see Protocol 7). This will fix the size of the dotted-graph state N required for the actual computation. However, as stated above, we will start with a dotted-complete graph state of size 3N and break it into three smaller dotted-complete graph states of size N each (see Fig. 9). We will refer to these graphs as the white trap graph, the black trap graph, and the computation graph. In the white trap graph all the vertices in P ( KN ) will become isolated traps (called white traps) by choosing all the vertices in A( KN ) to be dummy qubits. Similarly, in the black trap graph all the vertices in A( KN ) will become isolated traps (called black traps) by choosing all the vertices in P ( KN ) to be dummy qubits. We have to choose both type of vertices [A( K3N ) and P ( K3N )] to be potentially isolated traps, otherwise Bob could choose to cheat on one type rather than the other one. In order to make the position of traps random, Alice will choose a random partition of P ( K3N ) into three equal size sets and will choose appropriate dummy qubits (similar to Lemma 2) to obtain the three disconnected graphs. Note that this will lead to random positions for trap qubits; however, the positions of trap qubits will be also correlated with each other and we will take care of this issue when we present the proof of the verification. The above procedure is formalized in Protocol 7 and finally Protocol 8 presents a hiding protocol that is universal, verifiable, and blind.We can now present the final contribution of this paper, a scheme for blind quantum computing that has all the previously described properties: correctness, universality, blindness of angles, input, output, computation, and more importantly verifiability with exponentially small probability of error. Roughly speaking, universality and correctness will be obtained by using dotted-complete graph states (similar to Protocol 4). In order to achieve verification we exploit the idea of dummy qubits (similar to Protocol 3) to create, blindly, out of a dotted-complete graph state K3N three disconnected smaller dotted-complete graph states KN . Then we use two of these graph states to create O(N) isolated trap qubits at random positions (similar to Protocol 5). The final step is to perform the actual computation over the remaining dotted-complete graph state in such a way that the stated property in Theorem 9 is also satisfied, that is, to have the measurement pattern encoded in such a way that any Pauli error with weight less than d will be either corrected or detected. Such an encoding exists through the fault-tolerant one-way quantum computing scheme of [41]. All that is needed is to create a three-dimensional cluster state from the dotted-complete graph state and proceed with the fault-tolerant computation scheme of Raussendorf et al. [41,53]. 6We first give a concrete protocol for choosing the required parameters for the Raussendorf et al. scheme, given the desired security threshold for the verification (see Protocol 7). This will fix the size of the dotted-graph state N required for the actual computation. However, as stated above, we will start with a dotted-complete graph state of size 3N and break it into three smaller dotted-complete graph states of size N each (see Fig. 9). We will refer to these graphs as the white trap graph, the black trap graph, and the computation graph. In the white trap graph all the vertices in P ( KN ) will become isolated traps (called white traps) by choosing all the vertices in A( KN ) to be dummy qubits. Similarly, in the black trap graph all the vertices in A( KN ) will become isolated traps (called black traps) by choosing all the vertices in P ( KN ) to be dummy qubits. We have to choose both type of vertices [A( K3N ) and P ( K3N )] to be potentially isolated traps, otherwise Bob could choose to cheat on one type rather than the other one. In order to make the position of traps random, Alice will choose a random partition of P ( K3N ) into three equal size sets and will choose appropriate dummy qubits (similar to Lemma 2) to obtain the three disconnected graphs. Note that this will lead to random positions for trap qubits; however, the positions of trap qubits will be also correlated with each other and we will take care of this issue when we present the proof of the verification. The above procedure is formalized in Protocol 7 and finally Protocol 8 presents a hiding protocol that is universal, verifiable, and blind.</p>
        <p>As a high-level overview of the fault-tolerance scheme, qubits are encoded topologically as chains of defects (qubits to be measured in the Z basis) of finite thickness and separation (referred to as the scale parameter) that trace out a path through the three-dimensional structure of the resource state. The encoding forces nondetectable errors to be topologically nontrivial chains, either connecting or encircling defect chains. Certain Clifford group operations are implemented directly by braiding these defect chains. For the remaining operations required for universality it is necessary to implement the gate by first distilling a suitable resource state that is then used to implement the gate via teleportation (all within the topologically encoded computation). While the teleportation can be done with Clifford group operations, the distillation is implemented on a concatenated encoding where at each level of concatenation the corresponding distillation step is topologically encoded with progressively higher defect thicknesses and scale parameters. At the lowest level, however, the operations are performed directly on physical qubits and so the defect chains are only a single qubit in diameter.As a high-level overview of the fault-tolerance scheme, qubits are encoded topologically as chains of defects (qubits to be measured in the Z basis) of finite thickness and separation (referred to as the scale parameter) that trace out a path through the three-dimensional structure of the resource state. The encoding forces nondetectable errors to be topologically nontrivial chains, either connecting or encircling defect chains. Certain Clifford group operations are implemented directly by braiding these defect chains. For the remaining operations required for universality it is necessary to implement the gate by first distilling a suitable resource state that is then used to implement the gate via teleportation (all within the topologically encoded computation). While the teleportation can be done with Clifford group operations, the distillation is implemented on a concatenated encoding where at each level of concatenation the corresponding distillation step is topologically encoded with progressively higher defect thicknesses and scale parameters. At the lowest level, however, the operations are performed directly on physical qubits and so the defect chains are only a single qubit in diameter.</p>
        <p>Theorem 10. Assume Alice and Bob follow the steps of Protocol 8. Then Alice always accepts the output and the outcome density operator is correct.Theorem 10. Assume Alice and Bob follow the steps of Protocol 8. Then Alice always accepts the output and the outcome density operator is correct.</p>
        <p>Proof. First we note that it is always possible to choose measurement patterns M P by Lemma 2 and M reduce by Lemma 1. Further, by the universality of the Raussendorf et al. encoding, it is always possible to choose M comp . As the measurements composing M P , M reduce , M P , and M A are composed entirely of Pauli basis measurements, there is no partial time ordering imposed on the sequence of measurements and so the times at which these measurements are made have no effect on the outcome of the protocol. Thus, for any honest run of the protocol, the result will be the same as if the measurements from M P were made first. By construction this measurement pattern splits the graph state into three separate graph states KN .Proof. First we note that it is always possible to choose measurement patterns M P by Lemma 2 and M reduce by Lemma 1. Further, by the universality of the Raussendorf et al. encoding, it is always possible to choose M comp . As the measurements composing M P , M reduce , M P , and M A are composed entirely of Pauli basis measurements, there is no partial time ordering imposed on the sequence of measurements and so the times at which these measurements are made have no effect on the outcome of the protocol. Thus, for any honest run of the protocol, the result will be the same as if the measurements from M P were made first. By construction this measurement pattern splits the graph state into three separate graph states KN .</p>
        <p>The dummy qubits in M P and M A correspond to break operations in their respective graphs by Lemma 4 and hence after the initial step all the trap qubits remain unentangled from the rest. Recall that for these trap qubits φ i = 0 and since the qubit is prepared in the state |+ θ i and measured in basis {|+ θ i ,|θ i }, the measurement result communicated to Alice is s i = r i for all such qubits. Thus, Alice always accepts, satisfying the first criterion.The dummy qubits in M P and M A correspond to break operations in their respective graphs by Lemma 4 and hence after the initial step all the trap qubits remain unentangled from the rest. Recall that for these trap qubits φ i = 0 and since the qubit is prepared in the state |+ θ i and measured in basis {|+ θ i ,|θ i }, the measurement result communicated to Alice is s i = r i for all such qubits. Thus, Alice always accepts, satisfying the first criterion.</p>
        <p>By definition M reduce transforms the graph state corresponding to KN to the resource state necessary to implement M comp . Finally, measuring according to M comp yields the correct output of C by the correctness of the Raussendorf et al. protocol.By definition M reduce transforms the graph state corresponding to KN to the resource state necessary to implement M comp . Finally, measuring according to M comp yields the correct output of C by the correctness of the Raussendorf et al. protocol.</p>
        <p>Theorem 11. Protocol 8 is blind while leaking at most N .Theorem 11. Protocol 8 is blind while leaking at most N .</p>
        <p>Proof. The proof is directly obtained from Theorem 4. In what follows, choosing a measurement pattern means fixing the underlying graph state together with the appropriate angles of computation such that the resulting pattern implements the desired computation due to universality. Similarly choosing a partial measurement pattern means fixing the underlying graph state together with a partial set of angles of computation corresponding to a partial computation, where the rest of the angles will be fixed in Protocol 8 where this protocol is called as a subroutine. Here we assume that a standard labeling of the vertices of each dotted-complete graph state is known to both Alice and Bob.Proof. The proof is directly obtained from Theorem 4. In what follows, choosing a measurement pattern means fixing the underlying graph state together with the appropriate angles of computation such that the resulting pattern implements the desired computation due to universality. Similarly choosing a partial measurement pattern means fixing the underlying graph state together with a partial set of angles of computation corresponding to a partial computation, where the rest of the angles will be fixed in Protocol 8 where this protocol is called as a subroutine. Here we assume that a standard labeling of the vertices of each dotted-complete graph state is known to both Alice and Bob.</p>
        <p>(1) Alice chooses security parameter d and then transforms the quantum circuit C corresponding to her desired computation into (or directly designs) a measurement pattern M comp on a graph state G L that implements her computation using the encoding for topological fault-tolerant measurement-based quantum computation due to Raussendorf et al. [41], where G L is taken to correspond to the graph state of the threedimensional lattice L introduced in [41] with sufficient dimensions D x , D y , and D z to implement her computation using an encoding with parameters as follows: defect thickness d, lattice scale parameter λ = 5d, distillation of resource states |A and |Y using L = log 3 (d) levels, and for each concatenation level 1 &lt; &lt; L the thickness parameter and scale parameter for that level are chosen as d = 3d -1 and λ = λ -1 , with d 1 = 1, λ 1 = 5, d L = d, and λ L = λ. (2) Alice chooses a partial measurement pattern M reduce that reduces the graph state KN to the graph state G L through Pauli measurements (Theorem 6), where N is the total number of qubits in L. (3) Alice chooses a partial measurement pattern M P on the graph state KN such that every qubit corresponding to a vertex in A( KN ) is set to be a dummy qubit. Hence all vertices in P ( KN ) are isolated traps. (4) Alice chooses a partial measurement pattern M A on the graph state KN such that every qubit corresponding to a vertex in P ( KN ) is set to be a dummy qubit. Hence all vertices in A( KN ) are isolated traps. (5) For the graph K3N , Alice chooses uniformly at random a partitioning P of the vertices into three equal-size sets of vertices P 1 , P 2 , and P 3 . ( 6) Alice takes M P to be the partial measurement pattern where the required vertices in A( K3N ) are set to be dummy qubits such that the resulting state is the tensor product of three graph states of the three disconnected graphs k1 = KN , k2 = KN , and k3 = KN such that P ( ki ) = P i . ( 7) Alice calculates M, her overall measurement pattern on a graph state corresponding to K3N , by combining the partial pattern M P with M comp and M reduce applied to subgraph k1 and M P and M A applied to subgraphs k2 and k3 , respectively, to obtain a full measurement pattern.(1) Alice chooses security parameter d and then transforms the quantum circuit C corresponding to her desired computation into (or directly designs) a measurement pattern M comp on a graph state G L that implements her computation using the encoding for topological fault-tolerant measurement-based quantum computation due to Raussendorf et al. [41], where G L is taken to correspond to the graph state of the threedimensional lattice L introduced in [41] with sufficient dimensions D x , D y , and D z to implement her computation using an encoding with parameters as follows: defect thickness d, lattice scale parameter λ = 5d, distillation of resource states |A and |Y using L = log 3 (d) levels, and for each concatenation level 1 &lt; &lt; L the thickness parameter and scale parameter for that level are chosen as d = 3d -1 and λ = λ -1 , with d 1 = 1, λ 1 = 5, d L = d, and λ L = λ. (2) Alice chooses a partial measurement pattern M reduce that reduces the graph state KN to the graph state G L through Pauli measurements (Theorem 6), where N is the total number of qubits in L. (3) Alice chooses a partial measurement pattern M P on the graph state KN such that every qubit corresponding to a vertex in A( KN ) is set to be a dummy qubit. Hence all vertices in P ( KN ) are isolated traps. (4) Alice chooses a partial measurement pattern M A on the graph state KN such that every qubit corresponding to a vertex in P ( KN ) is set to be a dummy qubit. Hence all vertices in A( KN ) are isolated traps. (5) For the graph K3N , Alice chooses uniformly at random a partitioning P of the vertices into three equal-size sets of vertices P 1 , P 2 , and P 3 . ( 6) Alice takes M P to be the partial measurement pattern where the required vertices in A( K3N ) are set to be dummy qubits such that the resulting state is the tensor product of three graph states of the three disconnected graphs k1 = KN , k2 = KN , and k3 = KN such that P ( ki ) = P i . ( 7) Alice calculates M, her overall measurement pattern on a graph state corresponding to K3N , by combining the partial pattern M P with M comp and M reduce applied to subgraph k1 and M P and M A applied to subgraphs k2 and k3 , respectively, to obtain a full measurement pattern.</p>
        <p>We then prove that w &gt; 2d by induction, as follows. Assume that at level i we have w i &gt; 2d i . In that case we have w i+1 = min(4d i+1 ,6d i ), since by assumption 4d i + w i &gt; 6d i and 3w i &gt; 6d i , and clearly 8d i &gt; 6d i . However, we have d i+1 = 3d i for all levels except the top level, where d L 3d L-1 . Thus, in general, 2d i+1 6d i and hence w i+1 &gt; 2d i+1 . At the lowest level the error distillation uses unencoded qubits measured in non-Pauli bases and so w 0 = 1 and w 1 = 3 &gt; 2d 1 = 2 and thus by induction on i we obtain the result that w L &gt; 2d as required.We then prove that w &gt; 2d by induction, as follows. Assume that at level i we have w i &gt; 2d i . In that case we have w i+1 = min(4d i+1 ,6d i ), since by assumption 4d i + w i &gt; 6d i and 3w i &gt; 6d i , and clearly 8d i &gt; 6d i . However, we have d i+1 = 3d i for all levels except the top level, where d L 3d L-1 . Thus, in general, 2d i+1 6d i and hence w i+1 &gt; 2d i+1 . At the lowest level the error distillation uses unencoded qubits measured in non-Pauli bases and so w 0 = 1 and w 1 = 3 &gt; 2d 1 = 2 and thus by induction on i we obtain the result that w L &gt; 2d as required.</p>
        <p>Note, however, that any operation on a measured qubit that is diagonal in the computational basis (σ i ∈ {I,Z}) does not alter the computation. Hence an undetectable logical error is not created unless the total number of measured sites for which σ i ∈ {X,Y } plus the total number of output qubits for which σ i ∈ {X,Y,Z} is equal to or greater than 2d. Thus the outcome is either correct or when decoded results in a detected error, unlessNote, however, that any operation on a measured qubit that is diagonal in the computational basis (σ i ∈ {I,Z}) does not alter the computation. Hence an undetectable logical error is not created unless the total number of measured sites for which σ i ∈ {X,Y } plus the total number of output qubits for which σ i ∈ {X,Y,Z} is equal to or greater than 2d. Thus the outcome is either correct or when decoded results in a detected error, unless</p>
        <p>2d. Now we link the above general property of the Raussendorf et al. scheme to our specific protocol. To do so, we first introduce the notion of independently detectable errors.2d. Now we link the above general property of the Raussendorf et al. scheme to our specific protocol. To do so, we first introduce the notion of independently detectable errors.</p>
        <p>Definition 11. Given a dotted-complete graph state KN , a set of output qubits O, a measurement pattern M target containing only X-Y plane measurements and Z basis measurements, and a set of single-qubit Pauli operators σ = {σ i } N i=1 , with σ i ∈ {I,X,Y,Z}, which represent errors that modify each measurement result or unmeasured output qubit i by the application of σ i , for each location i we define the set i = {i} for i ∈ P ( KN ) and i = N KN (i) for i ∈ A( KN ). We say that σ contains k independently detectable errors if and only if there exists a set E of k locations such that for all i ∈ E,Definition 11. Given a dotted-complete graph state KN , a set of output qubits O, a measurement pattern M target containing only X-Y plane measurements and Z basis measurements, and a set of single-qubit Pauli operators σ = {σ i } N i=1 , with σ i ∈ {I,X,Y,Z}, which represent errors that modify each measurement result or unmeasured output qubit i by the application of σ i , for each location i we define the set i = {i} for i ∈ P ( KN ) and i = N KN (i) for i ∈ A( KN ). We say that σ contains k independently detectable errors if and only if there exists a set E of k locations such that for all i ∈ E,</p>
        <p>The intuition behind this definition is that in Protocol 8 the qubits in P ( K3N ) are independently randomly distributed between the two trap graphs and the computation graph and whether or not a qubit in A( K3N ) coincides with a trap depends only on the placement of the neighboring qubits [which are both in P ( K3N )]. The first condition ensures that the error anticommutes with some possible measurement of the system and is hence truly an error, while the second condition ensures that we are considering only qubits associated with disjoint subsets of P ( K3N ) and hence whether or not they coincide with a trap is uncorrelated. With this definition in place, we can proceed with proving a corollary to Lemma 5 that links that result with Protocol 8. (with appropriate local Z rotations applied) to the qubits corresponding to vertices in P ( KN ).The intuition behind this definition is that in Protocol 8 the qubits in P ( K3N ) are independently randomly distributed between the two trap graphs and the computation graph and whether or not a qubit in A( K3N ) coincides with a trap depends only on the placement of the neighboring qubits [which are both in P ( K3N )]. The first condition ensures that the error anticommutes with some possible measurement of the system and is hence truly an error, while the second condition ensures that we are considering only qubits associated with disjoint subsets of P ( K3N ) and hence whether or not they coincide with a trap is uncorrelated. With this definition in place, we can proceed with proving a corollary to Lemma 5 that links that result with Protocol 8. (with appropriate local Z rotations applied) to the qubits corresponding to vertices in P ( KN ).</p>
        <p>Take σ = {σ i } to be a set of single-qubit Pauli operators such that each σ i ∈ {I,X,Y,Z} acts on qubit i. Then for any σ , if M C is implemented on state KN , but the output of each measurement result or unmeasured qubit is modified by applying σ i , then either the computation is correct (corresponding to a run where all σ i = I ) or an error is detected when the output is decoded, unless σ contains at least 2d 5 independently detectable errors.Take σ = {σ i } to be a set of single-qubit Pauli operators such that each σ i ∈ {I,X,Y,Z} acts on qubit i. Then for any σ , if M C is implemented on state KN , but the output of each measurement result or unmeasured qubit is modified by applying σ i , then either the computation is correct (corresponding to a run where all σ i = I ) or an error is detected when the output is decoded, unless σ contains at least 2d 5 independently detectable errors.</p>
        <p>Proof. First we note that only qubits in P ( K3N ) are contained in O, since all qubits in A( K3N ) will be measured to make the required resource states. All measurements on qubits associated with vertices A( KN ) are in either the Y or Z basis, allowing any error in the measurement outcome to be associated with an X error on the underlying qubit. As the generators for the stabilizer of KN are simply the operators X i j ∈N KN (i) Z j and each vertex in A( KN ) has only two neighbors, both of which lie in P ( KN ), an X error on a qubit associated with a vertex in A( KN ) is equivalent to a local error on each of two qubits in P ( KN ). Thus any local Pauli operator in σ i associated with a vertex in A( KN ) either can be replaced by at most two local operators acting on qubits associated with vertices in P ( KN ) without altering the outcome of the computation or has no effect on the computation. Note that since Pauli Z operators always commute with Z basis measurements and anticommute with any measurement in the X-Y plane, these local operators are always Pauli operators due to the corresponding restriction on M target .Proof. First we note that only qubits in P ( K3N ) are contained in O, since all qubits in A( K3N ) will be measured to make the required resource states. All measurements on qubits associated with vertices A( KN ) are in either the Y or Z basis, allowing any error in the measurement outcome to be associated with an X error on the underlying qubit. As the generators for the stabilizer of KN are simply the operators X i j ∈N KN (i) Z j and each vertex in A( KN ) has only two neighbors, both of which lie in P ( KN ), an X error on a qubit associated with a vertex in A( KN ) is equivalent to a local error on each of two qubits in P ( KN ). Thus any local Pauli operator in σ i associated with a vertex in A( KN ) either can be replaced by at most two local operators acting on qubits associated with vertices in P ( KN ) without altering the outcome of the computation or has no effect on the computation. Note that since Pauli Z operators always commute with Z basis measurements and anticommute with any measurement in the X-Y plane, these local operators are always Pauli operators due to the corresponding restriction on M target .</p>
        <p>The only Pauli terms that can affect the outcome of the computation are those that either flip a measurement outcome (X or Y ) or act nontrivially upon an unmeasured qubit (as either X, Y , or Z). By Lemma 5, the outcome of the computation is unaltered unless σ produces such errors on at least 2d sites. To show that this implies the existence of at least 2d 5 independently detectable errors we will consider the effects of errors on A( KN ) and P ( KN ) in relation to the resource state for the Raussendorf et al. scheme G L . Errors on A( KN ) only occur when the qubit in question is measured in the Y basis, since for Z basis measurements dummy qubits are used and the outcome of Bob's measurement is ignored. Thus, as we have shown above, such errors correspond to local Pauli errors at either end of an edge in the G L . Errors in P ( KN ), however, correspond simply to errors on single vertices in G L . Therefore, we can consider any error introduced by σ as corresponding to a subgraph g σ of G L , where i ∈ A( KN ) introduces the vertices in N KN (i) together with a connecting edge, while i ∈ P ( KN ) simply introduces the vertex i. Such a subgraph contains all of the qubits in G L that can possibly be affected by local errors after the measurement of qubits according to M reduce are taken into account [propagating errors from A( KN ) to P ( KN )].The only Pauli terms that can affect the outcome of the computation are those that either flip a measurement outcome (X or Y ) or act nontrivially upon an unmeasured qubit (as either X, Y , or Z). By Lemma 5, the outcome of the computation is unaltered unless σ produces such errors on at least 2d sites. To show that this implies the existence of at least 2d 5 independently detectable errors we will consider the effects of errors on A( KN ) and P ( KN ) in relation to the resource state for the Raussendorf et al. scheme G L . Errors on A( KN ) only occur when the qubit in question is measured in the Y basis, since for Z basis measurements dummy qubits are used and the outcome of Bob's measurement is ignored. Thus, as we have shown above, such errors correspond to local Pauli errors at either end of an edge in the G L . Errors in P ( KN ), however, correspond simply to errors on single vertices in G L . Therefore, we can consider any error introduced by σ as corresponding to a subgraph g σ of G L , where i ∈ A( KN ) introduces the vertices in N KN (i) together with a connecting edge, while i ∈ P ( KN ) simply introduces the vertex i. Such a subgraph contains all of the qubits in G L that can possibly be affected by local errors after the measurement of qubits according to M reduce are taken into account [propagating errors from A( KN ) to P ( KN )].</p>
        <p>We note that any connected subgraph g γ σ of g σ containing n γ vertices necessarily contains at least n γ -1 edges. Note also that G L is four-edge colorable (see Fig. 10). Thus, by the pigeonhole principle, there is at least one color for that subgraph that corresponds to at least n γ - 1 4 edges. As the various subgraphs g γ σ are disconnected, we are free to choose the coloring independently for each and hence can choose a single four-edge coloring for g σ such that it includes at edges from each subgraph. We then take the set E to correspond to qubits in A( KN ) corresponding to edges of this color, as well as to the single vertex in any g γ σ for which n γ = 1, hence i ∩ j = 0. By Lemma 5, this ensures that either the outcome of the computation is correct or an error is detected upon decoding, or σ contains at least γ :n γ 2 n γ -1 4We note that any connected subgraph g γ σ of g σ containing n γ vertices necessarily contains at least n γ -1 edges. Note also that G L is four-edge colorable (see Fig. 10). Thus, by the pigeonhole principle, there is at least one color for that subgraph that corresponds to at least n γ - 1 4 edges. As the various subgraphs g γ σ are disconnected, we are free to choose the coloring independently for each and hence can choose a single four-edge coloring for g σ such that it includes at edges from each subgraph. We then take the set E to correspond to qubits in A( KN ) corresponding to edges of this color, as well as to the single vertex in any g γ σ for which n γ = 1, hence i ∩ j = 0. By Lemma 5, this ensures that either the outcome of the computation is correct or an error is detected upon decoding, or σ contains at least γ :n γ 2 n γ -1 4</p>
        <p>+ γ :n γ =1 1 independently detectable errors, where γ n γ 2d. Note that+ γ :n γ =1 1 independently detectable errors, where γ n γ 2d. Note that</p>
        <p>and hence either the computation is correct or an error is detected upon decoding, or σ contains at least 2d 5 independently detectable errors. The above corollary guarantees that one of the conditions of Theorem 9 for the verification with the amplified security is satisfied. However, we cannot yet directly use that theorem since, as stated before, the positions of the traps are not completely random as the positions of the black traps are fixed once we choose the random position assignment of qubits in P ( K3N ) to each of the three subgraphs. This is why we have introduced the notion of independently detectable errors. Here we give a direct proof of verification for Protocol 8 following the same steps as the proof of Theorem 9.and hence either the computation is correct or an error is detected upon decoding, or σ contains at least 2d 5 independently detectable errors. The above corollary guarantees that one of the conditions of Theorem 9 for the verification with the amplified security is satisfied. However, we cannot yet directly use that theorem since, as stated before, the positions of the traps are not completely random as the positions of the black traps are fixed once we choose the random position assignment of qubits in P ( K3N ) to each of the three subgraphs. This is why we have introduced the notion of independently detectable errors. Here we give a direct proof of verification for Protocol 8 following the same steps as the proof of Theorem 9.</p>
        <p>Theorem 12. Protocol 8 is in general (5/6) 2d/5 verifiable and in the case of only classical output is (2/3) 2d/5 verifiable, where d is the security parameter as described in Protocol 7.Theorem 12. Protocol 8 is in general (5/6) 2d/5 verifiable and in the case of only classical output is (2/3) 2d/5 verifiable, where d is the security parameter as described in Protocol 7.</p>
        <p>Proof. The proof of this theorem follows the same strategy as Theorem 8, first taking the most general strategy for Bob, expanding this in terms of Pauli operators, and finally showing that any Pauli term that leads to an incorrect outcome is detected with high probability. We note that any deviation by Bob from Protocol 8 can be rewritten in the form shown in Fig. 7. The proof of this is identical to the corresponding step in the proof of Theorem 8: Without loss of generality, any deviation by Bob from the protocol can be written in the form of Fig. 6. We can treat {δ i } as inputs to the circuit without violating causality, as they do not interact with any other part of the computation until after b j has been measured, for all j &lt; i. Then simply by reordering the operators via their commutation relations we obtain the form in Fig. 7 as required.Proof. The proof of this theorem follows the same strategy as Theorem 8, first taking the most general strategy for Bob, expanding this in terms of Pauli operators, and finally showing that any Pauli term that leads to an incorrect outcome is detected with high probability. We note that any deviation by Bob from Protocol 8 can be rewritten in the form shown in Fig. 7. The proof of this is identical to the corresponding step in the proof of Theorem 8: Without loss of generality, any deviation by Bob from the protocol can be written in the form of Fig. 6. We can treat {δ i } as inputs to the circuit without violating causality, as they do not interact with any other part of the computation until after b j has been measured, for all j &lt; i. Then simply by reordering the operators via their commutation relations we obtain the form in Fig. 7 as required.</p>
        <p>As a result, any deviation by Bob can be written as a single deviation operator that acts upon the quantum states Bob receives from Alice as well as δ i and some private register held by Bob. Similar to the proof of Theorem 8 the probability of Alice accepting an incorrect outcome density operator is then where as in previous proofs we take the Kraus operators associated with the , once Bob's private system has been removed, to be χ k = i α ki σ i , with k i α ki α * ki = 1. By Corollary 2, P ⊥ projects out the terms in the above sum where σ i does not contain at least 2d 5 independently detectable errors on the computation graph. This is a somewhat stronger condition than we actually need and so we will consider terms corresponding to any σ i that produces at least 2d 5 independently detectable errors in total across all three subgraphs (the computation graph and the two trap graphs). We will denote by I the set of all i for which σ i does not satisfy this condition. Similar to the proof of Theorem 8, all terms for which i = j average to zero. Thus, as in the proof of Theorem As before, we introduce notional sets S γ of three qubits each such that exactly one qubit from each set is on each of the three subgraphs (the two trap graphs and the computation graph) and where either all of the qubits are in P ( K3N ) or all of the qubits are in A( K3N ) (ensuring exactly one trap and at least one dummy qubit per set). As every σ i in the above sum corresponds to at least 2d 5 independently detectable (and hence uncorrelated) errors across these sets S γ , we have .As a result, any deviation by Bob can be written as a single deviation operator that acts upon the quantum states Bob receives from Alice as well as δ i and some private register held by Bob. Similar to the proof of Theorem 8 the probability of Alice accepting an incorrect outcome density operator is then where as in previous proofs we take the Kraus operators associated with the , once Bob's private system has been removed, to be χ k = i α ki σ i , with k i α ki α * ki = 1. By Corollary 2, P ⊥ projects out the terms in the above sum where σ i does not contain at least 2d 5 independently detectable errors on the computation graph. This is a somewhat stronger condition than we actually need and so we will consider terms corresponding to any σ i that produces at least 2d 5 independently detectable errors in total across all three subgraphs (the computation graph and the two trap graphs). We will denote by I the set of all i for which σ i does not satisfy this condition. Similar to the proof of Theorem 8, all terms for which i = j average to zero. Thus, as in the proof of Theorem As before, we introduce notional sets S γ of three qubits each such that exactly one qubit from each set is on each of the three subgraphs (the two trap graphs and the computation graph) and where either all of the qubits are in P ( K3N ) or all of the qubits are in A( K3N ) (ensuring exactly one trap and at least one dummy qubit per set). As every σ i in the above sum corresponds to at least 2d 5 independently detectable (and hence uncorrelated) errors across these sets S γ , we have .</p>
        <p>We have extended the original universal blind quantum computing protocol presented in [3] with different concepts of blind preparation of isolated dummy qubits (a qubit prepared randomly in the set {|0 ,|1 }) and isolated trap qubits (a qubit prepared randomly in the set {|+ θ }). These two modifications lead to a different construction for unconditionally verifiable blind quantum computation. However, in this way only polynomially bounded security could be achieved. Building upon these ideas, combined with fault-tolerant computation, we presented a UBQC protocol that achieves exponentially bounded security for the verification scheme using a different resource state, the dotted-complete graph state. This protocol extends the topological fault-tolerant measurement-based quantum computation scheme due to Raussendorf et al. [41] to a blind setting. We note that while consideration of fault tolerance in the blind computation itself is beyond the scope of the present work, if Protocol 8 is modified so as to allow Alice to accept a finite error rate on the trap qubits, the probability of Bob successfully cheating is exponentially suppressed in the gap between the expected error weight inferred from trap measurements and our threshold of 2d 5 and so a fault-tolerant adaptation of this protocol should be possible.We have extended the original universal blind quantum computing protocol presented in [3] with different concepts of blind preparation of isolated dummy qubits (a qubit prepared randomly in the set {|0 ,|1 }) and isolated trap qubits (a qubit prepared randomly in the set {|+ θ }). These two modifications lead to a different construction for unconditionally verifiable blind quantum computation. However, in this way only polynomially bounded security could be achieved. Building upon these ideas, combined with fault-tolerant computation, we presented a UBQC protocol that achieves exponentially bounded security for the verification scheme using a different resource state, the dotted-complete graph state. This protocol extends the topological fault-tolerant measurement-based quantum computation scheme due to Raussendorf et al. [41] to a blind setting. We note that while consideration of fault tolerance in the blind computation itself is beyond the scope of the present work, if Protocol 8 is modified so as to allow Alice to accept a finite error rate on the trap qubits, the probability of Bob successfully cheating is exponentially suppressed in the gap between the expected error weight inferred from trap measurements and our threshold of 2d 5 and so a fault-tolerant adaptation of this protocol should be possible.</p>
        <p>As mentioned before, a verifiable UBQC protocol can be viewed as an interactive proof system where Alice acts as the verifier and Bob as the prover [3][4][5]. This link to complexity theory suggests a different approach to questions such as the open problem of finding an interactive proof for any problem in BQP with a BQP prover, but with a purely classical verifier. The conceptual link between blindness and interactive proof systems is the key ingredient for verifying the high-complexity quantum-theoretic models with low-complexity classical ones.As mentioned before, a verifiable UBQC protocol can be viewed as an interactive proof system where Alice acts as the verifier and Bob as the prover [3][4][5]. This link to complexity theory suggests a different approach to questions such as the open problem of finding an interactive proof for any problem in BQP with a BQP prover, but with a purely classical verifier. The conceptual link between blindness and interactive proof systems is the key ingredient for verifying the high-complexity quantum-theoretic models with low-complexity classical ones.</p>
        <p>A cryptosystem is unconditionally (computationally) secure if it is secure even when the adversary has unlimited (restricted) computing power.A cryptosystem is unconditionally (computationally) secure if it is secure even when the adversary has unlimited (restricted) computing power.</p>
        <p>While several attempts have been made in recent years to find homomorphic encryption schemes that allow for the evaluation of certain quantum operations[13][14][15][16][17], a quantum analog of fully homomorphic encryption remains elusive[18].While several attempts have been made in recent years to find homomorphic encryption schemes that allow for the evaluation of certain quantum operations[13][14][15][16][17], a quantum analog of fully homomorphic encryption remains elusive[18].</p>
        <p>The parties aim to communicate messages over an untrusted channel in such a way that the receiver can authenticate the sender.The parties aim to communicate messages over an untrusted channel in such a way that the receiver can authenticate the sender.</p>
        <p>More precisely, the Solovay-Kitaev theorem states that if the subgroup generated by some subset of SU(2) operators is dense in SU(2), then the approximation converges exponentially quickly to any element of SU(2) in the number of these operators from a smaller set one uses to approximate.More precisely, the Solovay-Kitaev theorem states that if the subgroup generated by some subset of SU(2) operators is dense in SU(2), then the approximation converges exponentially quickly to any element of SU(2) in the number of these operators from a smaller set one uses to approximate.</p>
        <p>In its original form, this scheme requires Z-basis measurements to be made adaptively, which is not easily implementable using dummy qubits. However, the location of the dummy qubits can be fixed by always including a correction step for each gate teleportation in the logical circuit, where the angle of the correction is adapted based on the outcome of the teleportation. An alternative option is to use a slightly modified version of the scheme due to Morimae and Fujii[31], which requires only measurements in the X-Y plane. Although we assume the first scenario here, an almost identical proof applies to the second scenario.In its original form, this scheme requires Z-basis measurements to be made adaptively, which is not easily implementable using dummy qubits. However, the location of the dummy qubits can be fixed by always including a correction step for each gate teleportation in the logical circuit, where the angle of the correction is adapted based on the outcome of the teleportation. An alternative option is to use a slightly modified version of the scheme due to Morimae and Fujii[31], which requires only measurements in the X-Y plane. Although we assume the first scenario here, an almost identical proof applies to the second scenario.</p>
        <p>We thank Anne Broadbent for many insightful discussions throughout the writing of this paper. We would also like to acknowledge Robert Raussendorf and Earl Campbell for their help on the properties of the topological fault-tolerance scheme. We also thank Vedran Dunjko, Iordanis Kerenedis, Urmila Mahadev, and Tomoyuki Morimae for helpful discussions on the proof of Theorem 8 and for pointing out to us an error in the first draft. J.F.F. acknowledges support from the National Research Foundation and Ministery of Education, Singapore. This material is based on research supported in part by the Singapore National Research Foundation under National Research Foundation (Singapore). E.K. acknowledges support from Engineering and Physical Sciences Research Council Grant No. EP/E059600/1.We thank Anne Broadbent for many insightful discussions throughout the writing of this paper. We would also like to acknowledge Robert Raussendorf and Earl Campbell for their help on the properties of the topological fault-tolerance scheme. We also thank Vedran Dunjko, Iordanis Kerenedis, Urmila Mahadev, and Tomoyuki Morimae for helpful discussions on the proof of Theorem 8 and for pointing out to us an error in the first draft. J.F.F. acknowledges support from the National Research Foundation and Ministery of Education, Singapore. This material is based on research supported in part by the Singapore National Research Foundation under National Research Foundation (Singapore). E.K. acknowledges support from Engineering and Physical Sciences Research Council Grant No. EP/E059600/1.</p>
        <p>Protocol 8. Verifiable universal blind quantum computation.Protocol 8. Verifiable universal blind quantum computation.</p>
        <p>(1) Alice's resources (i) Alice chooses the pattern M and random partitioning P according to Protocol 7.(1) Alice's resources (i) Alice chooses the pattern M and random partitioning P according to Protocol 7.</p>
        <p>(ii) The dummy qubits position, set D, chosen according to Protocol 7.(ii) The dummy qubits position, set D, chosen according to Protocol 7.</p>
        <p>(iii) A sequence of measurement angles φ = (φ i ) 1 i 3N (3N +1)/2 , with φ i ∈ A, according to the description of Protocol 7, where φ i = 0 for all the trap and dummy qubits. The ordering of the measurements on P ( K3N ) is chosen uniformly at random subject to the constraint that the partial ordering of measurements from M comp determined by flow is preserved. Such a random ordering is required to hide the position of the trap qubits. The qubits in A( K3N ) are measured first in the order that the relevant edge entry appears in the adjacency matrix of K 3N once this random ordering has been taken into account. That is, the site in A( K3N ) that is joined by edges to i and j in P ( K3N ), with i &lt; j in the random ordering imposed on P ( K3N ), is measured in position 3N(i -1) + j -i(i+1) 2 . Note that the measurement order of the vertices in A should be independent of the computation (and traps), so in the above we prescribe one such suitable sequence. This is followed by the measurements of P ( K3N ) in the randomly chosen order. (iv) 3N(3N + 1)/2 random variables θ i with value taken uniformly at random from A. (v) 3N(3N + 1)/2 random variables r i and |D| random variable d i with values taken uniformly at random from {0,1}. (vi) A fixed function C(i,φ i ,θ i ,r i ,s) that for each nonoutput qubit i computes the angle of the measurement of qubit i to be sent to Bob.(iii) A sequence of measurement angles φ = (φ i ) 1 i 3N (3N +1)/2 , with φ i ∈ A, according to the description of Protocol 7, where φ i = 0 for all the trap and dummy qubits. The ordering of the measurements on P ( K3N ) is chosen uniformly at random subject to the constraint that the partial ordering of measurements from M comp determined by flow is preserved. Such a random ordering is required to hide the position of the trap qubits. The qubits in A( K3N ) are measured first in the order that the relevant edge entry appears in the adjacency matrix of K 3N once this random ordering has been taken into account. That is, the site in A( K3N ) that is joined by edges to i and j in P ( K3N ), with i &lt; j in the random ordering imposed on P ( K3N ), is measured in position 3N(i -1) + j -i(i+1) 2 . Note that the measurement order of the vertices in A should be independent of the computation (and traps), so in the above we prescribe one such suitable sequence. This is followed by the measurements of P ( K3N ) in the randomly chosen order. (iv) 3N(3N + 1)/2 random variables θ i with value taken uniformly at random from A. (v) 3N(3N + 1)/2 random variables r i and |D| random variable d i with values taken uniformly at random from {0,1}. (vi) A fixed function C(i,φ i ,θ i ,r i ,s) that for each nonoutput qubit i computes the angle of the measurement of qubit i to be sent to Bob.</p>
        <p>(2) Initial step (i) Alice's move: Alice sets all the value in s to be 0 and prepares the qubits in the form(2) Initial step (i) Alice's move: Alice sets all the value in s to be 0 and prepares the qubits in the form</p>
        <p>and sends Bob all the 3N(3N + 1)/2 qubits in the order of the labeling of the vertices of the graph.and sends Bob all the 3N(3N + 1)/2 qubits in the order of the labeling of the vertices of the graph.</p>
        <p>(ii) Bob's move: Bob receives 3N(3N + 1)/2 single qubits and entangles them according to K3N . (3) Step i:(ii) Bob's move: Bob receives 3N(3N + 1)/2 single qubits and entangles them according to K3N . (3) Step i:</p>
        <p>(i) Alice's move: Alice computes the angle δ i = C(i,φ i ,θ i ,r i ,s) and sends it to Bob.(i) Alice's move: Alice computes the angle δ i = C(i,φ i ,θ i ,r i ,s) and sends it to Bob.</p>
        <p>(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .(ii) Bob's move: Bob measures qubit i with angle δ i and sends Alice the result b i .</p>
        <p>(iii) Alice's move: Alice sets the value of s i in s to be s i + r i . (4) Verification Alice accepts if s i = r i for all the white and black trap qubits i.(iii) Alice's move: Alice sets the value of s i in s to be s i + r i . (4) Verification Alice accepts if s i = r i for all the white and black trap qubits i.</p>
        <p>In order to prove the verification property, as stated in Theorem 9, we require that the measurement pattern is encoded in such a way that any Pauli error of weight less than d will be either corrected or detected. We now show that this is true for the Raussendorf et al. scheme; although this is already implicit in their paper [41], we make it explicit here for completeness. In what follows we take L to be the three-dimensional lattice corresponding to the resource state used in [41].In order to prove the verification property, as stated in Theorem 9, we require that the measurement pattern is encoded in such a way that any Pauli error of weight less than d will be either corrected or detected. We now show that this is true for the Raussendorf et al. scheme; although this is already implicit in their paper [41], we make it explicit here for completeness. In what follows we take L to be the three-dimensional lattice corresponding to the resource state used in [41].</p>
        <p>Lemma 5. Let M C be a measurement pattern that implements a computation C on G L , the graph state corresponding to the lattice L, using the Raussendorf et al. fault-tolerance scheme with the following parameters: defect thickness d, lattice scale parameter λ = 5d, distillation of resource states |A and |Y using L = log 3 (d) levels, and for each concatenation level 1 &lt; &lt; L the thickness parameter and scale parameter for that level are chosen as d = 3d -1 and λ = 3λ -1 , with d 1 = 1, λ 1 = 5, d L = d, and λ L = λ. Take σ = {σ i } to be a set of Pauli operators such that each σ i ∈ {I,X,Y,Z} and acts on qubit i. Then for any σ , if M C is implemented on state |G L , but the output of each measurement result or unmeasured qubit i is modified by applying σ i , then either the computation is correct (corresponding to a run where all σ i = I ) or an error is detected when the output is decoded, unless andD O L = {γ : σ γ = Z, γ ∈ O} and where O is the set of output (unmeasured) qubits.Lemma 5. Let M C be a measurement pattern that implements a computation C on G L , the graph state corresponding to the lattice L, using the Raussendorf et al. fault-tolerance scheme with the following parameters: defect thickness d, lattice scale parameter λ = 5d, distillation of resource states |A and |Y using L = log 3 (d) levels, and for each concatenation level 1 &lt; &lt; L the thickness parameter and scale parameter for that level are chosen as d = 3d -1 and λ = 3λ -1 , with d 1 = 1, λ 1 = 5, d L = d, and λ L = λ. Take σ = {σ i } to be a set of Pauli operators such that each σ i ∈ {I,X,Y,Z} and acts on qubit i. Then for any σ , if M C is implemented on state |G L , but the output of each measurement result or unmeasured qubit i is modified by applying σ i , then either the computation is correct (corresponding to a run where all σ i = I ) or an error is detected when the output is decoded, unless andD O L = {γ : σ γ = Z, γ ∈ O} and where O is the set of output (unmeasured) qubits.</p>
        <p>Proof. In the Raussendorf et al. scheme, logical qubits are topologically protected against errors. The two lowest weight topological errors are error cycles around defects and error chains running between defects. As defects have thickness d, any cross section forms a rectangle of dimension at least d×d and thus perimeter at least 4(d + 1). As an error cycle must fit around the remaining defect and the minimum error cycle is at least 4d. As the centers of defects are separated by distance λ, the minimum distance between defects is λd and hence for our parameters we have λd = 4d.Proof. In the Raussendorf et al. scheme, logical qubits are topologically protected against errors. The two lowest weight topological errors are error cycles around defects and error chains running between defects. As defects have thickness d, any cross section forms a rectangle of dimension at least d×d and thus perimeter at least 4(d + 1). As an error cycle must fit around the remaining defect and the minimum error cycle is at least 4d. As the centers of defects are separated by distance λ, the minimum distance between defects is λd and hence for our parameters we have λd = 4d.</p>
        <p>The only region where this topological protection breaks down is within the regions used to distill the resource states |A and |Y . This distillation is performed using a concatenation of L levels of the Reed-Muller (|A ) or Steane (|Y ) codes. Each level of distillation is topologically protected with parameters d and λ . As the Reed-Muller and Steane codes are both distance 3, an error at level can be caused by either a topological error at that level or not less than three errors at the previous level. However, since at each level &lt; L we have λd = 4d and d = 3d -1 , the minimum weight w to create an error at level is min(4d ,8d -1 ,4d -1 + w -1 ,3w -1 ). The four terms in this last expression account, respectively, for the minimum weight errors in each of the four possible cases: (1) The error is entirely topological at level , (2) the error is entirely topological at level -1, (3) the error includes both topological errors at level -1 (which in the worst case affects two qubits with a single weight 4d error chain) and inherited errors from level -2, and (4) the case where all errors are inherited from level -2.The only region where this topological protection breaks down is within the regions used to distill the resource states |A and |Y . This distillation is performed using a concatenation of L levels of the Reed-Muller (|A ) or Steane (|Y ) codes. Each level of distillation is topologically protected with parameters d and λ . As the Reed-Muller and Steane codes are both distance 3, an error at level can be caused by either a topological error at that level or not less than three errors at the previous level. However, since at each level &lt; L we have λd = 4d and d = 3d -1 , the minimum weight w to create an error at level is min(4d ,8d -1 ,4d -1 + w -1 ,3w -1 ). The four terms in this last expression account, respectively, for the minimum weight errors in each of the four possible cases: (1) The error is entirely topological at level , (2) the error is entirely topological at level -1, (3) the error includes both topological errors at level -1 (which in the worst case affects two qubits with a single weight 4d error chain) and inherited errors from level -2, and (4) the case where all errors are inherited from level -2.</p>
    </text>
</tei>
