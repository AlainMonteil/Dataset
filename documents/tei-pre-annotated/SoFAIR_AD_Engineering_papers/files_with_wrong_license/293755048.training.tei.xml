<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-24T12:58+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>We present a challenging new benchmark and learning-environment for robot learning: 
            <rs type="software">RLBench</rs>. The benchmark features 100 completely unique, hand-designed tasks ranging in difficulty, from simple target reaching and door opening, to longer multi-stage tasks, such as opening an oven and placing a tray in it. We provide an array of both proprioceptive observations and visual observations, which include rgb, depth, and segmentation masks from an over-the-shoulder stereo camera and an eye-in-hand monocular camera. Uniquely, each task comes with an infinite supply of demos through the use of motion planners operating on a series of waypoints given during task creation time; enabling an exciting flurry of demonstration-based learning. 
            <rs type="software">RLBench</rs> has been designed with scalability in mind; new tasks, along with their motionplanned demos, can be easily created and then verified by a series of tools, allowing users to submit their own tasks to the 
            <rs type="software">RLBench</rs> task repository. This large-scale benchmark aims to accelerate progress in a number of vision-guided manipulation research areas, including: reinforcement learning, imitation learning, multi-task learning, geometric computer vision, and in particular, few-shot learning. With the benchmark's breadth of tasks and demonstrations, we propose the first large-scale fewshot challenge in robotics. We hope that the scale and diversity of 
            <rs type="software">RLBench</rs> offers unparalleled research opportunities in the robot learning community and beyond. Benchmarking code and videos can be found here 1 .
        </p>
        <p>Robot manipulation systems broadly fall somewhere on a spectrum ranging from traditional, modular methods, that include object recognition, state estimation, and planning, to fully end-to-end approaches that leverage deep learning and large-scale data to learn a mapping from input observations directly to motor actions, with the intuition that the 'traditional' modules are embedded in the weights of a deep neural network. Driven by the successful combination of large-scale data [1] and deep learning algorithms in the field of computer vision [2], there is now a large body of work looking at increasing the capabilities of robotic agents through the use of reinforcement learning [3], [4], meta-learning [5], [6], [7], multi-task learning [8], [9], etc. However, there is currently no standard in place for comparing manipulation methods in these respective areas. Although there exist benchmarks such as 
            <rs type="software">OpenAI Gym</rs> [10] and 
            <rs type="software">DeepMind Control Suite</rs> [11] for evaluating continuous-control reinforcement learning algorithms, their focus is not on real-world problems, and it is often the case that algorithms in these toy-benchmarks do not scale to more complex, real-world tasks. Few-shot learning methods for robotics also suffer from a lack of well defined tasks; for example, in Finn et al. [5] and James et al. [6] there is a very narrow distribution of tasks, where the task of "placing a peach into a red bowl" would be considered a different task to "placing an apple in to a green bowl". Despite the increase in these data-driven approaches, it is not clear where the ideal location on this 'learning' spectrum lies for complex robotics tasks that we may one day want robots performing in our homes. Given all of these problems, there seems to be a need for a benchmark that evaluates not only the diverse range of robot learning fields that are now emerging, but also a range of visually-guided manipulation approaches from both sides of the spectrum.
        </p>
        <p>This motivates the need for a one-size-fits-all benchmark that allows the capability to utilise large-scale data, whilst also allowing classical systems to be compared. To that end, we present 
            <rs type="software">RLBench</rs>, which is an ambitious large-scale benchmark and learning environment designed to facilitate research in a number of both classical and deep-learning based robot manipulation areas. 
            <rs type="software">RLBench</rs> is deliberately highly challenging and forward looking. The benchmark includes 100 completely unique, hand-designed tasks ranging in difficulty (shown in Figure 1), which share a common Franka Emika Panda robot arm, featuring a range of sensor modalities, including joint angles, velocities and forces, an eye-in-hand camera and an over-the-shoulder stereo camera setup. Each of the 100 tasks comes with a number of textual descriptions and an infinite set of demonstrations made possible through our task building tools that use waypointbased motion planning.
        </p>
        <p>In this paper, we discuss a host of research areas that would benefit from this benchmark, including, but not restricted to, reinforcement learning, imitation learning, fewshot learning, multi-task learning, and geometric based methods, such as SLAM. In addition to the benchmark, we also contribute an open-source set of tools that will allow rapid development of new tasks (through the use of 
            <rs type="software">PyRep</rs> [12]) in order to improve the size and scope of the benchmark over time. To summarise, 
            <rs type="software">RLBench</rs> has the following 3 key aims:
        </p>
        <p>• Provide a benchmark and learning environment for both 'robot learning' and 'traditional' methods. • Provide the a large-scale few-shot challenge, where given M training tasks and N unseen tasks, a system must take K different demonstrations of each of the N unseen tasks, and then be able to perform these tasks in new configurations. • Provide a set of tools to allow easy task creation.</p>
        <p>We review existing datasets, benchmarks, and learning environments that could be considered similar to ours in arXiv:1909.12271v1 [cs.RO] 26 Sep 2019 Fig. 1: RLBench is a large-scale benchmark consisting of 100 completely unique, hand-designed tasks. In this figure we show a sample of 24 tasks that feature in the benchmark. Example tasks include stacking a set of 6 colored blocks in a pyramid (top left), inserting a shape onto a peg (top right), finish setting up a checkers board (bottom left), and watering a plant (bottom right). To get a better understanding of the variety of tasks, please watch the video.</p>
        <p>an effort to further motivate RLBench. Firstly we cover reinforcement learning benchmarks, followed by benchmarks designed specifically for manipulation.</p>
        <p>a) Reinforcement Learning: Largely as a consequence of the seminal work that saw an algorithm learn to play a range of Atari 2600 video games to superhuman level directly from image pixels [13], deep reinforcement learning (DRL) has increasingly become prevalent in the literature, leading to a number of recent further success in the games of Go [14], Chess [15], 
            <rs type="software">StarCraft</rs> [16], and Dota [17]. With the success of these approaches, there has been a surge in developing DRL algorithms to solve continuous control environments [18], [19], [20], [21], [22]. These learned (continuous control) agents are usually tested on benchmarks such as 
            <rs type="software">OpenAI Gym</rs> [10] or the 
            <rs type="software">DeepMind Control Suite</rs> [11]. However, apart from a small number of robotic tasks in 
            <rs type="software">OpenAI Gym</rs>, these benchmarks feature only toy tasks that often do not resemble real-world problems that robots will need to overcome. To combat this, many projects create their own manipulation tasks to evaluate their approach, making comparisons difficult. As a direct consequence of this, these created tasks can often succumb to unintentionally introducing another hyperparameter into the method in the form of the task design itself. For example, a method could fail on a more challenging task, and so results would only be presented for a simpler set of tasks. This is something a standard benchmark of tasks could alleviate. (We should mention the very recently announced Meta-World project [23], a multi-task benchmark for meta-learning research in manipulation, though full documentation describing the aims of that project is not available at the time of writing.) b) Manipulation: Most related work in benchmarking robot manipulation algorithms often concentrates on solving only one of the manipulation sub-problems, focusing on either perception, grasping, or planning. But first, we look at benchmarks that evaluate the system as a whole. The Amazon Robotics Challenge (ARC) [24] was an attempt to create a benchmark for robotic picking and stowing. Although it was a successful challenge that drew many conclusions, such as the usefulness of a dual gripper and suction cup end-effector [25], it was difficult to reproduce in a lab setup. The ACRV Picking Benchmark [26] aimed to solve this by creating a similar, but reproducible setup to the ARC. The issue with picking and stowing is that it is but one of many possible tasks; RLBench on the other hand comes with 100 unique tasks, many of which involve some aspect of picking and placing. Similarly to ARC, the RoboCup@Home competition [27] is run annually, but has a greater range of tasks that must be completed. However, given that no largescale data is given beforehand, this makes reinforcement learning and other end-to-end approaches difficult to apply in the competition. RLBench is a platform that can unify both old and new methods and compare them on an even playing field.
        </p>
        <p>For evaluating imitation learning systems in particular, 
            <rs type="software">RoboTurk</rs> [28] was a recent attempt to leverage crowd sourcing to obtain data for tasks, but because of this the system has only three tasks. Whilst 
            <rs type="software">RoboTurk</rs> is entirely in simulation, 
            <rs type="software">Simitate</rs> [29] on the other hand is a hybrid approach, where real world observations (RGB-D camera calibrated against a motion capturing system) are combined with a simulated environment for benchmarking. In contrast to 
            <rs type="software">RoboTurk</rs>, we do not crowd source our demonstrations, but instead rely on an infinite supply of generated demonstrations collected via motion planners. Although 
            <rs type="software">Simitate</rs> offers the benefit of being partially a real-world dataset, the addition of new tasks requires time-consuming calibration and motion capturing; our system on the other hand sacrifices the real-world aspect, but in exchange we receive the ability generate a diverse range of tasks in a scalable way. Fig. 2: The V-REP scene consists of a Franka Panda affixed to a wooden table, surrounded by 3 directional lights. Observations include rgb, depth, and segmentation masks from an over-the-shoulder stereo camera and a eye-in-hand monocular camera, along with robot proprioceptive data, which includes joint angles, velocities, and torques, and the gripper pose. The arm can be easily swapped out for another arm if required.
        </p>
        <p>Moving on from whole-system benchmarks, there are a host of benchmarks that focus on sub-problems, for example perception datasets, from both the computer vision community (such as ILSVRC [1], COCO [30], Pascal-VOC [31], etc), and the robotics community (such as 
            <rs type="software">BigBIRD</rs> [32], YCB-Video [33], etc). For grasping, both 
            <rs type="software">OpenGrasp</rs> [34] and 
            <rs type="software">VisGraB</rs> [35] are popular simulation-based benchmarks, whilst the YCB dataset [36] focuses on real-world objects. In comparison to these, RLBench allows robotic systems to be evaluated on the complete robotic pipeline, rather than limited to sub-problems such as object detection, state estimation, grasp selection, and planning.
        </p>
        <p>When designing RLBench, we have prioritised several key properties:</p>
        <p>a) Diversity: Algorithms we develop should be general. In order to effectively learn inter-task relationships, a truly diverse range of tasks is needed to help avoid over-fitting.</p>
        <p>b) Reproducibility: Reproducibility is challenging in robotics as each lab has their own robotic setup. Moving to simulation solves this, but at the risk of developing solutions that may not run as well in the real-world. However, with the rise of deep-learning methods becoming more prominent in robotics, we believe it is important to find the potential and limits of these methods in a controlled, reproducible environment.</p>
        <p>c) Scale: Given the amount of data modern machine learning methods need, it is important to not only have a large collection of tasks, but also the ability to produce a large number of demonstrations from these tasks. Fig. 3: A sample of the visual observations given from both the over-the-shoulder stereo and eye-in-hand monocular cameras, which supply rgb, depth, and mask images. d) Extensibility: Following on from the previous point, we hope to continue to grow this repository of tasks. Therefore it is crucial that the task building system is as easy as possible to use. By leveraging the recently released robotics toolkit, 
            <rs type="software">PyRep</rs> [12], we are able to make a broad range of tasks in a short amount of time.
        </p>
        <p>e) Tiered Difficulty: Attempting to get robots to do a single task can be challenging let alone expecting them to do numerous tasks. We therefore wanted to have a range of tasks, including both easy tasks, such as reaching, which would be well suited to new and emerging methods, to more challenging, long-time-horizon tasks that can stress-test well known state-of-the-art algorithms in use today.</p>
        <p>f) Realism: Although we cannot claim full photorealism in our rendering system, or general realistic physics, we have put substantial effort into high quality components such as using a realistic robot model, graphics with lighting and shadows and a domain randomisation rendering option in order to maximise the potential for research on sim-to-real transfer.</p>
        <p>RLBench is an ambitious project which we hope to grow over many years. The benchmark and learning environment is built around a V-REP [37] and 
            <rs type="software">PyRep</rs> [12] interface. 
            <rs type="software">PyRep</rs> is a toolkit for robot learning research, built on top of V-REP that features a number of improvements, including speed, rendering, and flexible a API for robot control and scene manipulation. Using the combination of these two libraries, we have been able to build this ambitious benchmark, which we now describe in greater detail. Fig. 4: An example showing the distinction between task, variation, and episode. In this case, the 'stack blocks' task has V variations, each with E episodes. Each variation comes with a list of textual descriptions that describes the objective. Across variations, usually target objects or colours are changed, whereas across episodes positions are changed.
        </p>
        <p>The V-REP scene, shown in Figure 2, remains constant across all tasks and contains the Franka Emika Panda 7 DoF arm affixed to a wooden table, surrounded by 3 directional lights. As shown in Figure 3, visual observations can be perceived from a stereo camera, and a monocular wrist camera, which supply rgb, depth, and segmentation mask data on each frame. In addition to visual observations, robot proprioceptive data can be retrieved, which includes joint angles, velocities, and torques, along with the end-effector pose. Tasks are loaded into the scene and placed at the centre of the workspace. Every task starts with the same assumption that no objects are held, therefore, unlike many works in the literature, tasks that involve tools will first need to grasp the object appropriately in order to accomplish the task. Although this makes the environments considerably harder to complete, we believe it is an important assumption to make given that household robots will one day work under such conditions.</p>
        <p>RLBench employs 3 keys terms: Task, Variation, and Episode. Each task consists of one or more variations, and from each variation, an infinite number of episodes can be drawn. Each variation of a task comes with a list of textual descriptions that verbally summarise this variation of the task, which could prove useful for human robot interaction (HRI) and natural language processing (NLP) research. A summary of this can be seen in Figure 4. Formally, we define an episode trajectory τ to consist of a series of observations o and actions a: τ = [(o 1 , a 1 ), . . . , (o T , a T )]. These episodes are sampled from a variation τ ∼ ν. Finally, we define each task to be a set of variations,</p>
        <p>We now motivate the need for the concept of a 'variation' with an example. It is naturally difficult to come up with a precise way to differentiate between tasks given their subjective nature. For example, one could argue that "pick up the apple" and "pick up the banana" are different tasks, whilst one could also equally argue that they are the same "pick up the X" task. We therefore introduce the variation concept, which allows cases like the above to be grouped as very similar tasks. Moreover, given the way the task building tools are designed (discussed in Section IV-E), the variation concept allows a convenient way of getting as much from a task definition as possible, given that there is usually only a small amount of additional work needed to generate a large number of variations for a given task.</p>
        <p>Users will interface with the benchmark and learning environment through the Environment class. The Environment is the entry point and can spawn child environments, called TaskEnvironment, for the tasks you are interested in solving. The environment API, which Figure 5 demonstrates, is modelled after a typical agent-environment reinforcement learning setup. Each task has a completely sparse reward of +1 which is given only on task completion. Users have a wide variety of action spaces at their disposal, which include absolute or delta joint velocities, absolute or delta joint positions, absolute or delta joint torque, absolute or delta end-effector velocities, and finally absolute or delta end-effector poses.</p>
        <p>RLBench, through the task building tool mentioned in Section IV-E, provides expert algorithm π * for each different task and their corresponding variations, allowing for demonstration episodes to be generated The episodes produced via π * come from using the Open Motion Planning Library [38].</p>
        <p>Two common simulation environments in the literature today are Bullet [39] and MuJoCo [40]. However, given that these are physics engines rather than robotics frameworks, it can often be cumbersome to build rich environments and integrate standard robotics tooling such as inverse and 1 from 
            <rs type="software">rlbench</rs>.environment import Environment 2 from 
            <rs type="software">rlbench</rs>.action_modes import ActionMode 3 from 
            <rs type="software">rlbench</rs>.tasks import 
            <rs type="software">ReachTarget</rs> forward kinematics, user interfaces, motion libraries, and path planners. Given the scale of RLBench, we needed a tool for designing tasks as easily as possible.
        </p>
        <p>The task building tool is the interface for users who wish to create new tasks to be added to the RLBench task repository. Each task has 2 associated files: a V-REP model file (.ttm), which holds all of the scene information and demo waypoints, and a python (.py) file, which is responsible for wiring the scene objects to the RLBench backend, applying variations, defining success criteria, and adding other more complex task behaviours. Figure 6 shows an example of how simple many tasks files can be.</p>
        <p>In order to use the task creator, users must understand how tasks are initialised and placed in the scene. When a user asks for a new task from RLBench, the task is initialised by calling init task(), and is only called once. Following that, init variation(int i) is called at the beginning of each variation, and gets passed the variation number, which should be less than or equal to the number of variations for that task (which can be obtained by calling variation count()). This function returns a list of strings which provide descriptions that could be associated with this variation of the task; an analysis of the frequency of words in these descriptions can be seen in top of Figure 7. Finally, init episode() is called each time a new episode (of the same variation) is requested.</p>
        <p>Once a task has been created, we provide a task validation tool, that attempts to collect a number of demonstrations of the designed task in order to ensure that the path planning aspect of the task only fails a small number of times. Once the validator passes, the user will be free to perform a 1 from 
            <rs type="software">rlbench</rs>.backend.task import Task 2 from 
            <rs type="software">rlbench</rs>.backend.conditions import DetectedCondition, GraspedCondition 3 from pyrep.objects.shape import Shape 4 from pyrep.objects.proximity_sensor import ProximitySensor Fig. 6: An example of a task python file. When using the task building tool, users are able to simultaneously edit the V-REP scene whilst also changing the various behaviour of a task. In this example, the task is to take a lid off of a saucepan. By interfacing with the scene using 
            <rs type="software">PyRep</rs>, we register that the episode should terminate and be considered a success only if the saucepan lid is detected by a proximity sensor and that the lid is being held. The backend handles the randomisation of the position of the task at the beginning of each episode.
        </p>
        <p>GitHub pull request in order to contribute to the growing task repository.</p>
        <p>V. THE RLBENCH FEW-SHOT CHALLENGE (v 1.0)</p>
        <p>A big gap in the literature today is a means to evaluate and compare few-shot learning methods for robotics. We place particular emphasis on the few-shot regime, because much like humans, robots should have the ability to leverage knowledge from previously learned tasks in order to learn new ones quickly in new and unfamiliar environments. Despite this, most approaches in manipulation have focused on learning a single task, with a limited notion of generalisation, and no way of leveraging the knowledge to learn other tasks more efficiently.</p>
        <p>The few pieces of work that perform few-shot learning in robotics [5], [6], [7] focused on a very narrow definition of task and often treat a variation of the same task as another task; for example, placing a peach into a red bowl would be considered a different task to placing an apple into a green bowl. In order to develop truly general algorithms, we feel that it is important to have a diverse range of tasks to train and test on. To that end, we propose the following challenge:</p>
        <p>Given N unseen tasks, provide the system with K different demonstrations of each of the N tasks, and then evaluate the systems ability to perform these tasks in new configurations. Specifically, we suggest the following procedure: Fig. 7: Top shows the frequency of words in the variation descriptions with function words removed, leaving only content words. Bottom shows the average length of 5 demonstrations from a sample of 75 tasks (taken from the first variation). The tasks lengths vary from 100 to 1000 timesteps. Longer tasks usually involve many composed sets of actions, for example, the 'empty dishwasher' task involves opening the washer door, sliding out the tray, grasping a plate, and then lifting the plate out of the tray. These long-horizon tasks can facilitate interesting research in reinforcement learning in robotic tasks.</p>
        <p>• Of the 100 unique tasks, 10% of the tasks have been selected for the test set (meta-test) which span a range of difficulties, while the rest are chosen for training (metatrain). These train-test splits will be made available on the benchmark's webpage. • The training tasks can be used in any way desired by the user. 
            <rs type="software">RLBench</rs> supplies a large number of pre-generated demos for each task that can be downloaded, although there is also the option to generate demos on the fly (or for users to create their own). • During test time, the system is given K demonstrations of the unseen task (K-shot), and then success should be reported on new episodes of that same task. The only information available to the system should be the number of demos N and their corresponding observations. There must be no prior knowledge of the unseen tasks given to the system that are not included in the training tasks. Users report 1-shot, 5-shot, and 20-shot results for their method.
        </p>
        <p>We purposefully call this challenge v 1.0 as we expect the number of tasks to grow considerably over the years; as this happens, we will create newer versions that span a broader range of tasks; therefore, we hope this versioning will ensure results remain meaningful and reproducible as the benchmark grows. State-of-the-art few-shot learning methods such as recurrent methods [41], [42], [43], metric learning methods [44], [45], and gradient based methods [46], [47] have not been tested on such a grand scale, and we look forward to seeing how they perform on this benchmark.</p>
        <p>Further to the few-shot learning challenge highlighted in Section V, we briefly overview other areas of research that could benefit from RLBench.</p>
        <p>a) Reinforcement Learning: There is a large body of work in continuous control reinforcement learning that evaluate their algorithms on benchmarks such as OpenAI Gym [10] or 
            <rs type="software">DeepMind Control Suite</rs> [11]. Unlike these benchmarks, RLBench has been tailored for visually-guided manipulation, which makes this an ideal platform for evaluating current and future reinforcement learning algorithms on real-world based tasks. Moreover, given the large number of demonstrations provided, it opens up the space to accelerate and facilitate research in bootstrapping reinforcement learning policies with demonstrations in order to reduce sample complexity. In addition, with the provided eye-in-hand camera observations, we open research in partial observability or incremental estimation for continuous control tasks.
        </p>
        <p>b) Imitation Learning: Almost all imitation learning work design their own tasks for evaluating their method, making reproducibility difficult. A set number of demonstrations are shipped with RLBench, but there is also the option in the framework to generate demonstrations on-thefly, meaning that you cam generate an infinite amount for your imitation learning algorithm. c) Sim-to-Real Transfer: Recently there has been a large amount of work in learning control policies in simulation and then transferring these to the real world [48], [49], [50], [51], [52], [53]. The simulated Franka Panda within RLBench can be easily swapped out, with one line of code, for another arm that researchers may have in their lab; this means that sim-to-real methods could be compared more easily on a standard set of tasks. Moreover, given the taskbuilding tool and demonstration generation that 
            <rs type="software">RLbench</rs> has to offer, new tasks can easily be designed to demonstrate particular features in novel sim-to-real methods.
        </p>
        <p>d) Multi-task Learning: In contrast to few-shot learning, multi-task learning concerns itself with learning several tasks simultaneously without particularly being expected to generalise to radically different tasks at test time. In this setup, all tasks from both meta-training and meta-testing can be used during training, and then during testing, the system must be able to generalise to unseen examples of those tasks. Given the difficulty of the challenge laid out in Section V, tackling the multi-task problem could provide valuable insights to increasing performance in the few-shot domain.</p>
        <p>e) SLAM: Simultaneous Localisation and Mapping (SLAM) is concerned with constructing a map of an unknown environment while simultaneously keeping track of an agent's location within it. Traditionally SLAM has been limited to navigation, virtual reality and augmented reality domains; but ultimately we can envision SLAM systems playing a key role in robots interacting with the world, i.e. a focus on more task-based SLAM. However, if we would like a manipulation system to make use of a SLAM map, it is not currently clear what the best way to represent this map is: whether it be sparse [54], [55], dense [56], [57], or semidense [58]. Moreover, it is not clear what level accuracy the map would need in order to achieve a desired task. 
            <rs type="software">RLBench</rs> could facilitate research in unifying SLAM and manipulation more tightly.
        </p>
        <p>We have presented RLBench, an attempt to accelerate research in robotic manipulation that can be used in a broad range of robotic related research. We have posed the few-shot learning challenge for manipulation, and have highlighted a number of research areas that could benefit from this large scale benchmark and learning environment.</p>
        <p>Given the scale of this project, we envision that there may be teething problems as people begin using the platform, and so we aim to maintain and continuously improve the benchmark during launch. Further to that, we hope, along with the help of the community, to continuously expand the tasks available for both training and evaluation. We hope RLBench will become a key resource for a broad range of robot manipulation related research, and look forward to seeing what the community achieves with this diverse range of tasks.</p>
        <p>Dyson Robotics Lab, Imperial College London</p>
        <p>UROP, Imperial College London 1 https://sites.google.com/view/rlbench</p>
        <p>We thank Juxi Leitner, Ankur Handa and Eugene Valassakis for insightful feedback on an early draft of this paper. Research presented here has been supported by Dyson Technology Ltd.</p>
    </text>
</tei>
