<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-24T12:55+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Abstract-This paper presents a metaheuristic-based control framework, called Beetle Antennae Olfactory Recurrent Neural Network (BAORNN), for simultaneous tracking control and obstacle avoidance of a redundant manipulator. The ability to avoid obstacles while tracking a predefined reference path is critical for any industrial manipulator. The formulated control framework unifies the tracking control and obstacle avoidance into a single constrained optimization problem by introducing a penalty term into the objective function, which actively rewards the optimizer for avoiding the obstacles. One of the significant features of the proposed framework is the way that the penalty term is formulated following a straightforward principle: maximize the minimum distance between manipulator and obstacle. The distance calculations are based on GJK (Gilbert-Johnson-Keerthi) algorithm, which calculates the distance between manipulator and obstacle by directly using their 3D-geometries. Which also implies that our algorithm works for arbitrarily shaped manipulator and obstacle. Theoretical treatment proves the stability and convergence, and simulations results using LBR IIWA 7-DOF manipulator are presented to analyze the performance of the proposed framework.</p>
        <p>Index Terms-Obstacle Avoidance, Tracking Control, RNN, Metaheuristic Optimization.</p>
        <p>For a redundant robotic manipulator, the problem of tracking control and obstacle avoidance aims at computing an optimal control action to steer the end-effector along a required reference trajectory, while avoiding obstacles present in the environment. With the advances in robotics, the robotic manipulators have found increased research attention from academia as well as from industry [1]- [4]. Industries are interested in using the manipulators to automate the common tasks, e.g., moving, assembling, packing, and transporting the products. Accurate tracking control, along with obstacle avoidance, is a critical requirement for the industrial manipulators [5], [6]. To fulfill those requirements, redundant manipulators [7] are particularly desirable because the extra degree of freedoms (DOFs) provided by redundant joints helps in achieving secondary design objectives, such as obstacle avoidance [8]- [10]. It is well-known in the literature that the tracking control and obstacle avoidance in itself are challenging problems [11]. Unifying these two problems into single framework present an intricate technical challenge.</p>
        <p>Several aspects of industrial manipulators have been extensively studied in the academic literature. Apart from tracking control algorithms, particular emphasis has also been placed on designing optimal task-space trajectories for the manipulator as well as analyzing the repeatability of the controller to repeatedly track the generated trajectory have been of great interest [12], [13]. For example, one of the traditional control algorithm, called Jacobian-matrix-pseudo-inverse (JMPI), was shown to have poor repeatability [14]. Jerzy et al. [15] proposed a systematic procedure to measure the pose repeatability of an industrial manipulator and discussed the concerning factors additional to the control algorithm, e.g., mechanical and thermal strain. Similarly, several algorithms have been proposed to increase the repeatability of the manipulator during long-term operation [16]. Other approaches to improve the repeatability of the manipulator involves the learning algorithm to estimate the kinematic model of the manipulator in real-time [17]. The learning algorithm continually adapts to variation in the system model and compensate for them in real-time. Similarly, visual Servoing based approaches have also been proposed to use computer vision algorithms in improving the control of industrial manipulators [18].</p>
        <p>Kinematic tracking control of a redundant robotic manipulators is a well-studied problem in robotic literature [7], [10], [19]. For example, consider an industrial manipulator, assigned to move an object from one point to another by following a specified trajectory in the cartesian task-space. For a redundant manipulator, corresponding to a given trajectory in cartesian space, infinite numbers of trajectories exist in joint-space. Traditionally, Jacobian-matrix-pseudo-inverse (JMPI) [20] is to used resolve the redundancy. However, JMPI can only be used to solve equality constraint and therefore, does not respect the joint-angle limits. Additionally, it cannot accommodate obstacle avoidance, which usually modeled as inequality constraints [11], [21]. Furthermore, the calculation of pseudo-inverse of Jacobian is a computationally extensive task. Modern approaches to redundancy resolution model the kinematic control as a constrained optimization problem [8]- [10]. These optimization-centric approaches are capable of solving additional inequality constraint simultaneously with the tracking control problem. For example, Wei et al. [22] and Wang et al. [23] used it for tracking control of manipulators with flexible joints. Li et al. [19] proposed a dual Recurrent Neural Network (RNN) for solving the tracking-control optimization problem for multiple manipulators in real-time. Adaptive control techniques have also been proposed in literature [24]- [27] which estimate the system model in real-time to increases the robustness of the tracking controller.</p>
        <p>Obstacle avoidance is also an essential goal, along with the tracking control of the robotic manipulator [11]. The industrial robots often need to operate in a complex environment and interact with other robots and objects present in the surrounding. A traditional method for obstacle avoidance uses the concept of "artificial force field", like one proposed by Khatib [28] in which the goal position act as attractive pole whereas obstacles act as repulsive poles. However, their proposed algorithm is formulated in cartesian space and needs further computation for calculating the necessary control actions in the joint-space. Similarly, Flacco et al. [29] proposed an algorithm based on the robot-obstacle distance information obtained using a depth sensor. Guo and Zhang [21] proposed an approach at joint-acceleration level approach by minimizing the joint-acceleration norm. Zhang et al. [11] proposed a tracking control and obstacle avoidance algorithm, however, there proposed algorithm treats the obstacle as a point object and does not account for 3D-geometry of the manipulator and the obstacle. The traditional methods mostly incorporate obstacle avoidance as inequality constraint in the optimization problem. These constraints do not actively reward the optimizer for avoiding obstacles and only act passively. Our proposed problem formulation tries to overcome this issue by using a penalty term in the objective function. To summarize, the problems being addressed in this paper are 1) Formulating a tracking controller for a redundant manipulator to compute the necessary control actions in joint-space to track a specified task-space trajectory. 2) While tracking the reference trajectory, the controller should satisfy the joint-angle limits.</p>
        <p>3) The objects present in the surrounding of the manipulator are considered obstacles, and their collision with the manipulator should be avoided.</p>
        <p>In this paper, we take advantage of the fact that optimization-centric approach allows any arbitrary goal to be achieved by adequately formulating the objective function [8], [9]. We incorporate the obstacle avoidance problem into the tracking control framework by adding a penalty term in the objective function along with an inequality constraint. The penalty term approach used in our paper actively reward the optimizer for avoiding the obstacle, which is in contrast with the traditional obstacle avoidance approaches, which simply add an inequality constraint [11]. With this, the obstacle avoidance and tracking control problem essentially reduces to solving the formulated optimization problem in real-time. Our formulated objective function has two goals: 1) Tracking control, i.e., minimize the Euclidean distance between reference trajectory and the end-effector's trajectory, 2) Maximize the distance between the links of the manipulator and the obstacles. We used the Gilbert-Johnson-Keerthi (GJK) algorithm [30], to calculate the distance between manipulator's links and the obstacle by directly using their 3D-geometries.</p>
        <p>To solve the optimization problem in real-time, we take a metaheuristic approach; called Beetle Antennae Olfactory Recurrent Neural Network (BAORNN). We leverage the metaheuristic optimization algorithms, which are well-known [31], [32] for their ability to efficiently solve the complex nonlinear non-convex optimization problem. Our proposed algorithm is based on a nature-inspired metaheuristic optimization algorithm; Beetle Antennae Olfactory (BAO) algorithm [33], [34], inspired by the food searching behavior of beetles. Although recently introduced, BAO has shown practical applications in several real-world scenarios [35], [36] and therefore, the reason for our choice for solving the formulated optimization problem. Specifically, The formulation of the BAO algorithm allows the use of the "virtual robots", which virtually anticipate the consequences of joint-actions and only move the real robot when accuracy and collision-safety are guaranteed. We modeled the BAO algorithm as a Recurrent Neural Network (RNN) which enables fast prototyping and will be able to leverage the hardware acceleration, distributed processing, and software optimizations, offered by modern computing frameworks when implemented in an industrial setting.</p>
        <p>It should be further noted that the tracking controller presented in this paper is designed on position-level as opposed to velocity-level as done by the most traditional works on tracking control of redundant manipulators [11], [17], [19]. This approach is advantageous because it does not require that initial position of end-effector to lie on the reference trajectory, whereas the velocity-level controllers explicitly require moving the end-effector to the initial point on the reference trajectory. Additionally, the velocity-level controllers require the computation of Jacobian pseudo-inverse at each time-step, resulting in high computation cost. Position-level control, however, altogether avoid the mathematical manipulation of the Jacobian matrix, thereby significantly reducing the computation cost. Additionally, It is also worth noting that unlike the traditional obstacle avoidance algorithms, the proposed algorithm does not make an assumption about the shape of the obstacle, neither consider it as a point object [11]. The proposed algorithm directly use the 3D-model of the manipulator to calculate the distance of its link from the obstacle. As such, it works for any arbitrary manipulator and obstacle shape, which makes it realistic for an actual industrial setup. Although the algorithm requires 3D-geometry of the obstacle, with modern depth mapping sensors, this can be easily achieved. The main highlights of this paper are:</p>
        <p>1) We propose an optimization framework for unifying the tracking control and obstacle avoidance problems by using the penalty term approach. It fulfills two objectives: i) Minimize the tracking error, ii) Maximize the manipulator-obstacle distance. 2) We formulate the tracking control problem on position-level as compared to velocity-level as done in most traditional works. The position-level control avoids the manipulation and pseudo-inversion of the Jacobian matrix, consequently reducing the computation cost. 3) Using the GJK algorithm, to efficiently measure the distance between a manipulator and an arbitrarily-shaped obstacle by directly using their 3D-geometries, without making any assumption about their shapes. 4) We propose a metaheuristic based recurrent neural network, BAORNN, to efficiently solve the formulated optimization problem so that the manipulator can be controlled in real-time. 5) Extensive numerical analysis using a simulated model of KUKA LBR IIWA-14, a popular 7-DOF industrial robotic arm, are performed to demonstrate the performance of the proposed algorithm. The remainder of this paper is organized as follows: Section II presents the problem formulation of the tracking control and obstacle avoidance. In Section III, firstly, the GJK algorithm is described briefly, and then the details of BAORNN algorithm are laid down. Theoretically, analysis is presented to prove the global convergence of the algorithm. Section IV outlines the simulation methodology, present the results, and discuss their implications. Section V concludes the paper.</p>
        <p>In this section, we will mathematically formulate the tracking control and obstacle avoidance problem and unify them into one optimization framework.</p>
        <p>Consider the task of moving a payload using robotic manipulator along a specified trajectory, say a circular path. Tracking control deals with the calculation of the joint-space trajectory, which will move the end-effector in the specified circular path. For a given robotic manipulator, the position of its end-effector is a function of its joint-angles. For example, consider a m-DOF robotic manipulator operating in a n-dimensional task-space (n = 3 for position control). The forward kinematic mapping is a surjective function of the joint-space coordinates</p>
        <p>where x(t) ∈ R n and θ(t) ∈ R m are the task-space and joint-space coordinates respectively. Note that m &gt; n for a redundant manipulator. The forward kinematic mapping f (.) is a nonlinear vector-valued function, which is trivial to formulate using the mechanical design and Denavit-Hartenberg (DH) parameters for a given manipulator. However, the task for a manipulator is usually specified in the cartesian task-space instead of the joint space. Therefore, we are more interested in the inverse mapping, i.e., mapping from the task-space to the joint-space. Using 1, an inverse kinematics model can be defined</p>
        <p>where f -1 (.) denotes the inverse kinematic mapping. Now consider a reference trajectory x r (t) for end-effector position in cartesian task-space. To trace this trajectory, the corresponding angles θ r (t) in joint-space must satisfy the following equation,</p>
        <p>Our goal is to solve the above equation for the value of θ r (t).</p>
        <p>If a closed-form expression for f -1 (.) exist, we can trivially solve this equation using θ r (t) = f -1 (x r (t)). However, for a redundant manipulator, the forward kinematic mapping f (.) is surjective-only and not one-to-one, i.e., there exist an infinite solutions θ r (t) in the joint-space, which are mapped to the same reference trajectory x r (t).</p>
        <p>To resolve the redundancy, i.e., calculate an optimal joint-space trajectory out of infinitely many possible trajectories; we model the tracking control as following optimization problem</p>
        <p>where g tr (.) is the tracking objective function and defined as</p>
        <p>where x r is the current point on the reference trajectory and θ are the current joint-angles.</p>
        <p>Remark 1. In the formulation of tracking control objective function, only the kinematic model of the manipulator is considered. The tracking control algorithm based on kinematic models are intensively studied for the control of the manipulator as shown by recent works [17], [37]. Apart from the academic research, kinematic control is also widely used in commercial robotic systems such as ping-pong manipulator [38], ABB IRB 360 [39], Adept Quattro 650HS [40], DOBOT, and UR 10 manipulator.</p>
        <p>The solution to optimization problem (4) does not guarantee that the manipulator does not collide with an obstacle. Our obstacle avoidance strategy is based on the principle: maximizing the minimum distance the links of the manipulator and the obstacle. To incorporate this principle into our control framework, we formulate an additional objective function which penalizes the angles in joint-space which bring the robot close to the obstacle. The obstacle avoidance optimization problem is defined as</p>
        <p>where g OI (.) is called the obstacle avoidance objective function; which is a function of O ∈ R n O ×3 , the 3D-geometry of the obstacle, i.e., cartesian coordinates of all its vertices, and θ, the joint-angles of the manipulator. Here n O is the number of vertices in the 3D model of the obstacle. High value of n O results in a fine-grained 3D-mesh. The objective function g OI (.) is defined as</p>
        <p>where θ are the current joint-angles, m is the total number of links in the manipulator and d i (O, θ) is the distance of i th link from the obstacle O. The reciprocal relation ensures that decreasing the value of objective function increases the distance between links and obstacle. β is a hyper-parameter, and from simulation analysis, we found that β = 1 provides the best performance. The value of the distance is calculated using the GJK algorithm (refer to Section III-C for further details)</p>
        <p>here again i ∈ {1, 2, ..., m}. Since GJK algorithm requires 3D-geometry of the two objects, so we defined a function M i (θ) ∈ R ni×3 which returns the vertices of i th link. Similar to n O , n i is the number of vertices in the 3D-geometry i th link. It must be noted that the location of vertices change when manipulator moves, i.e., it is a function of joint-angles θ. The initial geometry, M i (0), is a given information for a manipulator based on its mechanical model. The subequent values of M(θ) are calculated using</p>
        <p>where R i (θ) and T i (θ) are the rotation and translation matrix for the i th link. These matrices can be calculates using the forward kinematic model of manipulator.</p>
        <p>A solution to optimization problem of ( 4) or ( 6) does not guarantee that the solution will lie within the mechanical limit of the joint. To guarantee the solution does not violate the joint-angle limits, the following constraint must be satisfied</p>
        <p>where θ -and θ + denote the lower and upper limits on the joints-angles respectively, the value of these limits depend on the mechanical construction of the manipulator and the type of actuator used to move the joints.</p>
        <p>Above, we formulated three seperate component of the problem: tracking control (4), obstacle avoidance (6) and joint-angle limits (9). These can be unified into the following optimization problem</p>
        <p>where g(.) is the unified objective function defined as</p>
        <p>where Λ is a constant parameter which controls the trade-off between tracking performance and maximizing the manipulator-obstacle distance. A value of Λ = 0 turns off the obstacle avoidance completely. The value of Λ greatly affect obstacle avoidance performance. Its effect is discussed in detail in Section IV. Remark 2. The obstacle avoidance objective function g OI (O, θ) acts as a penalty term in the unified objective function above. When the manipulator is moved far from the obstacle, the value of the penalty term becomes small, and the algorithm rewards the optimizer by reducing the overall value of the objective function.</p>
        <p>Although the penalty term approach actively reward the optimizer to avoid the obstacle, but consider a circumstance where the position of obstacle makes it impossible to track the reference trajectory; to avoid the collision in such a condition, we add inequality constraint to (10),</p>
        <p>The second constraint puts a hard lower-bound, d min , on obstacle-manipulator distance.</p>
        <p>Based on the above formulation, the complete form of the optimization problem can be written as</p>
        <p>The solution to this optimization problem gives the joint-space trajectory θ r (t). Now we will formulate the BAORNN algorithm in Section III to solve this optimization problem in real-time.</p>
        <p>In this section, we will first formulate the BAORNN algorithm. Then we will briefly describe the GJK algorithm used for calculating the distance between the manipulator and the obstacle.</p>
        <p>After the problem formulation in Section II, the tracking control and obstacle avoidance finally boils down to solving the optimization problem (13) in real-time while the manipulator is operating. BAORNN algorithm mimics the behavior of a beetle; which uses its pair of antennae and olfactory sense to probe an unknown environment in search of food (i.e., search for the region with maximum smell). At each step, beetle measure magnitude of smell at both antennae before deciding the direction of its next step. Especially, note the intermediary action; i.e., instead of randomly moving in any directions, the beetle stops after each step, uses just the olfactory sense to develop better intuition about goal direction and only then makes a calculated decision to take the next step. This overall behavior especially the intermediary action inspired us to incorporate the concept of "virtual manipulators" (analogous to antennae's olfactory sense) into our control framework and develop a heuristic mechanism to control the manipulator.</p>
        <p>Suppose, at time-step k, the manipulator starts at θ 0 in joint-space. The algorithm generates a normalized normally distributed random direction vector b ∈ R m analogous to the )</p>
        <p>Eq. 11</p>
        <p>Eq. 11 Use the generated random vector to calculate the location of left and right antennae, θ kL and θ kR respectively, using (15). Project the location of these antennae on the constrained set Ω using the projection function P Ω as defined in (16) to . Calculate the value of objective function at both location using "Virtual manipulators" as defined in (17). Calculate he updated location in joint-space using (18). Check if the updated location improves the value of objective function using (20).</p>
        <p>Move the manipulator to θ k+1 and update the value of g k+1 . k ← k + 1 end antenna of the beetle. Using direction vector b, the location of end-point of the antennae can be calculated as</p>
        <p>where λ k is a hyper-parameter representing the length of the antenna, θ kL and θ kR denotes the location of left and right antennae respectively at time-step k. However, these vectors might not satisfy the constraint of the problem (13). Therefore we project these vectors onto the constrained set</p>
        <p>where X ∈ {L, R}, P Ω (.) is the projection function which restrict the input inside the constrained set Ω. The set Ω is mathematically defined as,</p>
        <p>There are several way to project a vector θ on a set Ω, here we define a computationally straightforward projection function</p>
        <p>where again X ∈ {L, R}, d i is same as defined in (8). The projected antennae locations Ω θ kL and Ω θ kR , is then used to evaluate the value of objective function</p>
        <p>where g kX (X ∈ {L, R}) is the value of objective function at antenna locations.</p>
        <p>We then use the calculated values of the objective function at antennae locations, g kX , to move in a direction, inside joint-space, where the value of the objective function is decreasing by using the following update rule</p>
        <p>where Ω θ k+1 is the updated location in joint-space projected on set Ω, sign(g L -g R ) b term ensure that the next step is taken in direction of the antennae with small objective function value. δ k (λ k ), is a hyper-parameter and denotes the step-size, i.e., euclidean distance between Ω θ k+1 and θ k locations. The step-size is a function of antennae length λ k ; there relationship will also be discussed later. After calculating Ω θ k+1 , the value of objective function is re-evaluated</p>
        <p>the value of g k+1 is compared to the value of objective function at previous time-step g k . If there is any improvement (i.e., the updated value is smaller), then the robot moves to Ω θ k+1 in joint-space; otherwise, it remains at the current location</p>
        <p>Similarly, the value of g k+1 is assigned to use in next iteration</p>
        <p>After moving to θ k+1 , the iterative procedure is repeated for the next time-steps. The steps of the proposed BAORNN algorithm are systematically presented in Algorithm 1.</p>
        <p>The choice of hyper-parameter λ k and δ k (λ k ), where k denotes time-step, affects the speed of convergence. By empirical analysis, we found that the following rules for the selection of hyper-parameters provide a reasonable convergence rate</p>
        <p>where c 1 and c 2 are constant design parameters. The above relation regulate step-size such that the algorithm takes large steps when the end-effector is far from the goal position and make the steps extremely small when reached near the goal. The small step-size is necessary to prevent the overshooting of end-effector near goal position. For c 1 and c 2 , we propose the following rules for fast convergence.</p>
        <p>where T s is the sampling time of the control loop. The proposed BAORNN is formulated as RNN, as shown in Fig. 1a. The formulated RNN has a two-layered topology with a temporal-feedback connection from the second layer to the first layer. RNN architecture has a total of 3m + 6 neurons. The block "Random" represents a random vector generator and provide normally distributed unit direction vector b for the BAORNN algorithm. The neurons, shown as circles, use projection P Ω (.) as their activation function. The neurons shown as curved rectangular boxes represent "virtual manipulators", and their activation function is given by f (.). Similarly, the neurons represented by curved boxes (in cyan) represent the objective function evaluation, and their activation function is given by g(.).</p>
        <p>By parsing the RNN architecture shown in Fig. 1a, it can be shown that the algorithm has a complexity of O(m), i.e., the computational complexity is just a linear function of the number of joints. The algorithm involves elementary floating-point operations, which can be executed very efficiently on embedded processors since modern embedded processors have dedicated hardware unit for floating-point calculations.</p>
        <p>B. Theoritical Analysis Theorem 1. For the tracking control and obstacle avoidance of a redundant manipulator, starting from an initial joint-space angles θ 0 ; the joint-space trajectory θ r (t) generated by BAORNN algorithm is stable, i.e.,</p>
        <p>the values of objective function are monotonically decreasing.</p>
        <p>Proof. See Lemma 1 of [34].</p>
        <p>Theorem 2. For the tracking control and obstacle avoidance of a redundant manipulator, starting from an initial joint-space angles θ 0 ; the end-effector trajectory f (θ r (t)) is convergent to the reference trajectory x r (t), i.e.,</p>
        <p>Proof. See Theorem 1 of [34].</p>
        <p>GJK algorithm is an efficient algorithm to calculate the minimum distance between two arbitrarily shaped convex 3D-polygons. Although, in our case, the 3D-geometry of a manipulator link or the obstacle might be non-convex shape, however, the collision avoidance between convex-hulls of both objects is a sufficient condition for real collision avoidance.</p>
        <p>Consider two convex polygons A and B in 3D-space, their vertices defined by matrices</p>
        <p>respectively. n A and n B are the numbers of vertices of polygon A and B respectively. Each row of these matrices represents the location of a vertex of the corresponding polygon. The GJK algorithm takes these matrices and calculates the minimum distance between the closest vertices of the two polygons,</p>
        <p>where the notation V i: is used to represent the i th row of a matrix V . Fig. 1b illustrates GJK-algorithm.</p>
        <p>Here we will estimate the computational complexity of the BAORNN algorithm formulated in Section III-A. The first step in the algorithm is the generation of is a random vector b with m elements; the operation requires m floating-point operations. Next, we calculate θ kL and θ kR , each requiring m multiplication and m additions, totalling 4m floating-point operations. Next step requires the projection of two vectors using the projection function f Ω (.), which require a total of 4m comparisons. Then we use (17) to calculate the value of objective function at both antennae location. The evaluation of objective function is the most computationally intensive step of the algorithm since it requires the calculation of Euclidean distance as well as GJK-distance, as given in (11). The calculation of Euclidean distance require a total of 3m -1 floating-point operations (m subtractions, m squaring operations and m -1 additions). The calculation of GJK-distance depends on the number of vertices in the 3D models of two objects and require a total of n A + n B operations, as shown by [41]. Where n A and n B are the numbers of vertices in the 3D model of both objects, respectively. For the case of manipulator and obstacle distance, using the notation of Section II-B, the total number of operation comes out to be n O m i=1 n i . Although this number is large, these operations are only required in the first iterations of the algorithm, the later iterations of GJK-algorithm are near-constant time, as pointed out by [41], [42]. Therefore, the total number of operations required by GJK-algorithm are effectively m. It means that a total of 4m + 2 operations are required for evaluating the objective function; some additional operations are required for the scalar addition and multiplication as given in (11). Since objective function is evaluated twice in (17), therefore this step require a total of 8m + 4 operations. The next step, as given in (18), requires a total of 2m + 1 floating-point operations. Similarly, the subsequent step is again objective function evaluation requiring 4m + 2 operations. The final step of the algorithm, as given in ( 20) and ( 21), require a total of 2m comparisons. Adding the floating-point operations required for each step as calculated above; the final count comes out to be (m + 4m + 4m + (8m + 4) + (2m + 1) + (4m + 2) + 2m) = 25m + 7.</p>
        <p>The above analysis shows that the BAORNN algorithm have a complexity of O(m), where m are the total number of links of the manipulator. This show that the complexity of the BAORNN algorithm is only linearly related to the number of links of manipulator. For m = 7, as in the case of IIWA14 manipulator, the required number of operations per iterations are of the order of 182. Modern embedded processors can efficiently perform floating-point operations of this order withing few hundred of microseconds.</p>
        <p>In this section, simulation methodology, for evaluating the performance of the proposed algorithm, is presented along with the obtained results and discussion. Simulated model of KUKA LBR IIWA-14 manipulator is used as a testbench. The IIWA-14 has 7-DOF. 3D-model of the manipulator is shown in Fig. 2.</p>
        <p>We used the model of IIWA-14 provided by 
            <rs type="software">MATLAB</rs>
            <rs type="software">Robotic System Toolbox</rs> [43]. The model provides an excellent representation of a real-world industrial manipulator and therefore act as a desirable simulation testbed. To test the obstacle avoidance performance, we placed an arbitrarily shaped obstacle in front of the manipulator. The simulation setup, including manipulator and obstacle, is shown in Fig. 2.
        </p>
        <p>We used two reference trajectories [19] in our simulations: a rectangular and a circular trajectory as shown in Fig. 3 These values represent a circlular path in x -z plane at y = 0.6. The two trajectories mentioned above were chosen for developing simulation results in this paper. Without the loss of generality, the proposed algorithm works for an arbitrarily shaped reference-trajectory, provided that all the points on the trajectory are reachable by the end-effector without violating the mechanical limits of the manipulator's joints.</p>
        <p>To systematically study the effect of the proposed algorithm, we first conducted a simulation without any obstacle-avoidance, i.e., setting Λ = 0 in (13) and ignoring the 2 nd constraint. Then we performed simulations with different values of Λ and its effect on the obstacle avoidance performance is discussed in details.</p>
        <p>The first set of the simulation consists of analyzing the response of the manipulator without obstacle avoidance as described in Section IV-A. The results for rectangular and circular trajectories are both shown in Fig. 3. It can be seen that several angles in joint-space resulted in a collision with the obstacle. It is because the algorithm calculated a joint-space trajectory which minimized the tracking error without considering the obstacle in its path.</p>
        <p>Next we simulated the response of the system with different values of Λ as defined in (11). Fig. 4 shows the result for rectangular reference trajectory. The initial configuration of the manipulator's joint is assumed to be home configuration, i.e., all joint-angles are zero at the beginning. Fig. 4a to Fig. 4e summarizes the manipulator's response for Λ = 0.002.</p>
        <p>Fig. 3: Performance of tracking controller after switching-off the obstacle avoidance term, i.e., Λ = 0 as defined in (11).</p>
        <p>The links collide with obstacle for both trajectories.</p>
        <p>Fig. 4a shows the motion of each links of the manipulator along with the reference trajectory (shown in blue). The initial portion of the manipulator's trajectory lies away from the reference trajectory because the manipulator starts from home configuration and algorithm takes some time to find an optimal joint-space trajectory which takes the end-effector near the reference trajectory while avoiding the obstacle.</p>
        <p>Once the end-effector reaches near the reference trajectory, it accurately follows it for the rest of the path. Top view of the manipulator's trajectory is also shown as inset graphic, which confirms that the manipulator does not collide with an obstacle at any point. Fig. 4b shows the cartesian coordinates of end-effector motion and Fig. 4c shows the joint-space coordinates of the manipulator trajectory. It is worth pointing out that the unsmooth response shown by these trajectories is typical of metaheuristic algorithms because of the stochastic nature; however, the resultant gain in computational efficiency is much greater. Fig. 4d shows the position tracking error which is defined as e(t) = x r (t) -f (θ r (t)). At t = 0, it shows a huge tracking error of ≈ [0.5 -0.5 0.7] T ; again, this is the result of starting from the home configuration, which requires some time for reaching the reference trajectory. However, after some time, he tracking error converges as the end-effector finally converges to the reference trajectory. It also proves that the global convergence performance of the proposed algorithm, i.e., the tracking error converges to zero and does not rise again, except for some small ripples caused by the stochastic nature of the algorithm. Similarly, Fig. 4e shows the minimum distance of any link of the manipulator from the obstacle as defined in (7). A high value is desirable because it reduces the risk of collision in case of uncertainty in obstacle position or error in the manipulator model. We set d min = 0.02, which acts as a lower limit for the minimum manipulator-obstacle distance. We repeated the same set of simulations with Λ = 0.0002. Fig. 4f to Fig. 4j summarizes the manipulator's response. The major difference between these two situations is the quality of the obstacle avoidance performance. Fig. 4j shows that the minimum manipulator-obstacle distance is smaller as compared to Fig. 4e, i.e., the links of manipulator were closer to the obstacle as compared to the latter case, increases the risk of collision.</p>
        <p>The same conclusion can be drawn from the inset graphics of Fig. 4f and Fig. 4f which shows that the links are much closer to obstacle in second case as compared to the first case. We had to reduce the value of d min to 0.002 to successfully simulate a complete rectangular trajectory without colliding with an obstacle. The simulation results for the circular reference trajectory are shown in Fig. 5. These results show a similar trend. For a small value of Λ, the manipulator-obstacle distance decrease, and we had to reduce d min to complete the simulation. However, for a higher value of Λ, the algorithm shows an excellent performance in avoiding the obstacle. It should, however, be noted that increasing the value too much will significantly decrease the tracking performance because the algorithm will aggressively try to avoid the obstacle.</p>
        <p>In this paper, we proposed a framework to simultaneously address the problem of tracking control and obstacle avoidance in real-time. The proposed framework unifies the two goals into a single constrained optimization problem. The penalty term approach significantly improves the performance of the proposed algorithm by actively rewarding the optimizer for avoiding the obstacle. This approach results in a joint-space trajectory which maximizes the distance manipulator-obstacle distance. To solve the formulated optimization problem, in real-time, we proposed an RNN based on a metaheuristic optimization algorithm, called Beetle Antennae Olfactory. A key feature of the proposed framework is that it does not make assumptions about a specific shape of the obstacle. It directly uses the 3D-geometries of the manipulator and obstacle for formulating the penalty term using GJK-algorithm. Potential application of such an approach includes the operation of a manipulator in a dynamic environment where the shape of the obstacle is time-varying. The application of the GJK-algorithm to measure manipulator-obstacle distance allows the controller to work for an arbitrarily-shaped obstacle. Similarly, the proposed algorithm is also particularly useful for surgical-robots where it is critical to maintaining a safe distance, between the links of the manipulator and the patient, to ensure safety. The theoretical treatment is also presented in the paper to prove the stability and convergence of the proposed algorithm. Simulations using a KUKA LBR 7-DOF industrial manipulator are presented to prove the performance of the proposed algorithm.</p>
        <p>Potential further directions to improve the capability and performance of the proposed algorithm includes; extending the formulation of the optimization problem to incorporate multiple obstacles while keeping the calculation of manipulator-manipulator distance computationally efficient. Another exciting application of the proposed algorithm is to enhance the safety of surgical-robots by actively Λ = 0.002 Link-8</p>
        <p>Top View (a)</p>
        <p>x x (t)</p>
        <p>x y (t)</p>
        <p>x z (t) Link-8</p>
        <p>Top View (f)</p>
        <p>x x (t)</p>
        <p>x y (t)</p>
        <p>x z (t) Link-8</p>
        <p>Top View (a)</p>
        <p>x x (t)</p>
        <p>x y (t) x z (t) Link-8</p>
        <p>Top View (f)</p>
        <p>x x (t)</p>
        <p>x y (t) x z (t) GJK-distance of the manipulator from obstacle as defined in (7). (f-j) Shows similar results for Λ = 0.0005. It must be noted that the minimum manipulator-obstacle distance for Λ = 0.005 is much better (i.e., larger) as compared to Λ = 0.0005. (k) Simulation model of the LBR IIWA-14 robot while tracking the reference trajectory for Λ = 0.005.</p>
    </text>
</tei>
