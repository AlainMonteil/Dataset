<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-13T15:22+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>This paper establishes a new multi-unmanned aerial vehicle (multi-UAV) enabled mobile edge computing (MEC) system, where a number of UAVs are deployed as flying edge clouds for large-scale mobile users. In this system, we need to optimize the deployment of UAVs, by considering their number and locations. At the same time, to provide good services for all mobile users, it is necessary to optimize task scheduling. Specifically, for each mobile user, we need to determine whether its task is executed locally or on a UAV (i.e., offloading decision), and how many resources should be allocated (i.e., resource allocation). This paper presents a two-layer optimization method for jointly optimizing the deployment of UAVs and task scheduling, with the aim of minimizing the system energy consumption. By analyzing this system, we obtain the following property: the number of UAVs should be as small as possible under the condition that all tasks can be completed. Based on this property, in the upper layer, we propose a differential evolution algorithm with an elimination operator to optimize the deployment of UAVs, in which each individual represents a UAV's location and the whole population represents an entire deployment of UAVs. During the evolution, we first determine the maximum number of UAVs. Subsequently, the elimination operator gradually reduces the number of UAVs until at least one task cannot be executed under delay constraints. This process achieves adaptive adjustment of the number of UAVs. In the lower layer, based on the given deployment of UAVs, we transform the task scheduling into a 0-1 integer programming problem. Due to the large-scale characteristic of this 0-1 integer programming problem, we propose an efficient greedy algorithm to obtain the near-optimal solution with much less time. The effectiveness of the proposed two-layer optimization method and the established multi-UAV enabled MEC system is demonstrated on ten instances with up to 1000 mobile users.This paper establishes a new multi-unmanned aerial vehicle (multi-UAV) enabled mobile edge computing (MEC) system, where a number of UAVs are deployed as flying edge clouds for large-scale mobile users. In this system, we need to optimize the deployment of UAVs, by considering their number and locations. At the same time, to provide good services for all mobile users, it is necessary to optimize task scheduling. Specifically, for each mobile user, we need to determine whether its task is executed locally or on a UAV (i.e., offloading decision), and how many resources should be allocated (i.e., resource allocation). This paper presents a two-layer optimization method for jointly optimizing the deployment of UAVs and task scheduling, with the aim of minimizing the system energy consumption. By analyzing this system, we obtain the following property: the number of UAVs should be as small as possible under the condition that all tasks can be completed. Based on this property, in the upper layer, we propose a differential evolution algorithm with an elimination operator to optimize the deployment of UAVs, in which each individual represents a UAV's location and the whole population represents an entire deployment of UAVs. During the evolution, we first determine the maximum number of UAVs. Subsequently, the elimination operator gradually reduces the number of UAVs until at least one task cannot be executed under delay constraints. This process achieves adaptive adjustment of the number of UAVs. In the lower layer, based on the given deployment of UAVs, we transform the task scheduling into a 0-1 integer programming problem. Due to the large-scale characteristic of this 0-1 integer programming problem, we propose an efficient greedy algorithm to obtain the near-optimal solution with much less time. The effectiveness of the proposed two-layer optimization method and the established multi-UAV enabled MEC system is demonstrated on ten instances with up to 1000 mobile users.</p>
        <p>With the increasing popularity of mobile devices, more and more new types of mobile applications have emerged, such as mobile online gaming [1] and speech recognition [2].With the increasing popularity of mobile devices, more and more new types of mobile applications have emerged, such as mobile online gaming [1] and speech recognition [2].</p>
        <p>However, these applications are sensitive to latency and require considerable computation resources. Due to the physical limitations such as battery power and computation resources, it poses a great challenge for mobile devices to execute these applications [3].However, these applications are sensitive to latency and require considerable computation resources. Due to the physical limitations such as battery power and computation resources, it poses a great challenge for mobile devices to execute these applications [3].</p>
        <p>Mobile edge computing (MEC), which deploys servers to the network edge [4], [5], has been considered as a promising technology to address this challenge. In MEC, mobile devices can offload their tasks to the servers close to them. Compared with mobile cloud computing, MEC consumes less transmission time and energy due to shorter transmission distance. However, the locations of MEC servers are usually fixed and cannot be flexibly changed according to the needs of mobile users, which limits MEC's capability.Mobile edge computing (MEC), which deploys servers to the network edge [4], [5], has been considered as a promising technology to address this challenge. In MEC, mobile devices can offload their tasks to the servers close to them. Compared with mobile cloud computing, MEC consumes less transmission time and energy due to shorter transmission distance. However, the locations of MEC servers are usually fixed and cannot be flexibly changed according to the needs of mobile users, which limits MEC's capability.</p>
        <p>In recent years, unmanned aerial vehicles (UAVs) have received extensive attention in wireless communications [6]- [8]. For example, UAVs have been used in areas with limited communication infrastructures, such as in developing countries or mountainous areas, as well as in earthquake response, emergency rescue, and battlefield communication [9]. Very recently, a UAV-enabled MEC wireless powered system has been studied in [10], in which a MEC server is mounted on a UAV (i.e., a flying edge cloud). This kind of system can provide two advantages: 1) due to the higher altitude, the flying edge cloud can provide better line-of-sight links to mobile users with a higher probability, and 2) since the UAV can be flexibly deployed, it can further shorten the transmission distance. Overall, this kind of system can provide better services to mobile users. Therefore, the use of UAVs is expected to play an important role in improving the performance of MEC.In recent years, unmanned aerial vehicles (UAVs) have received extensive attention in wireless communications [6]- [8]. For example, UAVs have been used in areas with limited communication infrastructures, such as in developing countries or mountainous areas, as well as in earthquake response, emergency rescue, and battlefield communication [9]. Very recently, a UAV-enabled MEC wireless powered system has been studied in [10], in which a MEC server is mounted on a UAV (i.e., a flying edge cloud). This kind of system can provide two advantages: 1) due to the higher altitude, the flying edge cloud can provide better line-of-sight links to mobile users with a higher probability, and 2) since the UAV can be flexibly deployed, it can further shorten the transmission distance. Overall, this kind of system can provide better services to mobile users. Therefore, the use of UAVs is expected to play an important role in improving the performance of MEC.</p>
        <p>However, the current study in [10] only considers one UAV. A question which arises naturally is whether we can deploy multiple UAVs simultaneously to serve mobile users. Compared with a single UAV, multiple UAVs can support more tasks within a shorter time, which can remarkably boost the applications of MEC in emergency and complicated scenarios. To this end, we make the first attempt to investigate a new multi-UAV enabled MEC system, where multiple UAVs are employed to serve large-scale mobile users on the ground in a given area. To minimize this system's energy consumption while meeting the needs of all mobile users, there exist two key issues to be addressed: the deployment of UAVs and task scheduling. Specifically, the purpose of the deployment of UAVs is to determine the number and locations of UAVs. In addition, task scheduling includes two aspects: the offloading decision and resource allocation. The former aims at deter-mining whether a task is executed locally or is offloaded to a UAV. Subsequently, the latter decides how many resources should be allocated to this task.However, the current study in [10] only considers one UAV. A question which arises naturally is whether we can deploy multiple UAVs simultaneously to serve mobile users. Compared with a single UAV, multiple UAVs can support more tasks within a shorter time, which can remarkably boost the applications of MEC in emergency and complicated scenarios. To this end, we make the first attempt to investigate a new multi-UAV enabled MEC system, where multiple UAVs are employed to serve large-scale mobile users on the ground in a given area. To minimize this system's energy consumption while meeting the needs of all mobile users, there exist two key issues to be addressed: the deployment of UAVs and task scheduling. Specifically, the purpose of the deployment of UAVs is to determine the number and locations of UAVs. In addition, task scheduling includes two aspects: the offloading decision and resource allocation. The former aims at deter-mining whether a task is executed locally or is offloaded to a UAV. Subsequently, the latter decides how many resources should be allocated to this task.</p>
        <p>Actually, the deployment of a single UAV/multiple UAVs and the task scheduling in MEC have been extensively studied individually in wireless communications. Next, we briefly introduce them.Actually, the deployment of a single UAV/multiple UAVs and the task scheduling in MEC have been extensively studied individually in wireless communications. Next, we briefly introduce them.</p>
        <p>• Deployment of a single UAV/multiple UAVs: Fan et al. [11] researched the node placement of a UAV relaying system, with the aim of maximizing the system throughput. Bor-Yaliniz et al. [12] optimized the placement of a UAV to maximize the revenue of the network. Mozaffari et al. [13] designed the efficient deployment of multiple UAVs as wireless base stations, in which the total coverage area and the coverage lifetime of UAVs are maximized. Mozaffari et al. [14] investigated the placement of UAVs for data collection from ground Internet of Things devices. Lyu et al. [15] presented the placement of UAVs to supply distributed ground terminals with wireless coverage, ensuring that each ground terminal can be served by at least one UAV. Sharma et al. [16] introduced the assignment of UAVs over geographical areas to meet high traffic demands. Mozaffari et al. [17] deployed a UAV as a flying base station to provide wireless communications to an area. • Task scheduling: Some researchers have focused on either the offloading decision or the resource allocation in task scheduling of MEC. For example, Zhang et al. [18] proposed an energy-efficient offloading decision mechanism for MEC in 5G heterogeneous networks. Lyu et al. [19] designed a selective offloading decision scheme in MEC to minimize the energy consumption of Internet of Things devices. Wang et al. [20] optimized the resource allocation in MEC by means of a unifying framework for the power-performance tradeoff of a mobile service provider. You et al. [21] investigated the resource allocation for a multiuser MEC system based on time-division multiple access and orthogonal frequency-division multiple access. Recently, much attention has been paid to optimizing the offloading decision and resource allocation in MEC simultaneously. For instance, Mao et al. [22] presented an effective computation offloading strategy for a green MEC system with energy harvesting devices by optimizing the offloading decision and the resource allocation simultaneously. Zhang et al. [23] suggested the simultaneous offloading decision and resource allocation optimization in MEC to minimize the energy consumption and monetary cost from the mobile terminals' perspective. Kan et al. [24] introduced the offloading decision and the resource allocation of the MEC server considering the variety of tasks' requirements.• Deployment of a single UAV/multiple UAVs: Fan et al. [11] researched the node placement of a UAV relaying system, with the aim of maximizing the system throughput. Bor-Yaliniz et al. [12] optimized the placement of a UAV to maximize the revenue of the network. Mozaffari et al. [13] designed the efficient deployment of multiple UAVs as wireless base stations, in which the total coverage area and the coverage lifetime of UAVs are maximized. Mozaffari et al. [14] investigated the placement of UAVs for data collection from ground Internet of Things devices. Lyu et al. [15] presented the placement of UAVs to supply distributed ground terminals with wireless coverage, ensuring that each ground terminal can be served by at least one UAV. Sharma et al. [16] introduced the assignment of UAVs over geographical areas to meet high traffic demands. Mozaffari et al. [17] deployed a UAV as a flying base station to provide wireless communications to an area. • Task scheduling: Some researchers have focused on either the offloading decision or the resource allocation in task scheduling of MEC. For example, Zhang et al. [18] proposed an energy-efficient offloading decision mechanism for MEC in 5G heterogeneous networks. Lyu et al. [19] designed a selective offloading decision scheme in MEC to minimize the energy consumption of Internet of Things devices. Wang et al. [20] optimized the resource allocation in MEC by means of a unifying framework for the power-performance tradeoff of a mobile service provider. You et al. [21] investigated the resource allocation for a multiuser MEC system based on time-division multiple access and orthogonal frequency-division multiple access. Recently, much attention has been paid to optimizing the offloading decision and resource allocation in MEC simultaneously. For instance, Mao et al. [22] presented an effective computation offloading strategy for a green MEC system with energy harvesting devices by optimizing the offloading decision and the resource allocation simultaneously. Zhang et al. [23] suggested the simultaneous offloading decision and resource allocation optimization in MEC to minimize the energy consumption and monetary cost from the mobile terminals' perspective. Kan et al. [24] introduced the offloading decision and the resource allocation of the MEC server considering the variety of tasks' requirements.</p>
        <p>From this introduction, it is clear that the joint optimization of the deployment of UAVs and task scheduling remains scarce in current studies. Moreover, in MEC, large-scale mobile users have rarely been taken into consideration. Due to the fact that the system developed in this paper involves both multi-UAV enabled MEC and mobile users, we must jointly optimize the deployment of UAVs and task scheduling. To the best of our knowledge, this paper is the first attempt to investigate joint deployment and task scheduling optimization for large-scale mobile users in a multi-UAV enabled MEC system. The main contributions of this paper are summarized as follows:From this introduction, it is clear that the joint optimization of the deployment of UAVs and task scheduling remains scarce in current studies. Moreover, in MEC, large-scale mobile users have rarely been taken into consideration. Due to the fact that the system developed in this paper involves both multi-UAV enabled MEC and mobile users, we must jointly optimize the deployment of UAVs and task scheduling. To the best of our knowledge, this paper is the first attempt to investigate joint deployment and task scheduling optimization for large-scale mobile users in a multi-UAV enabled MEC system. The main contributions of this paper are summarized as follows:</p>
        <p>• A new multi-UAV enabled MEC system is proposed, where multiple UAVs are used as flying edge clouds for large-scale mobile users. This system can further develop the capability of traditional MEC systems by using multiple UAVs. • A two-layer optimization method named ToDeTaS is proposed to jointly optimize the deployment of UAVs and task scheduling, with the purpose of minimizing the system energy consumption. Specifically, we optimize four aspects: the number and locations of UAVs, the offloading decision, and the resource allocation. • In the upper layer, a differential evolution (DE) algorithm with an elimination operator is presented to optimize the deployment of UAVs. We encode a UAV's location into an individual and the whole population represents an entire deployment of UAVs. After analyzing this system, to achieve the minimum energy consumption, we should give a priority to the number of UAVs under the condition that all tasks can be completed. Based on this property, we first determine the maximum number of UAVs, and gradually reduce the number by the elimination operator if all tasks can be completed. In principle, the number of UAVs is adaptively adjusted by the elimination operator and the locations of UAVs are optimized by DE. • With respect to a given deployment of UAVs in the upper layer, the task scheduling in the lower layer is transformed into a 0-1 integer programming problem.• A new multi-UAV enabled MEC system is proposed, where multiple UAVs are used as flying edge clouds for large-scale mobile users. This system can further develop the capability of traditional MEC systems by using multiple UAVs. • A two-layer optimization method named ToDeTaS is proposed to jointly optimize the deployment of UAVs and task scheduling, with the purpose of minimizing the system energy consumption. Specifically, we optimize four aspects: the number and locations of UAVs, the offloading decision, and the resource allocation. • In the upper layer, a differential evolution (DE) algorithm with an elimination operator is presented to optimize the deployment of UAVs. We encode a UAV's location into an individual and the whole population represents an entire deployment of UAVs. After analyzing this system, to achieve the minimum energy consumption, we should give a priority to the number of UAVs under the condition that all tasks can be completed. Based on this property, we first determine the maximum number of UAVs, and gradually reduce the number by the elimination operator if all tasks can be completed. In principle, the number of UAVs is adaptively adjusted by the elimination operator and the locations of UAVs are optimized by DE. • With respect to a given deployment of UAVs in the upper layer, the task scheduling in the lower layer is transformed into a 0-1 integer programming problem.</p>
        <p>To reduce the computational time for the large-scale 0-1 integer programming problem, an efficient greedy algorithm is proposed to obtain the near-optimal solution.To reduce the computational time for the large-scale 0-1 integer programming problem, an efficient greedy algorithm is proposed to obtain the near-optimal solution.</p>
        <p>• Extensive experiments have been carried out on ten instances with up to 1000 mobile users. The experimental results demonstrate the effectiveness of ToDeTaS and the multi-UAV enabled MEC system. The rest of this paper is organized as follows. Section II introduces the model and problem formulation of the proposed system. Section III describes the details of our proposed ToDeTaS. Section IV gives the experimental studies. Section V discusses two issues. Finally, Section VI concludes this paper.• Extensive experiments have been carried out on ten instances with up to 1000 mobile users. The experimental results demonstrate the effectiveness of ToDeTaS and the multi-UAV enabled MEC system. The rest of this paper is organized as follows. Section II introduces the model and problem formulation of the proposed system. Section III describes the details of our proposed ToDeTaS. Section IV gives the experimental studies. Section V discusses two issues. Finally, Section VI concludes this paper.</p>
        <p>As shown in Fig. 1, we consider a multi-UAV enabled MEC system consisting of M mobile users denoted as M = {1, 2, . . . , M } and N UAVs denoted as N = {1, 2, . . . , N }. In this system, (x i , y i , 0) is the three-dimensional coordinate of mobile user i (i ∈ M). In addition, we assume that each mobile user i has a task U i to be executed. Specifically, U i can be described as U i = (C i , D i ), where C i describes the total number of the CPU cycles for completing U i , and D i denotes the size of input data of mobile user i. Note that M , x i , y i , C i , and D i can be known a priori. As for N UAVs, we assume that they are equipped with directional antennas of fixed beamwidth θ. These UAVs are flying at a constant altitude H and the location of UAV j (j ∈ N ) is represented by (X j , Y j , H). It is worth noting that N , X j , and Y j cannot be obtained in advance.As shown in Fig. 1, we consider a multi-UAV enabled MEC system consisting of M mobile users denoted as M = {1, 2, . . . , M } and N UAVs denoted as N = {1, 2, . . . , N }. In this system, (x i , y i , 0) is the three-dimensional coordinate of mobile user i (i ∈ M). In addition, we assume that each mobile user i has a task U i to be executed. Specifically, U i can be described as U i = (C i , D i ), where C i describes the total number of the CPU cycles for completing U i , and D i denotes the size of input data of mobile user i. Note that M , x i , y i , C i , and D i can be known a priori. As for N UAVs, we assume that they are equipped with directional antennas of fixed beamwidth θ. These UAVs are flying at a constant altitude H and the location of UAV j (j ∈ N ) is represented by (X j , Y j , H). It is worth noting that N , X j , and Y j cannot be obtained in advance.</p>
        <p>In this system, UAVs are used as flying edge clouds. Therefore, each task can be executed on its own mobile device or one of UAVs. As a result, each task has (N + 1) execution patterns denoted as K = {0, 1, . . . , N }. Specifically, k = 0 (k ∈ K) indicates that a task is executed on its own mobile device and k &gt; 0 indicates that a task is executed on UAV k. Furthermore, we assume that N UAVs serve all mobile users via frequency division multiple access with an equal bandwidth allocation. In this paper, we define matrix a to denote the offloading decision, where a i,k = 1 (i ∈ M and k ∈ K) if U i is executed in pattern k; otherwise, a i,k = 0. For example, in Fig. 1, U 1 , U 2 , and U 4 are executed on UAV 1; U 5 , U 7 , and U 8 are executed on UAV 2; and the rest of the tasks are executed locally. As a result, a 1,1 , a 2,1 , a 4,1 , a 5,2 , a 7,2 , a 8,2 , a 3,0 , a 6,0 , a 9,0 , a 10,0 , and a M,0 = 1, and the rest is equal to zero. In addition, we define another matrix f to denote the resource allocation, where f i,k (i ∈ M and k ∈ K) is the computation resources allocated to U i in pattern k.In this system, UAVs are used as flying edge clouds. Therefore, each task can be executed on its own mobile device or one of UAVs. As a result, each task has (N + 1) execution patterns denoted as K = {0, 1, . . . , N }. Specifically, k = 0 (k ∈ K) indicates that a task is executed on its own mobile device and k &gt; 0 indicates that a task is executed on UAV k. Furthermore, we assume that N UAVs serve all mobile users via frequency division multiple access with an equal bandwidth allocation. In this paper, we define matrix a to denote the offloading decision, where a i,k = 1 (i ∈ M and k ∈ K) if U i is executed in pattern k; otherwise, a i,k = 0. For example, in Fig. 1, U 1 , U 2 , and U 4 are executed on UAV 1; U 5 , U 7 , and U 8 are executed on UAV 2; and the rest of the tasks are executed locally. As a result, a 1,1 , a 2,1 , a 4,1 , a 5,2 , a 7,2 , a 8,2 , a 3,0 , a 6,0 , a 9,0 , a 10,0 , and a M,0 = 1, and the rest is equal to zero. In addition, we define another matrix f to denote the resource allocation, where f i,k (i ∈ M and k ∈ K) is the computation resources allocated to U i in pattern k.</p>
        <p>In our system, there are three models: the local execution model, the MEC execution model, and the UAV hover model.In our system, there are three models: the local execution model, the MEC execution model, and the UAV hover model.</p>
        <p>When U i is executed on its own mobile device, the time spent to complete it is defined as [25] TWhen U i is executed on its own mobile device, the time spent to complete it is defined as [25] T</p>
        <p>In addition, the energy used to complete U i is given as [26]In addition, the energy used to complete U i is given as [26]</p>
        <p>where η 1 is the effective switched capacitance and v is a positive constant.where η 1 is the effective switched capacitance and v is a positive constant.</p>
        <p>When a task is executed on a UAV, this task is first transmitted to the UAV, and then it is executed by the MEC server on the UAV. After execution, the result is returned to the mobile user.When a task is executed on a UAV, this task is first transmitted to the UAV, and then it is executed by the MEC server on the UAV. After execution, the result is returned to the mobile user.</p>
        <p>For mobile user i, its horizontal distance to UAV j is given asFor mobile user i, its horizontal distance to UAV j is given as</p>
        <p>Obviously, if U i is executed on UAV j, mobile user i must be within the coverage area of UAV j. That is, the following constraint should be satisfied [27]:Obviously, if U i is executed on UAV j, mobile user i must be within the coverage area of UAV j. That is, the following constraint should be satisfied [27]:</p>
        <p>where R is the coverage radius of each UAV and R = H tan θ.where R is the coverage radius of each UAV and R = H tan θ.</p>
        <p>The distance between two UAVs is expressed asThe distance between two UAVs is expressed as</p>
        <p>((</p>
        <p>Note that any two UAVs must maintain a minimum distance d U U min to avoid collision; thus, another constraint holds [28] C2 :Note that any two UAVs must maintain a minimum distance d U U min to avoid collision; thus, another constraint holds [28] C2 :</p>
        <p>Due to the computational capability limitations of a MEC server, each UAV can only execute at most n max tasks. That is [29] C3 :Due to the computational capability limitations of a MEC server, each UAV can only execute at most n max tasks. That is [29] C3 :</p>
        <p>The uplink data rate of U i in pattern k is given as [30]The uplink data rate of U i in pattern k is given as [30]</p>
        <p>where B is the channel bandwidth, P denotes the transmission power of each mobile device, β 0 is the channel power gain at the reference distance, G 0 is a positive constant, and N 0 is the noise power spectrum density. Then, the total time for completing U i includes the transmission time and the computation time on UAV j [31]:where B is the channel bandwidth, P denotes the transmission power of each mobile device, β 0 is the channel power gain at the reference distance, G 0 is a positive constant, and N 0 is the noise power spectrum density. Then, the total time for completing U i includes the transmission time and the computation time on UAV j [31]:</p>
        <p>In addition, the total energy used to complete U i includes the transmission energy and the computation energy on UAV j [32]In addition, the total energy used to complete U i includes the transmission energy and the computation energy on UAV j [32]</p>
        <p>where η 2 is the effective switched capacitance. Similar to [29], we assume that the output of the task can be returned to the mobile user with negligible transmission delay.where η 2 is the effective switched capacitance. Similar to [29], we assume that the output of the task can be returned to the mobile user with negligible transmission delay.</p>
        <p>When a UAV hovers at its fixed location for some time, the energy for it to hover is expressed asWhen a UAV hovers at its fixed location for some time, the energy for it to hover is expressed as</p>
        <p>where P 0 and T are the hover power and the hover time, respectively. Considering that this system contains both multi-UAV enabled MEC and mobile users, we need to jointly optimize the deployment of UAVs and the task scheduling to minimize the system energy consumption, which includes the energy to complete all tasks in the local computation patten or the MEC computation patten and the energy for UAVs' hover. The joint deployment and task scheduling optimization problem can be formulated aswhere P 0 and T are the hover power and the hover time, respectively. Considering that this system contains both multi-UAV enabled MEC and mobile users, we need to jointly optimize the deployment of UAVs and the task scheduling to minimize the system energy consumption, which includes the energy to complete all tasks in the local computation patten or the MEC computation patten and the energy for UAVs' hover. The joint deployment and task scheduling optimization problem can be formulated as</p>
        <p>where C4 ensures that all tasks are executed and each task can only be executed in one pattern; C5 and C6 denote that if U i is executed in pattern k, f i,k is greater than 0; otherwise, it is equal to 0; C7 and C8 are delay constraints for each task; and β is a weight coefficient and set to 1 in this paper.where C4 ensures that all tasks are executed and each task can only be executed in one pattern; C5 and C6 denote that if U i is executed in pattern k, f i,k is greater than 0; otherwise, it is equal to 0; C7 and C8 are delay constraints for each task; and β is a weight coefficient and set to 1 in this paper.</p>
        <p>From the introduction in Section II, it is clear that ( 12) is a non-convex nonlinear optimization problem. Therefore, traditional optimization methods cannot solve it. Evolutionary algorithms (EAs) have the potential to address it since they are a kind of population-based heuristic search methods that does not need the gradient information. However, EAs will face the following three issues when solving (12):From the introduction in Section II, it is clear that ( 12) is a non-convex nonlinear optimization problem. Therefore, traditional optimization methods cannot solve it. Evolutionary algorithms (EAs) have the potential to address it since they are a kind of population-based heuristic search methods that does not need the gradient information. However, EAs will face the following three issues when solving (12):</p>
        <p>• In (12), we need to optimize the number of UAVs (N ), the location of UAV j (X j and Y j ), and the offloading decision (a i,k ) and the resource allocation (f i,k ) for mobile user i. Therefore, (2(N +M )+1) decision variables must be optimized. It is evident that the number of decision variables increases with the increase of M and/or N .• In (12), we need to optimize the number of UAVs (N ), the location of UAV j (X j and Y j ), and the offloading decision (a i,k ) and the resource allocation (f i,k ) for mobile user i. Therefore, (2(N +M )+1) decision variables must be optimized. It is evident that the number of decision variables increases with the increase of M and/or N .</p>
        <p>Due to the fact that we consider a large number of mobile users in this paper, obviously, this is a large-scale optimization problem for EAs [33], [34]. For example, if we consider 1000 mobile users and 100 UAVs, the number of decision variables is 2201. • (12) includes an integer decision variable (N ), continuous decision variables (X j , Y j , and f i,k ), and binary decision variables (a i,k ). Thus, it is an optimization problem with mixed decision variables. In the evolutionary computation community, it is a challenging task to solve optimization problems with mixed decision variables [35]. • The deployment of UAVs and task scheduling are closely coupled. On the one hand, the available execution patterns of a task depend on the deployment of UAVs. This is because a task should be located in the coverage area of a UAV if it is expected to be executed on this UAV. On the other hand, for a given deployment of UAVs, its performance cannot be accurately assessed unless the corresponding task scheduling is optimal.Due to the fact that we consider a large number of mobile users in this paper, obviously, this is a large-scale optimization problem for EAs [33], [34]. For example, if we consider 1000 mobile users and 100 UAVs, the number of decision variables is 2201. • (12) includes an integer decision variable (N ), continuous decision variables (X j , Y j , and f i,k ), and binary decision variables (a i,k ). Thus, it is an optimization problem with mixed decision variables. In the evolutionary computation community, it is a challenging task to solve optimization problems with mixed decision variables [35]. • The deployment of UAVs and task scheduling are closely coupled. On the one hand, the available execution patterns of a task depend on the deployment of UAVs. This is because a task should be located in the coverage area of a UAV if it is expected to be executed on this UAV. On the other hand, for a given deployment of UAVs, its performance cannot be accurately assessed unless the corresponding task scheduling is optimal.</p>
        <p>Therefore, it is inefficient to optimize (12) directly by EAs. In this paper, we propose a two-layer optimization method called ToDeTaS, which decomposes ( 12) into a two-layer optimization problem. To be specific, the upper layer optimizes the deployment of UAVs and the lower layer optimizes the task scheduling, respectively. ToDeTaS provides the following technical advantages:Therefore, it is inefficient to optimize (12) directly by EAs. In this paper, we propose a two-layer optimization method called ToDeTaS, which decomposes ( 12) into a two-layer optimization problem. To be specific, the upper layer optimizes the deployment of UAVs and the lower layer optimizes the task scheduling, respectively. ToDeTaS provides the following technical advantages:</p>
        <p>• In the upper layer, the deployment of UAVs originally involves (2N + 1) decision variables. We propose a new encoding mechanism, by which there are only two decision variables in the deployment of UAVs. In addition, in the lower layer, there are originally 2M decision variables. For a given deployment of UAVs, the resource allocation in the task scheduling can be obtained through simple derivations. As a result, there are indeed M decision variables in the lower layer. Therefore, the original large-scale optimization problem is decomposed into two optimization problems that can be solved much easier than the original one because they have fewer decision variables. • In the upper layer, the optimization problem includes an integer decision variable (N in ( 12)) and continuous decision variables (X j and Y j in ( 12)). As analyzed later, the integer decision variable can be removed by our new encoding mechanism. In addition, the optimization problem in the lower layer includes binary decision variables (a i,k in ( 12)) and continuous decision variables (f i,k in ( 12)). Note that the optimal f i,k in ( 12) can be easily obtained without any optimization. Therefore, the original optimization problem with mixed decision variables is divided into an optimization problem with continuous decision variables (X j and Y j in ( 12)) in the upper layer and an optimization problem with binary decision variables (a i,k in ( 12)) in the lower layer. Thus, there do not exist any mixed decision variables in the two-layer optimization problem.• In the upper layer, the deployment of UAVs originally involves (2N + 1) decision variables. We propose a new encoding mechanism, by which there are only two decision variables in the deployment of UAVs. In addition, in the lower layer, there are originally 2M decision variables. For a given deployment of UAVs, the resource allocation in the task scheduling can be obtained through simple derivations. As a result, there are indeed M decision variables in the lower layer. Therefore, the original large-scale optimization problem is decomposed into two optimization problems that can be solved much easier than the original one because they have fewer decision variables. • In the upper layer, the optimization problem includes an integer decision variable (N in ( 12)) and continuous decision variables (X j and Y j in ( 12)). As analyzed later, the integer decision variable can be removed by our new encoding mechanism. In addition, the optimization problem in the lower layer includes binary decision variables (a i,k in ( 12)) and continuous decision variables (f i,k in ( 12)). Note that the optimal f i,k in ( 12) can be easily obtained without any optimization. Therefore, the original optimization problem with mixed decision variables is divided into an optimization problem with continuous decision variables (X j and Y j in ( 12)) in the upper layer and an optimization problem with binary decision variables (a i,k in ( 12)) in the lower layer. Thus, there do not exist any mixed decision variables in the two-layer optimization problem.</p>
        <p>• In 
            <rs type="software">ToDeTaS</rs>, we first generate a deployment in the upper layer. Based on the given deployment, it is easy to determine feasible execution patterns of each task; thus, we can obtain the feasible offloading decision with a higher probability. By optimizing task scheduling in the lower layer, we can accurately assess the performance of the deployment of UAVs. Therefore, the upper layer promotes the feasibility of the lower layer, and the lower layer enhances the accuracy of the performance evaluation of the upper layer. As a result, we achieve the joint deployment and task scheduling optimization. In summary, 
            <rs type="software">ToDeTaS</rs> is able to address the three aforementioned issues and provides a promising way to use EAs to solve (12).
        </p>
        <p>When traditional EAs optimize the deployment of UAVs in the upper layer, each individual is usually an entire deployment. As introduced in Section II, UAV j (j ∈ N ) is represented by (X j , Y j , H), and X j and Y j should be optimized. In addition, the number of UAVs is N . Thus, the length of each individual in traditional EAs is 2N . Due to the fact that the number of UAVs should be optimized during the evolution, N may change from one generation to another generation. Therefore, in traditional EAs, each individual has a variable length. Under this condition, the deployment of UAVs is a variable-length optimization problem. Currently, it is very challenging for EAs to cope with variable-length optimization problems [36].When traditional EAs optimize the deployment of UAVs in the upper layer, each individual is usually an entire deployment. As introduced in Section II, UAV j (j ∈ N ) is represented by (X j , Y j , H), and X j and Y j should be optimized. In addition, the number of UAVs is N . Thus, the length of each individual in traditional EAs is 2N . Due to the fact that the number of UAVs should be optimized during the evolution, N may change from one generation to another generation. Therefore, in traditional EAs, each individual has a variable length. Under this condition, the deployment of UAVs is a variable-length optimization problem. Currently, it is very challenging for EAs to cope with variable-length optimization problems [36].</p>
        <p>We find an interesting phenomenon in the deployment of UAVs: each UAV has two decision variables (i.e., X j and Y j (j ∈ N ) in the x-axis and y-axis), and all elements in {X 1 , . . . , X N } have the same upper and lower bounds, as well as all elements in {Y 1 , . . . , Y N }. Based on this observation and inspired by Wang et al. [37], we propose a new encoding mechanism: the location of each UAV is encoded into an individual and the whole population denotes an entire deployment, as shown in Fig. 2. This encoding mechanism has the following advantages: 1) each individual has a fixed length during the evolution, rather than a variable length, and 2) the length of each individual is equal to two, which means the deployment of UAVs is optimized in a very low-dimensional search space, that is, two.We find an interesting phenomenon in the deployment of UAVs: each UAV has two decision variables (i.e., X j and Y j (j ∈ N ) in the x-axis and y-axis), and all elements in {X 1 , . . . , X N } have the same upper and lower bounds, as well as all elements in {Y 1 , . . . , Y N }. Based on this observation and inspired by Wang et al. [37], we propose a new encoding mechanism: the location of each UAV is encoded into an individual and the whole population denotes an entire deployment, as shown in Fig. 2. This encoding mechanism has the following advantages: 1) each individual has a fixed length during the evolution, rather than a variable length, and 2) the length of each individual is equal to two, which means the deployment of UAVs is optimized in a very low-dimensional search space, that is, two.</p>
        <p>The general framework of ToDeTaS is presented in Algorithm 1. First, we generate an initial population P with N individuals (i.e., an initial deployment of UAVs) by Algorithm Algorithm 1 General Framework of ToDeTaS 1: N = Nmax; // N denotes the number of UAVs and Nmax denotes the maximum number of UAVs; 2: Generate an initial population P with N individuals (i.e., an initial deployment of UAVs) by Algorithm 2; 3: Calculate the offloading decision a and the resource allocation f according to P through Algorithm 5; 4: Evaluate the system energy consumption of {N, P, a, f }; 5: F Es = 1; // F Es denotes the number of fitness evaluations 6: f lag = 0 and num inf = 0; // f lag is the optimization status and num inf denotes the consecutive infeasible number of {N, P, a, f } 7: while F Es &lt; F Esmax do 8:The general framework of ToDeTaS is presented in Algorithm 1. First, we generate an initial population P with N individuals (i.e., an initial deployment of UAVs) by Algorithm Algorithm 1 General Framework of ToDeTaS 1: N = Nmax; // N denotes the number of UAVs and Nmax denotes the maximum number of UAVs; 2: Generate an initial population P with N individuals (i.e., an initial deployment of UAVs) by Algorithm 2; 3: Calculate the offloading decision a and the resource allocation f according to P through Algorithm 5; 4: Evaluate the system energy consumption of {N, P, a, f }; 5: F Es = 1; // F Es denotes the number of fitness evaluations 6: f lag = 0 and num inf = 0; // f lag is the optimization status and num inf denotes the consecutive infeasible number of {N, P, a, f } 7: while F Es &lt; F Esmax do 8:</p>
        <p>while f lag = 0 and {N, P, a, f } is feasible do 9:while f lag = 0 and {N, P, a, f } is feasible do 9:</p>
        <p>{Ntemp, Ptemp, atemp, ftemp} = {N, P, a, f }; 10:{Ntemp, Ptemp, atemp, ftemp} = {N, P, a, f }; 10:</p>
        <p>Perform the elimination operator by Algorithm 3; 11:Perform the elimination operator by Algorithm 3; 11:</p>
        <p>end while 12:end while 12:</p>
        <p>Implement the mutation and crossover operators of DE to produce an offspring population Q; 13: end for 28: end while 29: return {N, P, a, f } 2. Afterward, we calculate the offloading decision a and the resource allocation f according to P by Algorithm 5. Subsequently, we evaluate the system energy consumption of {N, P, a, f }. During the evolution, if {N, P, a, f } is feasible, which means that all tasks can be executed under delay constraints, the elimination operator is implemented in Algorithm 3 to consistently delete one individual until {N, P, a, f } is infeasible. Then, we apply DE to produce an offspring population Q. Each individual in Q is used to update {N, P, a, f } via Algorithm 4. On the one hand, if the updated {N, P, a, f } is infeasible, we will check num inf , which denotes the consecutive infeasible number of {N, P, a, f }. If num inf reaches a predefined threshold value (i.e., 1000 in this paper), which indicates that N cannot be reduced any more, {N, P, a, f } will return to its last feasible status and we will optimize {P, a, f } by DE. On the other hand, if the updated {N, P, a, f } is feasible, we will implement the elimination operator on it. The above process continues until the maximum number of fitness evaluations (F Es max ) is met.Implement the mutation and crossover operators of DE to produce an offspring population Q; 13: end for 28: end while 29: return {N, P, a, f } 2. Afterward, we calculate the offloading decision a and the resource allocation f according to P by Algorithm 5. Subsequently, we evaluate the system energy consumption of {N, P, a, f }. During the evolution, if {N, P, a, f } is feasible, which means that all tasks can be executed under delay constraints, the elimination operator is implemented in Algorithm 3 to consistently delete one individual until {N, P, a, f } is infeasible. Then, we apply DE to produce an offspring population Q. Each individual in Q is used to update {N, P, a, f } via Algorithm 4. On the one hand, if the updated {N, P, a, f } is infeasible, we will check num inf , which denotes the consecutive infeasible number of {N, P, a, f }. If num inf reaches a predefined threshold value (i.e., 1000 in this paper), which indicates that N cannot be reduced any more, {N, P, a, f } will return to its last feasible status and we will optimize {P, a, f } by DE. On the other hand, if the updated {N, P, a, f } is feasible, we will implement the elimination operator on it. The above process continues until the maximum number of fitness evaluations (F Es max ) is met.</p>
        <p>In principle, this paper achieves the joint deployment and task scheduling optimization through optimizing a 4-tuple: {N, P, a, f }. Moreover, once num inf = 1000, the optimal value of N is obtained.In principle, this paper achieves the joint deployment and task scheduling optimization through optimizing a 4-tuple: {N, P, a, f }. Moreover, once num inf = 1000, the optimal value of N is obtained.</p>
        <p>Algorithm 2 introduces the initialization of P, which contains the locations of N UAVs. First, we randomly generate a location for the first UAV and put it into P. After that, we generate a location for the second UAV. If this UAV satisfies C2 in (12), which suggests that the distance between the first and second UAVs is not smaller than d U U min and they will not collide, then we put it into P. Otherwise, the generation of the location of the second UAV is unsuccessful. Under this condition, if the consecutive unsuccessful number is bigger than 200, we restart the initialization; otherwise, the location of the second UAV is regenerated by Step 4. Subsequently, we execute the above process on the third UAV and so forth. Finally, all UAVs' locations are successfully generated and an initial deployment of UAVs is obtained (i.e., P).Algorithm 2 introduces the initialization of P, which contains the locations of N UAVs. First, we randomly generate a location for the first UAV and put it into P. After that, we generate a location for the second UAV. If this UAV satisfies C2 in (12), which suggests that the distance between the first and second UAVs is not smaller than d U U min and they will not collide, then we put it into P. Otherwise, the generation of the location of the second UAV is unsuccessful. Under this condition, if the consecutive unsuccessful number is bigger than 200, we restart the initialization; otherwise, the location of the second UAV is regenerated by Step 4. Subsequently, we execute the above process on the third UAV and so forth. Finally, all UAVs' locations are successfully generated and an initial deployment of UAVs is obtained (i.e., P).</p>
        <p>The aim of the upper layer optimization is to determine the optimal deployment of UAVs, in other words, the optimal number and locations of UAVs. In ToDeTaS, the number of UAVs is equal to the population size of P (i.e., N ). Therefore, the optimization of the number of UAVs is equivalent to the adjustment of N . By analyzing the multi-UAV enabled MEC system proposed in this paper, the following property is obtained.The aim of the upper layer optimization is to determine the optimal deployment of UAVs, in other words, the optimal number and locations of UAVs. In ToDeTaS, the number of UAVs is equal to the population size of P (i.e., N ). Therefore, the optimization of the number of UAVs is equivalent to the adjustment of N . By analyzing the multi-UAV enabled MEC system proposed in this paper, the following property is obtained.</p>
        <p>Property 1: The number of UAVs should be as small as possible under the condition that all tasks can be executed under delay constraints. We analyze the rationality of this property in the Appendix. Based on this property, the population size of P is adjusted as follows: we first set the initial N as the maximum number of UAVs (N max = M/n max ), and then N is gradually decreased by the elimination operator in Algorithm 3 until at least one task cannot be executed under delay constraints. As shown in Algorithm 3, in each time, we only delete one individual from P. A question is which individual should be deleted. In this paper, we consider that the most crowded individual should be deleted. It is because the UAV corresponding to this individual may be redundant, thus adding system energy consumption.Property 1: The number of UAVs should be as small as possible under the condition that all tasks can be executed under delay constraints. We analyze the rationality of this property in the Appendix. Based on this property, the population size of P is adjusted as follows: we first set the initial N as the maximum number of UAVs (N max = M/n max ), and then N is gradually decreased by the elimination operator in Algorithm 3 until at least one task cannot be executed under delay constraints. As shown in Algorithm 3, in each time, we only delete one individual from P. A question is which individual should be deleted. In this paper, we consider that the most crowded individual should be deleted. It is because the UAV corresponding to this individual may be redundant, thus adding system energy consumption.</p>
        <p>The second issue in the upper layer optimization is to determine the optimal locations of UAVs, which is achieved by making use of DE. In this paper, the classical DE version, DE/rand/1/bin [38], is adopted. For the ith individual x i = (x i,1 , x i,2 ) (i ∈ {1, . . . , N }) in P, the mutation and crossover operators of DE/rand/1/bin are introduced in ( 13) and (14), respectively:The second issue in the upper layer optimization is to determine the optimal locations of UAVs, which is achieved by making use of DE. In this paper, the classical DE version, DE/rand/1/bin [38], is adopted. For the ith individual x i = (x i,1 , x i,2 ) (i ∈ {1, . . . , N }) in P, the mutation and crossover operators of DE/rand/1/bin are introduced in ( 13) and (14), respectively:</p>
        <p>where i ∈ {1, . . . , N }; j ∈ {1, 2}; x r1 , x r2 , and x r3 are three mutually distinct individuals randomly selected from P;where i ∈ {1, . . . , N }; j ∈ {1, 2}; x r1 , x r2 , and x r3 are three mutually distinct individuals randomly selected from P;</p>
        <p>) and u i = (u i,1 , u i,2 ) are the mutant vector and the trial vector, respectively; u i,j , v i,j , and x i,j are the jth dimension of u i , v i , and x i , respectively; F is the scaling factor; j rand is an integer randomly selected between 1 and D to ensure that u i is different from x i in at least one dimension; rand j (0, 1) denotes a uniformly distributed random number between 0 and 1 for each j, and CR is the crossover control parameter.) and u i = (u i,1 , u i,2 ) are the mutant vector and the trial vector, respectively; u i,j , v i,j , and x i,j are the jth dimension of u i , v i , and x i , respectively; F is the scaling factor; j rand is an integer randomly selected between 1 and D to ensure that u i is different from x i in at least one dimension; rand j (0, 1) denotes a uniformly distributed random number between 0 and 1 for each j, and CR is the crossover control parameter.</p>
        <p>During the evolution, DE is implemented on P to produce an offspring population Q. Thereafter, each individual in Q is utilized to replace a randomly selected individual in P; thus, P is updated, denoted as R. For R, if it satisfies C2 in (12), we compute the offloading decision a and the resource allocation f . If {N, R, a , f } can execute more tasks under delay constraints than {N, P, a, f }, or if both of them can execute all tasks under delay constraints and the system energy consumption of {N, R, a , f } is less than that of {N, P, a, f }, then {N, P, a, f } is replaced with {N, R, a , f }. The updating operator is given in Algorithm 4.During the evolution, DE is implemented on P to produce an offspring population Q. Thereafter, each individual in Q is utilized to replace a randomly selected individual in P; thus, P is updated, denoted as R. For R, if it satisfies C2 in (12), we compute the offloading decision a and the resource allocation f . If {N, R, a , f } can execute more tasks under delay constraints than {N, P, a, f }, or if both of them can execute all tasks under delay constraints and the system energy consumption of {N, R, a , f } is less than that of {N, P, a, f }, then {N, P, a, f } is replaced with {N, R, a , f }. The updating operator is given in Algorithm 4.</p>
        <p>Regarding Steps 15-22 and Steps 23-26 in Algorithm 1, we would like to give the following remarks:Regarding Steps 15-22 and Steps 23-26 in Algorithm 1, we would like to give the following remarks:</p>
        <p>• Steps 15-22: f lag represents the optimization status.• Steps 15-22: f lag represents the optimization status.</p>
        <p>Specifically, f lag = 0 denotes that the elimination operator can be implemented; instead, f lag = 1 denotes that the elimination operator will not be used any more.Specifically, f lag = 0 denotes that the elimination operator can be implemented; instead, f lag = 1 denotes that the elimination operator will not be used any more.</p>
        <p>If {N, P, a, f } is still infeasible after 1000 consecutive updates, we consider that N cannot be reduced and the optimal number of UAVs has been found (i.e., N + 1). Thus, we let f lag = 1. Under this condition, the followings steps will be applied: {N, P, a, f } returns to its last feasible status, the elimination operator is no longer used, and we continue to take advantage of the updating operator to optimize P, that is, the locations of UAVs. • Steps 23-26: If f lag = 0 and {N, P, a, f } is feasible, the updating operator breaks and the elimination operator is implemented on {N, P, a, f } to further reduce N .If {N, P, a, f } is still infeasible after 1000 consecutive updates, we consider that N cannot be reduced and the optimal number of UAVs has been found (i.e., N + 1). Thus, we let f lag = 1. Under this condition, the followings steps will be applied: {N, P, a, f } returns to its last feasible status, the elimination operator is no longer used, and we continue to take advantage of the updating operator to optimize P, that is, the locations of UAVs. • Steps 23-26: If f lag = 0 and {N, P, a, f } is feasible, the updating operator breaks and the elimination operator is implemented on {N, P, a, f } to further reduce N .</p>
        <p>Overall, in the upper layer optimization, the number of UAVs is optimized by the elimination operator and the locations of UAVs are optimized by the updating operator. Moreover, Steps 15-22 and Steps 23-26 control the switch between the elimination operator and the updating operator.Overall, in the upper layer optimization, the number of UAVs is optimized by the elimination operator and the locations of UAVs are optimized by the updating operator. Moreover, Steps 15-22 and Steps 23-26 control the switch between the elimination operator and the updating operator.</p>
        <p>The lower layer optimization aims to optimize the task scheduling under a given deployment of UAVs, including the offloading decision and the resource allocation. For a given deployment of UAVs, N , X j , Y j (j ∈ N ), and E H are fixed in (12). In addition, this deployment must satisfy C2 in (12) since if it does not satisfy C2, it cannot enter the population as shown in Step 2 of Algorithm 4. Therefore, we only need to focus on a i,k and f i,k (i ∈ M and k ∈ K) in (12). By substituting (2) and (10), which are related to f i,k , to (12), the lower layer optimization problem can be expressed as: It can be seen from ( 15) that the more the computation resources consumed to complete a task under a certain pattern (i.e., f i,k ), the greater the energy consumption (the objective function in (15)). It is because the energy consumption increases monotonously with the increase of f i,k . Therefore, to minimize the energy consumption, f i,k should be as small as possible. However, when U i is executed in pattern k, to ensure that delay constraints C7 and C8 are satisfied, f i,k must not be smaller than a minimum value, which can be calculated based on C7 and C8.The lower layer optimization aims to optimize the task scheduling under a given deployment of UAVs, including the offloading decision and the resource allocation. For a given deployment of UAVs, N , X j , Y j (j ∈ N ), and E H are fixed in (12). In addition, this deployment must satisfy C2 in (12) since if it does not satisfy C2, it cannot enter the population as shown in Step 2 of Algorithm 4. Therefore, we only need to focus on a i,k and f i,k (i ∈ M and k ∈ K) in (12). By substituting (2) and (10), which are related to f i,k , to (12), the lower layer optimization problem can be expressed as: It can be seen from ( 15) that the more the computation resources consumed to complete a task under a certain pattern (i.e., f i,k ), the greater the energy consumption (the objective function in (15)). It is because the energy consumption increases monotonously with the increase of f i,k . Therefore, to minimize the energy consumption, f i,k should be as small as possible. However, when U i is executed in pattern k, to ensure that delay constraints C7 and C8 are satisfied, f i,k must not be smaller than a minimum value, which can be calculated based on C7 and C8.</p>
        <p>Substituting ( 1) and ( 9) to C7 and C8, respectively, one can obtain thatSubstituting ( 1) and ( 9) to C7 and C8, respectively, one can obtain that</p>
        <p>• when U i is executed in pattern 0:• when U i is executed in pattern 0:</p>
        <p>• when U i is executed in pattern k:• when U i is executed in pattern k:</p>
        <p>From ( 16) and ( 17), the minimum computation resources are Ci T and Ci T -From ( 16) and ( 17), the minimum computation resources are Ci T and Ci T -</p>
        <p>, respectively, when U i is executed in pattern 0 and the other patterns. Thus, each element of the optimal resource allocation f can be given as, respectively, when U i is executed in pattern 0 and the other patterns. Thus, each element of the optimal resource allocation f can be given as</p>
        <p>(18) After obtaining the optimal resource allocation, C5, C6, C7, and C8 are satisfied, and then we can rewrite the lower layer optimization problem again by substituting ( 18) to ( 15):(18) After obtaining the optimal resource allocation, C5, C6, C7, and C8 are satisfied, and then we can rewrite the lower layer optimization problem again by substituting ( 18) to ( 15):</p>
        <p>s.t. C1, C3, and C4.s.t. C1, C3, and C4.</p>
        <p>Remark 1: As mentioned in the Appendix, E i,k represents the minimum energy to completeRemark 1: As mentioned in the Appendix, E i,k represents the minimum energy to complete</p>
        <p>As can be seen, we only need to optimize a i,k ; thus, ( 19) is a 0-1 integer programming problem since a i,k = 0 or 1. Although classical mathematical programming methods, such as the branch and bound algorithm [39], can be used to solve (19), they are time-consuming due to the large-scale characteristic in this paper. To this end, we propose a greedy algorithm to efficiently obtain the near-optimal solution of (19).As can be seen, we only need to optimize a i,k ; thus, ( 19) is a 0-1 integer programming problem since a i,k = 0 or 1. Although classical mathematical programming methods, such as the branch and bound algorithm [39], can be used to solve (19), they are time-consuming due to the large-scale characteristic in this paper. To this end, we propose a greedy algorithm to efficiently obtain the near-optimal solution of (19).</p>
        <p>First, we define a candidate pattern set for each task:First, we define a candidate pattern set for each task:</p>
        <p>• This task can be executed in each candidate pattern under delay constraints; • If pattern 0 is one of the candidate patterns, then the energy consumption of any other candidate pattern is less than that of pattern 0.• This task can be executed in each candidate pattern under delay constraints; • If pattern 0 is one of the candidate patterns, then the energy consumption of any other candidate pattern is less than that of pattern 0.</p>
        <p>Subsequently, all tasks are divided into three categories:Subsequently, all tasks are divided into three categories:</p>
        <p>• The tasks' candidate pattern sets only contain pattern 0;• The tasks' candidate pattern sets only contain pattern 0;</p>
        <p>• The tasks' candidate pattern sets do not contain pattern 0; • The tasks' candidate pattern sets contain both pattern 0 and other patterns.• The tasks' candidate pattern sets do not contain pattern 0; • The tasks' candidate pattern sets contain both pattern 0 and other patterns.</p>
        <p>Suppose that there are M 1 , M 2 , and M 3 tasks in the first, second, and third categories, respectively. Then, offloading decision a is expressed in the following, each element of which is initialized to be zero: Algorithm 5 Task Scheduling 1: Calculate f based on the given P; 2: Divide the tasks into three categories. Suppose that the first, second, and third categories have M 1 , M 2 , and M 3 tasks, respectively; 3: Initialize a = 0 in (20); 4: For the tasks in the first category, a 1,0 = • • • = a M 1 ,0 = 1; 5: A = {1, . . . , M 2 }; 6: while A = ∅ do 7:Suppose that there are M 1 , M 2 , and M 3 tasks in the first, second, and third categories, respectively. Then, offloading decision a is expressed in the following, each element of which is initialized to be zero: Algorithm 5 Task Scheduling 1: Calculate f based on the given P; 2: Divide the tasks into three categories. Suppose that the first, second, and third categories have M 1 , M 2 , and M 3 tasks, respectively; 3: Initialize a = 0 in (20); 4: For the tasks in the first category, a 1,0 = • • • = a M 1 ,0 = 1; 5: A = {1, . . . , M 2 }; 6: while A = ∅ do 7:</p>
        <p>Choose the task with the minimum number of candidate patterns in the second category (denoted as the sth task); 8:Choose the task with the minimum number of candidate patterns in the second category (denoted as the sth task); 8:</p>
        <p>Suppose that this task has ns candidate patterns and the corresponding minimum energy consumption of these ns candidate patterns is: E s,1 , . . . , E s,ns ; 9:Suppose that this task has ns candidate patterns and the corresponding minimum energy consumption of these ns candidate patterns is: E s,1 , . . . , E s,ns ; 9:</p>
        <p>The candidate pattern with min(E s,1 , . . . , E s,ns ) is selected, denoted as cs.The candidate pattern with min(E s,1 , . . . , E s,ns ) is selected, denoted as cs.</p>
        <p>a M 1 +s,cs = 1 in a and A = A\{s}; 11:a M 1 +s,cs = 1 in a and A = A\{s}; 11:</p>
        <p>The number of tasks that the csth UAV can serve is reduced by one, and the candidate pattern sets of the rest of the tasks in A are updated; if Us is executed on a UAV then 23:The number of tasks that the csth UAV can serve is reduced by one, and the candidate pattern sets of the rest of the tasks in A are updated; if Us is executed on a UAV then 23:</p>
        <p>The number of tasks that this UAV can serve is reduced by one, and the candidate pattern sets of the rest of the tasks in B are updated; 24:The number of tasks that this UAV can serve is reduced by one, and the candidate pattern sets of the rest of the tasks in B are updated; 24:</p>
        <p>end if 25: end while 26:end if 25: end while 26:</p>
        <p>We give the priorities of these three categories in descending order. The tasks in the first category have the highest priority. This is because they are executed locally (i.e., a 1,0 = • • • = a M1,0 = 1) and do not consume any computation resources from MEC servers on UAVs. Since the tasks in the second category can only be executed on UAVs, we need to give them the second highest priority, with the aim of completing as many tasks as possible. In addition, the tasks in the third category can be executed locally in the worst case. Therefore, they have the lowest priority.We give the priorities of these three categories in descending order. The tasks in the first category have the highest priority. This is because they are executed locally (i.e., a 1,0 = • • • = a M1,0 = 1) and do not consume any computation resources from MEC servers on UAVs. Since the tasks in the second category can only be executed on UAVs, we need to give them the second highest priority, with the aim of completing as many tasks as possible. In addition, the tasks in the third category can be executed locally in the worst case. Therefore, they have the lowest priority.</p>
        <p>Next, we determine the offloading decision for the tasks in the second and third categories.Next, we determine the offloading decision for the tasks in the second and third categories.</p>
        <p>• The offloading decision for the tasks in the second category is given in Steps 5-15 in Algorithm 5. When determining which task to execute, we first select the task with the minimum number of candidate patterns, the aim of which is to complete all tasks with a higher probability.• The offloading decision for the tasks in the second category is given in Steps 5-15 in Algorithm 5. When determining which task to execute, we first select the task with the minimum number of candidate patterns, the aim of which is to complete all tasks with a higher probability.</p>
        <p>Afterward, we choose one of the candidate patterns of this task by considering their minimum energy consumption. • The offloading decision for the tasks in the third category is given in Steps 16-25 in Algorithm 5. When determining which task to execute, we consider the number of candidate patterns and the energy consumption simultaneously. We prefer the tasks with fewer candidate patterns and less energy consumption; thus, all tasks can be completed with the system energy consumption being as little as possible. Remark 2: Only in the second category, some tasks may not be executed under delay constraints. For the other two categories, all tasks can be definitely completed.Afterward, we choose one of the candidate patterns of this task by considering their minimum energy consumption. • The offloading decision for the tasks in the third category is given in Steps 16-25 in Algorithm 5. When determining which task to execute, we consider the number of candidate patterns and the energy consumption simultaneously. We prefer the tasks with fewer candidate patterns and less energy consumption; thus, all tasks can be completed with the system energy consumption being as little as possible. Remark 2: Only in the second category, some tasks may not be executed under delay constraints. For the other two categories, all tasks can be definitely completed.</p>
        <p>Remark 3: In Algorithm 4, it is necessary to compute the number of completed tasks. Note that the number of uncompleted tasks is equal to the number of the remaining tasks in A when Algorithm 5 terminates, that is, the number of rows in a, in which all the elements are zero.Remark 3: In Algorithm 4, it is necessary to compute the number of completed tasks. Note that the number of uncompleted tasks is equal to the number of the remaining tasks in A when Algorithm 5 terminates, that is, the number of rows in a, in which all the elements are zero.</p>
        <p>The proposed ToDeTaS has the following characteristics:The proposed ToDeTaS has the following characteristics:</p>
        <p>• This paper optimizes a 4-tuple: {N, P, a, f } to minimize the energy consumption of the proposed multi-UAV enabled MEC system; • By mining the specific-knowledge of this system, we propose a new encoding mechanism and adaptively adjust population size N (i.e., the number of UAVs); • DE serves as the search engine to optimize P, that is, the locations of UAVs; • By exploiting the correlation between the upper layer and the lower layer, for a given deployment of UAVs in the • This paper is the first attempt to establish a multi-UAV enabled MEC system to serve large-scale mobile users. • An optimization problem is formulated to jointly optimize the deployment of UAVs and the task scheduling. The main challenges of this optimization problem are twofold: large-scale mixed decision variables and strong coupling between the deployment of UAVs and the task scheduling.• This paper optimizes a 4-tuple: {N, P, a, f } to minimize the energy consumption of the proposed multi-UAV enabled MEC system; • By mining the specific-knowledge of this system, we propose a new encoding mechanism and adaptively adjust population size N (i.e., the number of UAVs); • DE serves as the search engine to optimize P, that is, the locations of UAVs; • By exploiting the correlation between the upper layer and the lower layer, for a given deployment of UAVs in the • This paper is the first attempt to establish a multi-UAV enabled MEC system to serve large-scale mobile users. • An optimization problem is formulated to jointly optimize the deployment of UAVs and the task scheduling. The main challenges of this optimization problem are twofold: large-scale mixed decision variables and strong coupling between the deployment of UAVs and the task scheduling.</p>
        <p>
            <rs type="software">ToDeTaS</rs>. The two-layer structure is able to deal with large-scale decision variables and strong coupling between the deployment of UAVs and the task scheduling. Moreover, in the upper layer, an integer decision variable (i.e., the number of UAVs) and continuous decision variables (i.e., the locations of UAVs) are handled by a new encoding mechanism and an elimination operator, and in the lower layer, binary decision variables (i.e., offloading decision of each mobile user) and continuous decision variables (i.e., resource allocation of each mobile user) are tackled by an efficient greedy algorithm. Therefore, 
            <rs type="software">ToDeTaS</rs> can also address the challenge caused by mixed decision variables.
        </p>
        <p>The parameter settings of the proposed multi-UAV enabled MEC system are given in Table I [30], [40], [41]. In addition, we applied ten instances with different numbers of mobile users to study the performance of ToDeTaS: M = 100, 200, . . . , 1000. We assumed that all mobile users were distributed in square areas with different side lengths, as shown in Table II.The parameter settings of the proposed multi-UAV enabled MEC system are given in Table I [30], [40], [41]. In addition, we applied ten instances with different numbers of mobile users to study the performance of ToDeTaS: M = 100, 200, . . . , 1000. We assumed that all mobile users were distributed in square areas with different side lengths, as shown in Table II.</p>
        <p>The proposed ToDeTaS includes two parameters, which were set as follows: F = 0.9 and CR = 0.9. The maximum number of fitness evaluations (F Es max ) was set to 10,000 and 30 independent runs were implemented on 
            <rs type="software">ToDeTaS</rs>.
        </p>
        <p>In order to compare the performance of different algorithms, three performance indicators were employed:In order to compare the performance of different algorithms, three performance indicators were employed:</p>
        <p>• The first performance indicator was the average number of completed tasks and the standard deviation over 30 independent runs (denoted as 'Mean NC' and 'Std Dev'). • The second performance indicator was the success rate (denoted as SR), which means the percentage of successful runs over 30 independent runs. A run is successful if all tasks can be completed when an algorithm ends. • If SR of an algorithm is equal to 100%, then we compute the system energy consumption via (12) (denoted as EC). Thus, the third performance indicator was the average system energy consumption (i.e.,• The first performance indicator was the average number of completed tasks and the standard deviation over 30 independent runs (denoted as 'Mean NC' and 'Std Dev'). • The second performance indicator was the success rate (denoted as SR), which means the percentage of successful runs over 30 independent runs. A run is successful if all tasks can be completed when an algorithm ends. • If SR of an algorithm is equal to 100%, then we compute the system energy consumption via (12) (denoted as EC). Thus, the third performance indicator was the average system energy consumption (i.e.,</p>
        <p>EC i , where EC i represents the system energy consumption of the ith independent run) and the standard deviation over 30 independent runs (denoted as 'Mean EC' and 'Std Dev').EC i , where EC i represents the system energy consumption of the ith independent run) and the standard deviation over 30 independent runs (denoted as 'Mean EC' and 'Std Dev').</p>
        <p>We handle the joint deployment and task scheduling optimization by two-layer optimization. Moreover, we optimize the deployment of UAVs and task scheduling in the upper and lower layers, respectively. To verify the effectiveness of the two-layer optimization, we solved ( 12) by a single-layer optimization method proposed in [42]. The method in [42] is designed to solve optimization problems with a variable number of dimensions, in which different individuals in the population have different lengths, and the length of each individual is updated according to a probability-based way. As pointed out in Section III-B, the deployment of UAVs is a variable-length optimization problem due to the fact that the optimal number of UAVs is unknown. Therefore, the method in [42] was chosen to solve (12) as a single-layer optimization method in this paper. Note that we made a simple revision to this method by replacing particle swarm optimization with DE as the search engine. The resultant method was named DE-VND. In DE-VND, each initial individual included a deployment of UAVs as well as task scheduling, both of them were randomly generated. In addition, we designed a two-layer version of DE-VND, named ToDE-VND. In ToDE-VND, the deployment of UAVs in the upper layer was the same with DE-VND; however, the task scheduling in the lower layer was the same with ToDeTaS.We handle the joint deployment and task scheduling optimization by two-layer optimization. Moreover, we optimize the deployment of UAVs and task scheduling in the upper and lower layers, respectively. To verify the effectiveness of the two-layer optimization, we solved ( 12) by a single-layer optimization method proposed in [42]. The method in [42] is designed to solve optimization problems with a variable number of dimensions, in which different individuals in the population have different lengths, and the length of each individual is updated according to a probability-based way. As pointed out in Section III-B, the deployment of UAVs is a variable-length optimization problem due to the fact that the optimal number of UAVs is unknown. Therefore, the method in [42] was chosen to solve (12) as a single-layer optimization method in this paper. Note that we made a simple revision to this method by replacing particle swarm optimization with DE as the search engine. The resultant method was named DE-VND. In DE-VND, each initial individual included a deployment of UAVs as well as task scheduling, both of them were randomly generated. In addition, we designed a two-layer version of DE-VND, named ToDE-VND. In ToDE-VND, the deployment of UAVs in the upper layer was the same with DE-VND; however, the task scheduling in the lower layer was the same with ToDeTaS.</p>
        <p>The performance of DE-VND was compared with that of ToDE-VND on the ten instances. In the experiments, DE-VND and ToDE-VND had the same parameter settings: the population size was set to 100, the probabilities p 1 to x i , p 2 to x r1 , p 3 to x r2 , and p 4 to x r3 were set to 0.25, 0.25, 0.25 and 0.25, respectively, F = 0.9, CR = 0.9, F Es max = 10, 000, and 30 independent runs were implemented. The experimental results in terms of mean NC and SR are summarized in Table III.The performance of DE-VND was compared with that of ToDE-VND on the ten instances. In the experiments, DE-VND and ToDE-VND had the same parameter settings: the population size was set to 100, the probabilities p 1 to x i , p 2 to x r1 , p 3 to x r2 , and p 4 to x r3 were set to 0.25, 0.25, 0.25 and 0.25, respectively, F = 0.9, CR = 0.9, F Es max = 10, 000, and 30 independent runs were implemented. The experimental results in terms of mean NC and SR are summarized in Table III.</p>
        <p>From Table III, as far as the mean NC is concerned, ToDE-VND is significantly better than DE-VND on all instances. In addition, ToDE-VDE provides higher SR than DE-VND from M = 100 to 700. Moreover, when M = 100, 200, and 300, ToDE-VND achieves 100% SR. The superiority of ToDE-VND against DE-VND can be attributed to two aspects: 1) by the two-layer optimization, ( 12) is decomposed into two optimization problems in the upper and lower layers with fewer numbers of decision variables, and 2) in ToDE-VND, the lower layer is generated based on the upper layer, which in turn enhances the accuracy of the evaluation of the upper layer; thus, the correlation between the upper and lower layers has been considered. However, in DE-VND, the deployment of UAVs and task scheduling are optimized independently. In this case, on the one hand, for a given deployment of UAVs, the probability that all tasks can be completed in the task scheduling remarkably decreases. On the other hand, we cannot provide an accurate evaluation of the deployment of UAVs based on the corresponding task scheduling. The aforementioned discussion verifies the effectiveness of the two-layer optimization, which is the main motivation of this paper.From Table III, as far as the mean NC is concerned, ToDE-VND is significantly better than DE-VND on all instances. In addition, ToDE-VDE provides higher SR than DE-VND from M = 100 to 700. Moreover, when M = 100, 200, and 300, ToDE-VND achieves 100% SR. The superiority of ToDE-VND against DE-VND can be attributed to two aspects: 1) by the two-layer optimization, ( 12) is decomposed into two optimization problems in the upper and lower layers with fewer numbers of decision variables, and 2) in ToDE-VND, the lower layer is generated based on the upper layer, which in turn enhances the accuracy of the evaluation of the upper layer; thus, the correlation between the upper and lower layers has been considered. However, in DE-VND, the deployment of UAVs and task scheduling are optimized independently. In this case, on the one hand, for a given deployment of UAVs, the probability that all tasks can be completed in the task scheduling remarkably decreases. On the other hand, we cannot provide an accurate evaluation of the deployment of UAVs based on the corresponding task scheduling. The aforementioned discussion verifies the effectiveness of the two-layer optimization, which is the main motivation of this paper.</p>
        <p>The difference between ToDE-VND and ToDeTaS is the upper layer optimization. To be specific, ToDE-VND and ToDeTaS have different encoding mechanisms and different ways to deal with the variable-length optimization problem in (12). Hence, by comparing ToDE-VND with ToDeTaS, we can study the effectiveness of the upper layer optimization. It can be seen from Section IV-B that ToDE-VND and ToDeTaS have the same parameter settings.The difference between ToDE-VND and ToDeTaS is the upper layer optimization. To be specific, ToDE-VND and ToDeTaS have different encoding mechanisms and different ways to deal with the variable-length optimization problem in (12). Hence, by comparing ToDE-VND with ToDeTaS, we can study the effectiveness of the upper layer optimization. It can be seen from Section IV-B that ToDE-VND and ToDeTaS have the same parameter settings.</p>
        <p>Table IV reports the experimental results derived from ToDE-VND and ToDeTaS in terms of mean NC, SR, and mean EC. When M = 100, 200, and 300, both ToDE-VND and ToDeTaS can complete all tasks and provide 100% SR. Under this condition, we compared their mean EC. It is clear that the mean EC values resulting from ToDeTaS are significantly smaller than those of ToDE-VND. In addition, for the remaining instances, ToDeTaS succeeds in completing all tasks consistently. In contrast, ToDE-VND's SR is smaller than 100% on each instance. More importantly, ToDE-VND fails to complete all tasks in each run for the instances with a larger number of mobile users, i.e., M = 800, 900, and 1000. The reason why ToDeTaS performs better than ToDE-VND is straightforward: the former searches for the optimal deployment of UAVs in the search space with a much lower dimension compared with the latter. Moreover, ToDeTaS encodes the location of a UAV into an individual, thus transforming a variable-length optimization problem into a fixed-length one. It is noteworthy that ToDeTaS adopts an elimination operator to adaptively adjust the population size. As a result, an important parameter, i.e., the population size, has been eliminated. Fig. 3 plots the evolution of the mean EC and the mean number of uncompleted tasks (denoted as 'mean NU') provided by ToDeTaS over 30 independent runs on the ten instances. As shown in Fig. 3, ToDeTaS can consistently complete all tasks and converge after 5000 fitness evaluations.Table IV reports the experimental results derived from ToDE-VND and ToDeTaS in terms of mean NC, SR, and mean EC. When M = 100, 200, and 300, both ToDE-VND and ToDeTaS can complete all tasks and provide 100% SR. Under this condition, we compared their mean EC. It is clear that the mean EC values resulting from ToDeTaS are significantly smaller than those of ToDE-VND. In addition, for the remaining instances, ToDeTaS succeeds in completing all tasks consistently. In contrast, ToDE-VND's SR is smaller than 100% on each instance. More importantly, ToDE-VND fails to complete all tasks in each run for the instances with a larger number of mobile users, i.e., M = 800, 900, and 1000. The reason why ToDeTaS performs better than ToDE-VND is straightforward: the former searches for the optimal deployment of UAVs in the search space with a much lower dimension compared with the latter. Moreover, ToDeTaS encodes the location of a UAV into an individual, thus transforming a variable-length optimization problem into a fixed-length one. It is noteworthy that ToDeTaS adopts an elimination operator to adaptively adjust the population size. As a result, an important parameter, i.e., the population size, has been eliminated. Fig. 3 plots the evolution of the mean EC and the mean number of uncompleted tasks (denoted as 'mean NU') provided by ToDeTaS over 30 independent runs on the ten instances. As shown in Fig. 3, ToDeTaS can consistently complete all tasks and converge after 5000 fitness evaluations.</p>
        <p>The lower layer optimization involves the offloading decision and resource allocation. Although in ToDeTaS, the resource allocation can be determined by simple mathematical derivations, the offloading decision is still a large-scale 0-1 integer programming problem due to a large number of mobile users in this paper. To reduce the computational time complexity, we propose a greedy algorithm to solve this problem. One may be interested in the performance difference between our greedy algorithm and other classical mathematical programming methods. To this end, we designed a variant of ToDeTaS, named ToDeTaS-BB, in which the offloading decision was solved by the branch and bound algorithm [39]. We implemented the branch and bound algorithm via the 
            <rs type="software">Matlab</rs> toolbox.
        </p>
        <p>The experimental results of ToDeTaS and ToDeTaS-BB are presented in Table V in terms of mean EC and mean runtime. We can observe from Table V that from M = 300 to 1000, overall, ToDeTaS-BB provides slightly less mean EC than ToDeTaS. It is largely because the branch and bound algorithm can generate a better offloading decision than the greedy algorithm and improve the accuracy of evaluation for the upper layer. It is interesting to note that ToDeTaS is better than ToDeTaS-BB in terms of the mean EC for a small number of mobile users, that is, M = 100 and 200. This phenomenon is not difficult to understand since for a small number of mobile users, the greedy algorithm is able to generate a highquality offloading decision. In addition, the branch and bound algorithm cannot guarantee the absolute optimal offloading decision in the 
            <rs type="software">Matlab</rs> toolbox.
        </p>
        <p>With respect to the mean runtime, it is obvious that ToDe-TaS performs much faster than ToDeTaS-BB. In this paper, we defined the mean accelerator rate (MAR) of ToDeTaS against ToDeTaS-BB:With respect to the mean runtime, it is obvious that ToDe-TaS performs much faster than ToDeTaS-BB. In this paper, we defined the mean accelerator rate (MAR) of ToDeTaS against ToDeTaS-BB:</p>
        <p>where T 1 i and T 2 i represent the runtime of ToDeTaS-BB and ToDeTaS on the ith instance, respectively. As shown in Table V, ToDeTaS is on average 13.22 times more efficient than its competitor. After a task is executed, the computational time complexity of the greedy algorithm in Algorithm 5 depends mainly on updating the candidate pattern sets of the rest of the tasks in Steps 11 and 23, which requires M N judgements in the worst case. Due to the fact that there are M tasks, the computational time complexity of the greedy algorithm is O(M 2 N ) in the worst case. In contrast, the computational time complexity of the branch and bound algorithm is O((N + 1) M ). Therefore, we can conclude that the greedy algorithm can efficiently optimize the offloading decision with only a slight sacrifice of the system energy consumption, compared with the branch and bound algorithm.where T 1 i and T 2 i represent the runtime of ToDeTaS-BB and ToDeTaS on the ith instance, respectively. As shown in Table V, ToDeTaS is on average 13.22 times more efficient than its competitor. After a task is executed, the computational time complexity of the greedy algorithm in Algorithm 5 depends mainly on updating the candidate pattern sets of the rest of the tasks in Steps 11 and 23, which requires M N judgements in the worst case. Due to the fact that there are M tasks, the computational time complexity of the greedy algorithm is O(M 2 N ) in the worst case. In contrast, the computational time complexity of the branch and bound algorithm is O((N + 1) M ). Therefore, we can conclude that the greedy algorithm can efficiently optimize the offloading decision with only a slight sacrifice of the system energy consumption, compared with the branch and bound algorithm.</p>
        <p>Finally, we compared two algorithms-ToDeTaS-L and ToDeTaS-M-with ToDeTaS to verify the effectiveness of our multi-UAV enabled MEC system. For ToDeTaS-L and ToDeTaS-M, all tasks can only be executed locally and on UAVs, respectively. However, for ToDeTaS, a task can be executed locally or on a UAV.Finally, we compared two algorithms-ToDeTaS-L and ToDeTaS-M-with ToDeTaS to verify the effectiveness of our multi-UAV enabled MEC system. For ToDeTaS-L and ToDeTaS-M, all tasks can only be executed locally and on UAVs, respectively. However, for ToDeTaS, a task can be executed locally or on a UAV.</p>
        <p>Table VI shows the experimental results of ToDeTaS-L, ToDeTaS-M, and ToDeTaS in terms of mean NC over 30 independent runs. As depicted in Table VI, both ToDeTaS-L and ToDeTaS-M cannot successfully complete all tasks on any instance. However, ToDeTaS has the capability to complete all tasks on all ten instances. The poor performance of ToDeTaS-L and ToDeTaS-M can be explained as follows. For ToDeTaS-L, if a mobile device cannot complete its task due to the lack of enough computational resources, then ToDeTaS-L will fail. In addition, for ToDeTaS-M, due to the nonuniform distribution of mobile users, some tasks may not be covered by any UAV; thus, ToDeTaS-M may fail. In principle, ToDeTaS can alleviate the limitations of these two algorithms.Table VI shows the experimental results of ToDeTaS-L, ToDeTaS-M, and ToDeTaS in terms of mean NC over 30 independent runs. As depicted in Table VI, both ToDeTaS-L and ToDeTaS-M cannot successfully complete all tasks on any instance. However, ToDeTaS has the capability to complete all tasks on all ten instances. The poor performance of ToDeTaS-L and ToDeTaS-M can be explained as follows. For ToDeTaS-L, if a mobile device cannot complete its task due to the lack of enough computational resources, then ToDeTaS-L will fail. In addition, for ToDeTaS-M, due to the nonuniform distribution of mobile users, some tasks may not be covered by any UAV; thus, ToDeTaS-M may fail. In principle, ToDeTaS can alleviate the limitations of these two algorithms.</p>
        <p>Note that the mean NC values provided by ToDeTaS-M are close to those of ToDeTaS in Table VI. In order to further identify the performance difference, we compared the mean number of UAVs (i.e., mean N ) of ToDeTaS-M and ToDeTaS on the ten instances. Fig. 4 shows the experimental results. From Fig. 4, ToDeTaS is able to complete all tasks while requiring considerably fewer UAVs than ToDeTaS-M on each instance. This is because about 40% of the tasks can be executed locally under delay constraints according to the parameter settings in Table I. Therefore, ToDeTaS is capable of reducing about 40% of UAVs compared with ToDeTaS-M. This comparison confirms the effectiveness of our multi-UAV enabled MEC system.Note that the mean NC values provided by ToDeTaS-M are close to those of ToDeTaS in Table VI. In order to further identify the performance difference, we compared the mean number of UAVs (i.e., mean N ) of ToDeTaS-M and ToDeTaS on the ten instances. Fig. 4 shows the experimental results. From Fig. 4, ToDeTaS is able to complete all tasks while requiring considerably fewer UAVs than ToDeTaS-M on each instance. This is because about 40% of the tasks can be executed locally under delay constraints according to the parameter settings in Table I. Therefore, ToDeTaS is capable of reducing about 40% of UAVs compared with ToDeTaS-M. This comparison confirms the effectiveness of our multi-UAV enabled MEC system.</p>
        <p>A. On Hyper-Heuristic Approaches for the Task Scheduling in the Lower Layer One may be interested in whether hyper-heuristic approaches (e.g., genetic programming and particle swarm optimization) can work better for the task scheduling in the lower layer. There is no doubt that hyper-heuristic approaches are able to solve the task scheduling in the lower layer and may even obtain a better solution than our greedy algorithm. However, the computational time complexity of a hyperheuristic approach is significantly higher than that of our greedy algorithm. This is because a hyper-heuristic approach searches for the optimal solution via an iterative way. In this paper, we adopted a two-layer optimization method. Obviously, if the computational time complexity of the lower layer optimization method is high, it is impossible to apply the two-layer optimization method in the large-scale scenarios. Moreover, as can be seen from the experimental studies in Section IV, our greedy algorithm exhibits good performance. Overall, by considering the tradeoff between computational time complexity and accuracy, we made use of a greedy algorithm to optimize the task scheduling in the lower layer.A. On Hyper-Heuristic Approaches for the Task Scheduling in the Lower Layer One may be interested in whether hyper-heuristic approaches (e.g., genetic programming and particle swarm optimization) can work better for the task scheduling in the lower layer. There is no doubt that hyper-heuristic approaches are able to solve the task scheduling in the lower layer and may even obtain a better solution than our greedy algorithm. However, the computational time complexity of a hyperheuristic approach is significantly higher than that of our greedy algorithm. This is because a hyper-heuristic approach searches for the optimal solution via an iterative way. In this paper, we adopted a two-layer optimization method. Obviously, if the computational time complexity of the lower layer optimization method is high, it is impossible to apply the two-layer optimization method in the large-scale scenarios. Moreover, as can be seen from the experimental studies in Section IV, our greedy algorithm exhibits good performance. Overall, by considering the tradeoff between computational time complexity and accuracy, we made use of a greedy algorithm to optimize the task scheduling in the lower layer.</p>
        <p>Although we only consider the static environment in this paper, a dynamic environment can also be applied to our system. We will explain this from the following two aspects.Although we only consider the static environment in this paper, a dynamic environment can also be applied to our system. We will explain this from the following two aspects.</p>
        <p>• If x i , y i , C i , and D i (i ∈ M) change in different time slots, then we can use ToDeTaS to jointly re-optimize the deployment of UAVs and the task scheduling in each time slot. • If x i , y i , C i , and D i change within a time slot, then we can tighten the delay constraints (i.e., C7 and C8 in ( 12)) to make the task executed in the time duration less than T .• If x i , y i , C i , and D i (i ∈ M) change in different time slots, then we can use ToDeTaS to jointly re-optimize the deployment of UAVs and the task scheduling in each time slot. • If x i , y i , C i , and D i change within a time slot, then we can tighten the delay constraints (i.e., C7 and C8 in ( 12)) to make the task executed in the time duration less than T .</p>
        <p>This paper proposed a new multi-UAV enabled MEC system to enhance the performance of traditional MEC systems by making use of multiple UAVs. In this system, it is necessary to jointly optimize the deployment of UAVs and task scheduling. When EAs are employed to solve this joint optimization problem, they face two issues: large-scale search space and mixed decision variables. Moreover, they usually ignore the correlation between the deployment of UAVs and task scheduling. In this paper, we proposed a two-layer optimization method, called 
            <rs type="software">ToDeTaS</rs>, which considered the deployment of UAVs as the upper layer optimization problem and the task scheduling as the lower layer optimization problem. For the upper layer optimization, a new encoding mechanism was suggested, which encoded the location of a UAV into an individual; thus, the whole population represented an entire deployment and the number of UAVs was equal to the population size. Then, DE served as the search engine and an elimination operator was designed to adaptively tune the population size. In the lower layer optimization, for a given deployment of UAVs, we first determined the resource allocation, and then optimized the offloading decision by a greedy algorithm.
        </p>
        <p>Overall, ToDeTaS has the following three advantages:Overall, ToDeTaS has the following three advantages:</p>
        <p>• Compared with the original joint optimization problem, the optimization problems in the upper and lower layers have fewer decision variables, therefore reducing the dimension of the search space. • ToDeTaS avoids mixed decision variables by the new encoding mechanism, the elimination operator, and the derivation of resource allocation. • The correlation between the deployment of UAVs and the task scheduling is fully taken into consideration. Specifically, the upper layer make the lower layer more likely to complete all tasks, and the lower layer improves the accuracy of the evaluation of the upper layer. The performance of ToDeTaS was investigated by ten instances with up to 1000 mobile users. We also demonstrated the effectiveness of the two-layer optimization and the proposed system by various performance indicators.• Compared with the original joint optimization problem, the optimization problems in the upper and lower layers have fewer decision variables, therefore reducing the dimension of the search space. • ToDeTaS avoids mixed decision variables by the new encoding mechanism, the elimination operator, and the derivation of resource allocation. • The correlation between the deployment of UAVs and the task scheduling is fully taken into consideration. Specifically, the upper layer make the lower layer more likely to complete all tasks, and the lower layer improves the accuracy of the evaluation of the upper layer. The performance of ToDeTaS was investigated by ten instances with up to 1000 mobile users. We also demonstrated the effectiveness of the two-layer optimization and the proposed system by various performance indicators.</p>
        <p>Suppose that the minimum energy to execute U i (i ∈ M) under its delay constraints in pattern k (k ∈ K) is E i,k . Note that E i,k may change with different deployments of UAVs. We are interested in identifying the maximum energy improvement for U i in different deployments of UAVs, denoted as ∆E i . If U i can be executed locally and if the minimum energy to complete U i can be improved by offloading it to a UAV, then the maximum energy improvement should be less than E i,0 , that is, ∆E i &lt; E i,0 = η 1 (f i,0 ) v-1 C i , where f i,0 is defined in (18). In addition, if U i cannot be executed locally, then suppose that it is executed on UAV j. When mobile user i has the shortest distance with UAV j (i.e., mobile user i is located directly below UAV j), we can obtain the ideal minimum energy to complete U i : E i,k,min = P Di r i,k,max + η 2 (f i,k ) v-1 C i (k = j), where r i,k,max represents the maximum uplink data rate and is equal to Blog 2 1 + P β0G0 N0Bθ 2 ((d M U i,j,min ) 2 +H 2 ) , f i,k is defined in (18), and d M U i,j,min = 0. On the other hand, when mobile user i has the longest distance with UAV j (i.e., mobile user i is located on the boundary of the area covered by UAV j), we can obtain the ideal maximum energy to complete U i : E i,k,max = P Di r i,kmin + η 2 (f i,k ) v-1 C i (k = j), where r i,k,min represents the minimum uplink data rate and is equal to Blog 2 1 + P β0G0 N0Bθ 2 ((d M U i,j,max ) 2 +H 2 ) and d M U i,j,max = H tan θ. Therefore, under this condition, ∆E i = E i,k,max -E i,k,min (k = j).Suppose that the minimum energy to execute U i (i ∈ M) under its delay constraints in pattern k (k ∈ K) is E i,k . Note that E i,k may change with different deployments of UAVs. We are interested in identifying the maximum energy improvement for U i in different deployments of UAVs, denoted as ∆E i . If U i can be executed locally and if the minimum energy to complete U i can be improved by offloading it to a UAV, then the maximum energy improvement should be less than E i,0 , that is, ∆E i &lt; E i,0 = η 1 (f i,0 ) v-1 C i , where f i,0 is defined in (18). In addition, if U i cannot be executed locally, then suppose that it is executed on UAV j. When mobile user i has the shortest distance with UAV j (i.e., mobile user i is located directly below UAV j), we can obtain the ideal minimum energy to complete U i : E i,k,min = P Di r i,k,max + η 2 (f i,k ) v-1 C i (k = j), where r i,k,max represents the maximum uplink data rate and is equal to Blog 2 1 + P β0G0 N0Bθ 2 ((d M U i,j,min ) 2 +H 2 ) , f i,k is defined in (18), and d M U i,j,min = 0. On the other hand, when mobile user i has the longest distance with UAV j (i.e., mobile user i is located on the boundary of the area covered by UAV j), we can obtain the ideal maximum energy to complete U i : E i,k,max = P Di r i,kmin + η 2 (f i,k ) v-1 C i (k = j), where r i,k,min represents the minimum uplink data rate and is equal to Blog 2 1 + P β0G0 N0Bθ 2 ((d M U i,j,max ) 2 +H 2 ) and d M U i,j,max = H tan θ. Therefore, under this condition, ∆E i = E i,k,max -E i,k,min (k = j).</p>
        <p>According to the parameter settings in Table I, we can derive that M i=1 ∆E i &lt; E H , which means that the maximum energy improvement of all tasks in different deployments of UAVs is less than the energy to hover a UAV. That is, although adding a UAV can reduce the energy to complete all tasks (i.e., the first term of the objective function of ( 12)), the total system energy consumption (i.e., the objective function of ( 12)) will definitely add. Therefore, if all tasks can be executed under delay constraints, we should use as few UAVs as possible, which is property 1.According to the parameter settings in Table I, we can derive that M i=1 ∆E i &lt; E H , which means that the maximum energy improvement of all tasks in different deployments of UAVs is less than the energy to hover a UAV. That is, although adding a UAV can reduce the energy to complete all tasks (i.e., the first term of the objective function of ( 12)), the total system energy consumption (i.e., the objective function of ( 12)) will definitely add. Therefore, if all tasks can be executed under delay constraints, we should use as few UAVs as possible, which is property 1.</p>
        <p>Under this condition, both Steps 8-11 (i.e., the elimination operator) and Steps 15-26 are unnecessary, and we only concentrate on the optimization of {P, a, f } by DE (i.e., Steps 12-14 and Step 27).Under this condition, both Steps 8-11 (i.e., the elimination operator) and Steps 15-26 are unnecessary, and we only concentrate on the optimization of {P, a, f } by DE (i.e., Steps 12-14 and Step 27).</p>
        <p>It is noteworthy that the deployment of UAVs in the upperIt is noteworthy that the deployment of UAVs in the upper</p>
        <p>••</p>
        <p>a1,0 a1,1 • • • a1,N . . . . . . . . . . . . aM 1 ,0 aM 1 ,1 • • • aM 1 ,N aM 1 +1,0 aM 1 +1,1 • • • aM 1 +1,N . . . . . . . . . . . . aM 1 +M 2 ,0 aM 1 +M 2 ,1 • • • aM 1 +M 2 ,N aM 1 +M 2 +1,0 aM 1 +M 2 +1,1 • • • aM 1 +M 2 +1,N . . . . . . . . . . . .a1,0 a1,1 • • • a1,N . . . . . . . . . . . . aM 1 ,0 aM 1 ,1 • • • aM 1 ,N aM 1 +1,0 aM 1 +1,1 • • • aM 1 +1,N . . . . . . . . . . . . aM 1 +M 2 ,0 aM 1 +M 2 ,1 • • • aM 1 +M 2 ,N aM 1 +M 2 +1,0 aM 1 +M 2 +1,1 • • • aM 1 +M 2 +1,N . . . . . . . . . . . .</p>
        <p>This work was supported in part by the Innovation-Driven Plan in Central South University under Grant 2018CX010, in part by the National Natural Science Foundation of China under Grant 61673397, in part by the Hunan Provincial Natural Science Fund for Distinguished Young Scholars (Grant No. 2016JJ1018), and in part by the Beijing Advanced Innovation Center for Intelligent Robots and Systems under Grant 2018IRS06.This work was supported in part by the Innovation-Driven Plan in Central South University under Grant 2018CX010, in part by the National Natural Science Foundation of China under Grant 61673397, in part by the Hunan Provincial Natural Science Fund for Distinguished Young Scholars (Grant No. 2016JJ1018), and in part by the Beijing Advanced Innovation Center for Intelligent Robots and Systems under Grant 2018IRS06.</p>
    </text>
</tei>
