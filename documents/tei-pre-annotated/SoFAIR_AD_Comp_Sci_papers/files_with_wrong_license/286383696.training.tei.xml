<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-24T11:34+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Mobile Edge Computing (MEC) is a new computing paradigm with great potential to enhance the performance of user equipment (UE) by offloading resource-hungry computation tasks to lightweight and ubiquitously deployed MEC servers. In this paper, we investigate the problem of offloading decision and resource allocation among multiple users served by one base station to achieve the optimal system-wide user utility, which is defined as a trade-off between task latency and energy consumption. Mobility in the process of task offloading is considered in the optimization. We prove that the problem is NP-hard and propose a heuristic mobilityaware offloading algorithm (HMAOA) to obtain the approximate optimal offloading scheme. The original global optimization problem is converted into multiple local optimization problems. Each local optimization problem is then decomposed into two subproblems: a convex computation allocation subproblem and a non-linear integer programming (NLIP) offloading decision subproblem. The convex subproblem is solved with a numerical method to obtain the optimal computation allocation among multiple offloading users, and a partial order based heuristic approach is designed for the NLIP subproblem to determine the approximate optimal offloading decision. The proposed HMAOA is with polynomial complexity. Extensive simulation experiments and comprehensive comparison with six baseline algorithms demonstrate its excellent performance.</p>
        <p>boosts the proliferation of novel mobile applications, such as augmented reality, natural language processing, and face recognition. Most of these applications are computation-intensive, latency-sensitive, and bandwidth-demanding. However, the resources in UEs are usually limited. It is difficult to support these emerging applications with merely onboard systems. Mobile cloud computing (MCC) was proposed to solve this problem [1]. By offloading resource-intensive tasks to the powerful remote cloud, MCC brings several benefits: prolonging battery life, supporting sophisticated computations, and providing potentially unlimited storage.</p>
        <p>Nevertheless, the long transmission distance between UE and cloud may cause high latency and jitter, which significantly affects the performance and usability of MCC [2]. Some bandwidth-demanding applications can also cause network congestion, which is harmful to the core network. Considering the weakness of MCC, mobile edge computing (MEC) was introduced in recent years [3]- [6]. In MEC, lightweight MEC servers are ubiquitously deployed in the vicinity of mobile users. Offloading can be done within the radio access networks, bringing lower network latency and less jitter. At the same time, the bandwidth to the core network can be saved, reducing the risk of network congestion.</p>
        <p>In MEC, the improvement of application performance largely depends on effective and efficient offloading decisions [6], [7]. Since extra overhead is induced, such as the energy consumption for data transmission and the time cost for task remote execution, it is unwise to always offload all tasks. Besides, MEC servers distributed throughout the network edge are with limited capability, which may lead to fierce resource contentions among users. Considering different environments and user requirements (e.g., user movement and task latency requirement), obtaining the optimal offloading scheme is usually a challenging problem. So far, research on task offloading has attracted significant attention, including the acceleration of computing [8]- [10], the optimization of energy consumption [11]- [13], and the trade-off between these two [14]- [16].</p>
        <p>When making offloading decisions, most existing studies assume a quasi-static scenario, where all UEs remain stationary during the offloading procedure that ranges from hundreds of milliseconds to several seconds [16]- [18]. However, in some real-world use cases, the mobility of UE cannot be neglected, especially for on-vehicle applications [19]: UEs can move with high speed in the cellular networks. Due to UE's movement, the wireless channel between UE and base station (BS) changes dynamically, and offloading processes may even fail if UEs move outside BS's coverage region. When considering user movement, obtaining the optimal offloading solution becomes more challenging [20]. The mobility is also widely researched in MEC, and many methods are proposed to support user mobility from different perspectives, such as service migration [21], [22], path selection [23], and fine-grained control (e.g., transmission power control [24] and resource allocation [25]), etc.</p>
        <p>In this paper, we investigate the problem of offloading decision and resource allocation among multiple moving UEs served by a BS. Because of user mobility, sufficient resources must be allocated to ensure the success of task offloading. However, the computation and wireless resources in BS's MEC server are limited, leading to severe contentions with the increase in the number of UEs. Under the constraints of resource limitation and UE's mobility, as well as task latency requirements, the BS needs to find the optimal offloading scheme to maximize the overall system-wide user utility, which is defined as a trade-off between task latency and energy consumption. This optimization problem is proved to be NP-hard and difficult to solve.</p>
        <p>To address this challenge, a heuristic mobility-aware offloading algorithm (HMAOA) with polynomial complexity is proposed. It first converts the original global optimization problem into multiple local optimization problems by fixing the maximum number of UEs allowed for offloading in each local optimization problem. Then, each local optimization problem is decomposed into two subproblems: a convex subproblem for allocating computation resources among multiple offloaded tasks and a non-linear integer programming (NLIP) subproblem to decide which UEs to offload. The convex computation allocation subproblem is solved numerically, and a partial order based heuristic approach is designed for the NLIP offloading decision subproblem. The solution to the global optimization problem is obtained by solving all the local optimization problems. Extensive simulations are performed by comparing with six baseline algorithms, and the experiment results demonstrate the superior performance of HMAOA. The main contributions of this paper are summarized as follows:</p>
        <p>r We investigate the offloading decision and resource alloca- tion problem among multiple users, while users' mobility in the process of task offloading is taken into account. Under the constraints of resource limitation, user mobility, and task latency requirements, this optimization problem is formulated as a mixed-integer nonlinear programming (MINLP) problem.</p>
        <p>r The proposed HMAOA has polynomial complexity. It transforms the original global optimization problem into multiple local optimization problems and then decomposes each local optimization problem into two subproblems: a convex computation allocation subproblem and an NLIP offloading decision subproblem. Because of the NP-hardness of the NLIP offloading decision subproblem, a partial order based heuristic approach is designed to obtain the approximate optimal offloading decision.</p>
        <p>r Extensive simulation experiments are conducted by com- paring with six baseline algorithms, including the exhaustive search method and fine-tuned genetic algorithm. The experiment results show that HMAOA can achieve more than 99.5% of the optimal system utility on average, confirming its excellent performance. The rest of this paper is organized as follows. The system model and problem formulation are presented in Section II. In Section III, HMAOA is proposed to solve this problem through a series of transformations and decompositions. We discuss how to adapt HMAOA to other scenarios in Section IV. Simulation experiments are conducted in Section V. Section VI reviews the related works, and, finally, Section VII concludes this paper.</p>
        <p>In this section, we first introduce the system architecture. Then, the detailed mathematical models of local and offloading execution and the overall designing objective are elaborated.</p>
        <p>In order to better demonstrate the impact of mobility, this paper considers a typical vehicular scenario, as shown in Fig. 1. A BS equipped with an MEC server acts as a proximate cloud to enhance the capability of UEs in its coverage region. UEs in the coverage region can move at high speed and, when necessary, request the BS for task offloading to reduce the time cost (i.e., latency) and energy consumption of task execution. After receiving the requests from UEs, the BS needs to make the offloading decision. Since the resources in the BS's MEC server are limited, contentions among UEs become fierce as the number of offloaded UEs increases. Hence, the offloading decision (which UEs can offload their tasks) and the resource allocation (how to allocate the computation and wireless resources for each task) should be jointly considered.</p>
        <p>Suppose that N UEs in the coverage region request the BS for task offloading. Let N = {1, 2, . . . , N} denote the UE set, and the task of UE n (n ∈ N) is defined as</p>
        <p>where d n specifies the size of the input data (in bits), c n is the total number of CPU cycles required to accomplish the task, and d n is the maximum latency allowed for executing the task (in seconds), respectively. The information of d n and c n can be obtained by applying program profiler (e.g., as introduced in [15], [18], [26]). Since the size of the computation output is generally much smaller than the input, we omit it in the definition as [15], [16], [18].</p>
        <p>All the tasks are atomic, which means that a task can be executed either locally in the UE or remotely in the BS's MEC server (by offloading), but cannot be separated. Let a n ∈ {0, 1} denote the offloading decision on OT n made by the BS. If OT n is assigned for local execution (i.e., a n = 0), c n CPU cycles will be directly processed on the local CPU of UE n. In contrast, if it is scheduled for offloading (i.e., a n = 1), d n bits of input data should first be transmitted to the BS via the wireless channel. Afterwards, the MEC server in the BS executes OT n with the allocated computation resource (in CPU frequency) and then send the output back.</p>
        <p>The mobility of UE directly affects the wireless channel between UE and BS. Trajectory prediction is one of the most widely studied topics in the field of intelligent transportation. Even in complicated situations, such as lane changing and turning (other than simply following the road), integrated prediction methods can achieve high predictive accuracy [27]. In this paper, it is thus assumed that UEs' trajectories within a short-term period, t P , can be estimated accurately. Let the time when making the offloading decision be 0. The trajectory of UE n is defined as</p>
        <p>where t is a future time from the moment of the offloading decision, i.e., 0, and (x n (t), y n (t)) is the coordinate of UE n at t taking the BS's location as the origin. After t P , the mobility of UEs cannot be anticipated.</p>
        <p>The coverage region of the BS can be presented as a polygon with holes. All the points in this polygon constitute a continuous point set, denoted as R. When a UE is located in this region, i.e., (x n (t), y n (t)) ∈ R, the channel fading coefficient between the UE and the BS is statistically determined by the signal propagation environment. If the UE moves outside the coverage region, i.e., (x n (t), y n (t)) / ∈ R, the data transmission between the UE and the BS cannot be guaranteed (because of the distance, noise, and interference from other base stations, etc.). The UE can be served by a new BS, as well as the MEC server of the new BS, after a handover. Nevertheless, the application data of its ongoing offloading task need to traverse between the original BS and the new one via the core network, whose latency cannot be guaranteed. Worse still, the UE may even be out of service, which leads to offloading failure. Therefore, if a task is scheduled for offloading, sufficient resources must be allocated to ensure that the offloading process is completed before the UE moves outside the BS's coverage region. Otherwise, scheduling the task for local execution is assumed to be a better choice.</p>
        <p>Let f l n denote the CPU frequency of UE n, which represents the number of CPU cycles the UE can execute in each second. Then, the time cost for executing OT n locally is given as</p>
        <p>In this paper, it is assumed that the local execution of a task can be completed within the task latency requirement, i.e., t l n ≤ d n . We will discuss how to adapt our method to the situation without this assumption in Section IV.</p>
        <p>The CPU power consumption of UE, denoted as p l n , is widely modeled to be a super-linear function of its CPU frequency [11], [17], [18], i.e.,</p>
        <p>Hence, the energy consumption for executing OT n is</p>
        <p>The offloading process of any task, e.g., OT n , consists of three phases: 1) transmission of input data from UE to MEC, 2) executing task remotely at MEC server, and 3) feeding computation result from MEC server back to UE. As previously mentioned, we ignored the overhead of the last phase (i.e., computation output reception) [15], [16], [18].</p>
        <p>1) Input Data Transmission: Let B denote the system bandwidth, which is orthogonally shared by the UEs in the coverage region, through, e.g., single-carrier frequency division multiple access (SC-FDMA). In this paper, it is assumed that the system bandwidth is equally allocated to the UEs admitted to offload their tasks (i.e., a n = 1). Then, the channel bandwidth for each UE to transmit its input data is subject to the number of offloaded UEs, which is given as</p>
        <p>According to [28], the data transmission rate from UE n to the BS can be obtained by</p>
        <p>where N represents the power spectral density of the white Gaussian noise, p n is the transmission power of UE n, and g n (t) denotes the channel gain from UE n to the BS at time point t, respectively. The wireless channel from UE n to the BS is modeled as a Rayleigh fading channel with free space propagation path loss. The channel gain g n (t) can be calculated by</p>
        <p>where h n is a stochastic variable following the complex Gaussian distribution CN (0, 1), representing the small-scale fading. L 0 and α are the path-loss constant and the path-loss exponent, respectively. l n (t) is the distance between UE n and the BS, which can be easily calculated by l n (t) = x 2 n (t) + y 2 n (t). The value of r n (w, t) can be obtained by integrating Eq.</p>
        <p>(3) into Eq. (2). Since it varies with UE's location, the time cost for task transmission is directly affected by user mobility. Considering that r n (w, t) is a stochastic variable (because of h n ), we calculate its expectation, i.e., E h n {r n (w, t)}. According to [29], the expectation can be approximated by Taylor series expansion as</p>
        <p>) where K is the Taylor order parameter to control the accuracy of this approximation, and SNR n is the received signal to noise ratio from UE n to the BS, denoted as SNR n = p n wN L 0 l α n (t) . The function T K (x) is defined as</p>
        <p>and t K is the solution to K n=0 (-t K ) n /n! = 0. When t ∈ [0, t P ), E h n {r n (w, t)} is continuous and positive. Hence, a cumulative area function can be constructed to show the relation between the size of the input data, i.e., d n , and its transmission time, i.e., t tx n , as</p>
        <p>Since t tx n is a function of w, we denote it as t tx n (w). With t tx n (w), the energy consumption for input data transmission can be calculated by</p>
        <p>2) Task Remote Execution: After OT n is transmitted to the BS, the BS should allocate a certain amount of CPU frequency for executing it. Let f n denote the CPU frequency allocated to OT n . The time cost for executing OT n remotely is</p>
        <p>As mentioned before, all the tasks to be offloaded need to share the limited computation resource in the BS. Let F 0 denote the total available CPU frequency of the BS. We have</p>
        <p>3) Offloading Execution Model: The total time cost for offloading OT n , denoted as t o n , is composed of two parts: the data transmission time and the remote execution time, i.e.,</p>
        <p>To UE n, the energy consumption for offloading OT n is only associated with the data transmission, which is given by</p>
        <p>To make the task offloading in this mobility scenario successful, two additional constraints should be satisfied. First, as previously mentioned, if OT n is scheduled for offloading (i.e., a n = 1), the offloading process must be completed before UE n moves outside the BS's coverage region (i.e., R), i.e.,</p>
        <p>In other words, all UEs scheduled for offloading (i.e., a n = 1) must be in the coverage region of the BS (i.e., T n (t) ∈ R) during the entire offloading process (i.e., ∀t ∈ [0, t o n (w, f n )]). Second, since the trajectory of UE cannot be predicted after t P , the data transmission after that cannot be anticipated. Therefore, the time consumption for task offloading is constrained to be less than t P , i.e.,</p>
        <p>As mentioned before, the trajectory prediction of UE within a short-term period can achieve high accuracy (as [27]). In this paper, t P is assumed to be in the range of a few seconds.</p>
        <p>Considering that the completion time of task offloading ranges from hundreds of milliseconds to several seconds (as [16]- [18]), this additional constraint is reasonable.</p>
        <p>In mobile system, the user experience for executing a task, e.g., OT n , is determined mainly by its execution latency, i.e., t n , and its energy consumption, i.e., e n . Specifically, t n and e n can be obtained by</p>
        <p>We design a quality-of-experience (QoE)-based utility function as [15], [16] to measure the user utility of executing OT n , which is defined as a trade-off between the time and energy consumption of the task compared with local execution, i.e.,</p>
        <p>where β T n ∈ [0, 1] and β E n ∈ [0, 1] are set by the user, indicating the user's preference on time and energy consumption when executing OT n . We set</p>
        <p>If the task is urgent, the user can increase the time consumption preference. Otherwise, if the UE is running in a low battery mode, the energy consumption preference can be raised.</p>
        <p>It is worth noting that the user utility on OT n , i.e., u n (a n , w, f n ), indicates the improvement in user experience over local execution. The improvement is measured by (t l nt n )/t l n and (e l ne n )/e l n , respectively. When OT n is executed locally, the user utility u n equals 0, i.e., u n (0, w, f n ) = 0, which brings no improvement. If the remote execution of OT n brings lower time and energy consumption compared with local execution, the user utility u n can be positive. However, offloading too many tasks leads to longer task latency because of the heavy resource contention. In this case, the user utility u n can be negative.</p>
        <p>We define the system utility as the weighted sum of all user utility, denoted as n∈N φ n u n (a n , w, f n ), where φ n ∈ [0, 1] indicates the preference of the service provider (SP) on UE n, which can be determined based on user's payment [15].</p>
        <p>Our target is to find the optimal offloading decision and resource allocation to maximize the system-wide user utility:</p>
        <p>, ( 8), ( 11), ( 12),</p>
        <p>where a = {a 1 , a 2 , . . . , a N } and f = {f 1 , f 2 , . . . , f N } are the vectors of variables to be optimized. Constraint (16) states that a task can be either locally executed or offloaded. All offloaded tasks must be allocated a certain amount of computation resource, which is ensured by constraint (17). Constraint (18) guarantees that all the tasks in N should be completed on time (subject to the maximum latency, i.e., d n ).</p>
        <p>Considering the non-linearity of the optimization function, i.e., n∈N φ n u n (a n , w, f n ), and value ranges of the variables to be optimized, problem GP is an MINLP problem [30].</p>
        <p>Constraint ( 18) can be rewritten as two constraints based on the offloading decision a, i.e.,</p>
        <p>As mentioned before, a task can be completed by local execution within the task latency requirement. Hence, constraint (19) can be ignored in the subsequent optimization. Constraint (11) indicates that the offloading process must be completed before UE n moves outside the BS's coverage region (i.e., R). Hence, it can be transferred from a spatial constraint to a temporal constraint. The key is to determine the time when UE n first leaves the BS's coverage region, denoted as t R n . With the trajectory of UE n (i.e., T n (t)) and the coverage region of the BS (i.e., R), t R n can be easily obtained (which will be introduced latter in this section). Then, we rewrite constraint (11) as</p>
        <p>Because of (9), constraints (12), ( 20) and ( 21) can be rewritten, respectively, as</p>
        <p>Let O denote the set of UEs scheduled for offloading, i.e., O = {n|a n = 1, n ∈ N}. Since executing a task locally brings 0 utility, our optimization objective can be rewritten as</p>
        <p>The number of offloaded UEs, i.e., |O|, varies from 1 to N , and the bandwidth allocated to each UE, i.e., w, changes accordingly as (25). The discrete variation of w leads to different objective function (i.e., n∈O φ n u n (1, w, f n )) and unstable constraint (i.e., ( 29)-( 31)). To deal with this problem, we convert the original global optimization problem GP2 into N local optimization problems with fixed channel bandwidth. The local optimization problem is defined as</p>
        <p>where ŵ = B/O max , and O max is fixed in each local optimization problem, but varies from 1 to N across different local optimization problems. It indicates the maximum number of UEs allowed for offloading in the corresponding local optimization problem. Note that the optimal solution of a local optimization problem may contain less than O max offloaded tasks. If so, allocating more bandwidth to each offloading task can bring higher system utility. Hence, the optimal solution of this local optimization problem is not the global optimal solution. When all of the N local optimization problems (i.e., LP) with different O max are solved, the global optimal solution, i.e., the solution of GP2, can be obtained by simply comparing their system utility. Therefore, we focus on solving LP in the rest of this paper.</p>
        <p>In LP, with the fixed channel bandwidth for each UE, i.e., ŵ, the time cost for input data transmission, i.e., t tx n ( ŵ), can be calculated according to (5). Since the trajectory T n (t) can be arbitrary, it is difficult to derive the analytical solution of t tx n ( ŵ), as well as t R n (mentioned before). Therefore, a numerical adjusted trapezoidal method is adopted to obtain both the approximate values of t tx n ( ŵ) and t R n , as shown in Algorithm 1. The trajectory of UE n is divided into multiple tiny segments based on the time interval, step. In each segment, the data transmission rate, i.e., E h n {r n ( ŵ, timeP ast)}, is assumed to be fixed. In this way, we can obtain the amount of data transmitted in each step, i.e., Δ. Then, the data transmission time, i.e., t tx n ( ŵ), is the accumulated time interval when the input data transmission finished (i.e., dataSend ≥ d n ). In each step, we also check if [31]) and record the time when it first leaves this region, i.e., t R n . As previously mentioned, the trajectory of UE cannot be predicted after t P . Therefore, in Algorithm 1, if UE n never moves outside the BS's coverage region within the period of t P , we set the value of t R n as the longest time interval that can be predicted, i.e., t P . In addition, there are two situations that make the data transmission time, i.e., t tx n ( ŵ), unable to obtain: 1) UE n leaves the coverage region before the completion of input data transmission; 2) The input data transmission cannot be finished before t P . If either of these two situations occurs, it indicates that OT n is not suitable for offloading under the current channel bandwidth. Therefore, we set the value of t tx n ( ŵ) to infinity, which causes OT n to be assigned for local execution because of constraints ( 29)- (31). The accuracy of the time approximation in Algorithm 1 is subject to the length of step, and t P /step iterations are needed in the worst case.</p>
        <p>With the values of t R n and t tx n ( ŵ), constraints ( 29)-( 31) can be combined into one, i.e.,</p>
        <p>where According to (7), the constraint can be written as</p>
        <p>For UE n ∈ N 1 , only when φ n u n (1, ŵ, f n ) ≥ 0, it is reasonable to offload OT n . Otherwise, executing the task locally is a better choice, which increases its utility as well as the system's. Let φ n u n (1, ŵ, f n ) ≥ 0, we can derive:</p>
        <p>where</p>
        <p>Similarly, only when t inlmt n &gt; 0, it can bring positive utility to offload</p>
        <p>The search space of O can be further truncated to N 2 , i.e., O ⊆ N 2 . We have</p>
        <p>Constraints ( 27), (34), and ( 36) can be combined as</p>
        <p>where k n is the maximum value in 0, c n /t inlmt n , and c n /t inlmt n . It represents the minimum CPU frequency required to meet once OT n is offloaded. When k n &gt; F 0 , we can only execute such task locally because of the shortage of computation resource. Hence, the search space of O is further truncated, i.e., O ⊆ N 3 , where</p>
        <p>According to ( 6), ( 7), ( 9), (10), and ( 13)-( 15), the objective function can be rewritten as</p>
        <p>where n and ς n are two positive constants.</p>
        <p>Theorem 1: Problem LP2, as well as GP, is NP-hard. Proof: See Appendix A.</p>
        <p>Problem LP2 can be decomposed into two subproblems: one for offloading decision and one for computation allocation.</p>
        <p>1) Computation Allocation: Once the offloading decision set, i.e., O, is given, problem LP2 reduces to a convex problem to allocate the CPU frequency in the BS's MEC server, i.e., (28), (38).</p>
        <p>which means that the Hessian matrix of h(f ) is negtive definite. Hence, SP1 is a convex optimization, which can be solved with the Lagrangian duality and Algorithm 2: Frequency Allocation Algorithm (F unc).</p>
        <p>totalF requency ← n∈O k n 3:</p>
        <p>if totalF requency &gt; F 0 then 4:</p>
        <p>g ← -y/f 2 obtain gradients g = {g 1 , g 2 , . . . , g n } 8:</p>
        <p>while totalF requency &lt; F 0 do 9:</p>
        <p>i ← arg min i∈O {g i } find the lowest gradient 10:</p>
        <p>totalF requency ← totalF requency + piece 13:</p>
        <p>end while 14:</p>
        <p>util</p>
        <p>return f , util 16: end procedure Karush-Kuhn-Tucker conditions [32]. However, this needs to solve a multi-variable system of non-linear equations, which brings high complexity. We construct Algorithm 2 numerically, which divides F 0 into many tiny atomic pieces and assigns them one by one to each UE. The key is to find the UE with the fastest change on each assignment, which is the one with the lowest gradient. When each piece is small enough, the final allocation can adequately approach the optimal result.</p>
        <p>The complexity of Algorithm 2 is subject to the total available frequency, i.e., F 0 , the length of each tiny piece, i.e., piece, the minimum frequency of UEs, i.e., k, and the number of offloaded tasks, i.e., |O|. In the worst case, the complexity of this algorithm is O(F 0 /step × O max ).</p>
        <p>2) Offloading Decision: With Algorithm 2, the numerical solution of SP1 can be obtained. Then, we need to search for the optimal subset O from N 3 as the offloading decision, i.e., (32), (39).</p>
        <p>Due to the non-linearity of F unc(•), SP2 is an NLIP problem, which is still NP-hard [33]. Hence, we design a partial order based heuristic approach to solve this subproblem with polynomial complexity.</p>
        <p>Let</p>
        <p>is the lowest utility OT n can contribute to the system utility once offloaded. Then, Util n (f n ) increases as f n grows, until it consumes all the CPU frequency in the MEC server, i.e., Util n (F 0 ). Here, the minimum frequency requirement k n , the lowest utility Util n (k n ) and the highest utility Util n (F 0 ) of OT n are the key features for constructing our heuristic approach.</p>
        <p>Definition 1: Define the binary relation priority equal: ∀n, m ∈ N 3 , OT n is priority equal to OT m (OT n OT m ) if and only if they are with the same minimum frequency requirement and the same lowest and highest utility, i.e.,</p>
        <p>From Definition 1, we can deduce that</p>
        <p>Therefore, for two priority equivalent tasks, when making the offloading decision, there is no difference in choosing either of them, which means that they have the same priorities.</p>
        <p>Definition 2: Define the binary relation priority higher: ∀n, m ∈ N 3 , OT n is priority higher than OT m (OT n OT m ) if and only if their minimum frequency requirements satisfy k n &lt; k m , and their utility at k m and F 0 satisfy Util n (k m ) &gt; Util m (k m ) and Util n (F 0 ) &gt; Util m (F 0 ), respectively, i.e.,</p>
        <p>With this lemma, if OT n OT m , OT n contributes more in system utility than OT m when f ∈ [k m , F 0 ]; and OT n is the only choice when f ∈ [k n , k m ]. Hence, when OT n is priority higher than OT m , choosing OT n is always better than OT m , which means that OT n has a higher priority than OT m .</p>
        <p>Lemma 2: With the binary relation of priority higher, the UE set, N 3 , is a strict partially ordered set (poset).</p>
        <p>Proof: See Appendix C. Let (N 3 , ) denote the poset. Based on (N 3 , ), we can generate a Hasse diagram (HD) [34], which is a transitive reduced directed acyclic graph (DAG). In an HD, when OT i OT j , there is one and only one path from OT i to OT j .</p>
        <p>Poset (N 3 , ) becomes a totally ordered set when all the tasks in it are comparable with each other. In this case, the generated HD reduces to a chain, which means that it can be sorted into a sequence under the relation of priority higher.</p>
        <p>Definition 3: For a sequence Seq = (i 1 , i 2 , . . . , i n ), the kth head-subsequence of Seq is the subsequence of Seq constructed by the first k items in Seq in their original order. We denote it as head(Seq, k) (i 1 , i 2 , . . . , i k ).</p>
        <p>Lemma 3: If (N 3 , ) is a totally ordered set, i.e., a chain, and let Seq N 3 denote the sequence from its highest priority task to its lowest one, then the optimal offloading decision set is one of Seq N 3 's head-subsequences.</p>
        <p>Proof: See Appendix D. Because of the non-linearity of F unc(•), it is not straightforward to find which head-subsequence of Seq N 3 is the optimal Algorithm 3: Offloading Decision on Chain (ODC). return O, f , util 14: end procedure offloading decision. We only need to find the one with maximum system utility from the |N 3 | head-subsequences of N 3 . Algorithm 3 describes this procedure. In the worst case, it needs to call Algorithm 2 O max times.</p>
        <p>Generally, not every task in (N 3 , ) is comparable to each other. In this case, we consider constructing a linear extension of (N 3 , ), which is a totally ordered set that contains all the relations in the original poset [34]. Let (N 3 , * ) denote the linear extension. We have ∀OT i , OT j ∈ (N 3 , ), OT i OT j ⇒ OT i * OT j , OT i , OT j ∈ (N 3 , * ). Lemma 4: The optimal offloading decision set of SP2 is a head-subsequence in one of (N 3 , )'s sorted linear extensions.</p>
        <p>Proof: See Appendix E.</p>
        <p>According to the order-extension principle, every partial order can be extended to at least one total order by topological sorting algorithms [34]. With this principle, an intuitive method is to enumerate all the linear extensions of (N 3 , ). However, this method has huge complexity (to count all the linear extensions of a finite partial order is #P-complete [35]). In the worst case, if all the tasks in (N 3 , ) are incomparable with each other, there will be |N 3 |! linear extensions.</p>
        <p>Based on the above analysis, in this paper, we heuristically construct a task comparison method, which turns (N 3 , ) into a linear extension and then obtains the approximate optimal offloading decision by Algorithm 3.</p>
        <p>The relation between two tasks on their contributions to the system utility changes with the allocated frequency. ∀OT n , OT m ∈ (N 3 , ), there exist four different situations., 1 1) When</p>
        <p>OT n contributes more 1 OT n and OT m can be any tasks in (N 3 ). If we exchange their positions in each situation, the result is also correct. There is no need to list them repeatedly.</p>
        <p>to the system utility, i.e., Util n (f ) ≥ Util m (f ), and</p>
        <p>We find that, in situation (1), the relation between two tasks on their contributions to the system utility is independent to the allocated frequency f . We only need to retain the relations in the original set (N 3 , ) to ensure the accuracy of topological sorting. However, in situations ( 2), (3), and ( 4), there exist one or two change points. When f changes, the relation of the two tasks changes too. More conditions should be considered in order to compare them.</p>
        <p>When a change point of two tasks, i.e., f chg , is small, e.g., near 0, the relation on (0, f chg ] can hardly take effect because almost every offloaded task should be allocated a certain amount of frequency. Similarly, when a change point is large, e.g., near F 0 , the relation on (f chg , F 0 ] has little impact since a task can hardly consume all the resources. Hence, we define two parameters Ψ l , Ψ h ∈ (0, 1] to control two frequency thresholds, bound l (Ψ l ) and bound h (Ψ h ), and only consider the task relations in the range of (bound l (Ψ l ), bound h (Ψ h )). bound l and bound h are defined as</p>
        <p>The values of Ψ l and Ψ h are set empirically. When they become larger, the ignored change points become less.</p>
        <p>When there is at least one change point between bound l and bound h , the relation between two tasks becomes subtle. In this case, we empirically determine their relation by comparing the area under their utility functions, i.e., Util(•). The area can well synthesize k n , Util n (k n ), and Util n (F 0 ), simultaneously. The evaluation in Section V will show its excellent property. The area of OT n when f ∈ [bound l , bound h ] can be calculated by definite integral:</p>
        <p>where</p>
        <p>We summarize the task comparison method in Table I. Now, any two tasks in (N 3 , ) are comparable with each other by the heuristic method. Sorting algorithms can be adopted to build the sequence, and one of its head-sequences is the approximate optimal offloading decision. Record O, f , and utility under O max . 12:</p>
        <p>end for 13:</p>
        <p>Find the O and f with maximum utility in all records. 14:</p>
        <p>Send the offloading decision to UEs. 15: end procedure</p>
        <p>The proposed HMAOA is summarized in Algorithm 4. After receiving the offloading requests from N UEs, HMAOA enters N iterations, each of which has different O max (from 1 to N ). In each iteration, ŵ is fixed, i.e., ŵ = B/O max . For each offloading request, Algorithm 1 is performed to obtain t R and t tx n ( ŵ). Then, the search space is truncated to N 3 . HMAOA computes the area under the utility function of all tasks (i.e., Util n (•)) as introduced in Section III-B2, which can boost the task comparison afterwards. Based on the proposed heuristic task comparison method, sorting algorithms can be adopted to turn N 3 into an ordered sequence. After that, the approximate optimal offloading decision in this iteration is obtained by Algorithm 3 and recorded. Finally, all the recorded offloading decisions are compared to find the one with the highest utility as the offloading decision.</p>
        <p>Three critical operations determine the complexity of HMAOA: Algorithm 1, with the complexity of O(t P /step), is invoked N 2 times; the sorting algorithm, usually with the complexity of O(N × log(N )), is called N times; Algorithm 3, which invokes Algorithm 2 N times, is called N times. In the worst case, the complexity of Algorithm 2 is O(F 0 /step × N ). Therefore, the complexity of HMAOA is O(N 3 × (F 0 /step)).</p>
        <p>This section discusses how to adapt the proposed HMAOA to other scenarios.</p>
        <p>As previously mentioned, in this paper, we assume that all tasks can be completed by local execution within their task latency requirements, i.e., t l n ≤ d n . This assumption is reasonable because MEC services are not always available, and a UE must complete its task by itself if no MEC server exists (e.g., out of service). Nevertheless, in some special use cases (e.g., a very urgent task), the latency requirement of a task may be less than its local execution time, i.e., d n &lt; t l n . This means that the task should always be offloaded, and sufficient resources should be allocated. Let Ô denote the set of all these tasks, i.e., Ô = {n|d n &lt; t l n , n ∈ N}. Since all tasks in Ô should be offloaded, we have Ô ⊆ O. The original global optimization problem changes into</p>
        <p>The corresponding local optimization problem changes into</p>
        <p>where</p>
        <p>In LP3, a new search space of O, i.e., N 4 , is derived because constraint (36) does not apply to this scenario: A task in Ô should always be offloaded even it brings negative utility.</p>
        <p>By pre-determining some elements of the offloading set O before making the offloading decision, HMAOA can be well adapted to the new scenario. Specifically, in each local optimization we search from the difference set between N 4 and Ô, i.e., N 4 -Ô, for the optimal head-subsequence, which, combined with Ô, can produce the maximum system utility. Note that some local optimization problems (i.e., LP3) of GP3 may be infeasible because</p>
        <p>This does not affect the global optimization. We just need to optimize the feasible ones and, among them, find the optimal solution.</p>
        <p>However, there exists the situation where all the derived local optimization problems are infeasible. It indicates that the global optimization problem itself is infeasible because of resource limitation. How to deal with this situation is beyond the scope of this paper, which is an interesting topic to investigate in our future work.</p>
        <p>Since users' requests arrive dynamically, HMAOA can work in an online mode to achieve resource multiplexing in the time dimension: The BS collects the released communication and computation resources in real time and allocates current available resources to the requesting UEs. In this mode, our original offloading optimization problem can be rewritten as</p>
        <p>, ( 29)-( 31).</p>
        <p>(</p>
        <p>where N is the set of current requesting UEs, and B and F0 are current available wireless bandwidth and CPU frequency in the MEC server, respectively. Since GP4 is equivalent to GP2, HMAOA can solve this problem without any modification.</p>
        <p>In this paper, the coverage region of one BS is considered to be the basic spatial unit of offloading decision and resource allocation. By dividing the physical space into multiple spatial units based on BS's coverage region and only focusing on one of them, the offloading problem can be simplified. At the same time, applying the solution for one coverage region (i.e., HMAOA) to others is straightforward.</p>
        <p>The overall system performance can be further improved if BSs can cooperate. This can ensure the success of ongoing offloaded tasks even when UEs traverse among BS's coverage regions. To further optimize the offloading scheme in this situation is an interesting topic to investigate at the next stage, in which the handover cost, delay, the available resources of both the original and the target BS, and the topology and status of the edge and core network should all be taken into account.</p>
        <p>In this section, simulation experiments are adopted to evaluate the proposed HMAOA. All the experiments are run on 
            <rs type="software">Matlab</rs>
            <rs type="version">R</rs>
            <rs type="version">2018b</rs> using a server with Intel Xeon CPU E5-2650 @ 2.2 GHz processor. Table II summarizes the main simulation parameters and their default values.
        </p>
        <p>In our simulation, the coverage region of the BS is considered to be a circle with a radius of R = 100 meters. The system bandwidth of the BS is set as B = 20 MHz, and the total available CPU frequency is set as F 0 = 20 GHz. All the wireless communication parameters, including the path-loss, the white Gaussian noise density, and the UE's transmission power, are set in accordance with the 3GPP specification [36].</p>
        <p>Each UE has its motion parameters, including location, speed, and direction. In the simulations, for simplicity, we consider all UEs moving straightly with a constant speed. In each simulation run, N moving UEs are uniformly distributed in the BS's coverage region, and their speed and direction are chosen from the uniform distributions as shown in Table II.</p>
        <p>For the sake of generality, all the parameters regarding UE, i.e., the UE's local CPU frequency f l n , the user's time consumption preference β T n , and the user preference of SP φ n , are set as random variables following the uniform distributions as shown in Table II. The same consideration holds for the parameters regarding task, i.e., the input data size d n , the number of CPU cycles c n , and the latency requirement d n . To ensure that the local execution of a task is completed within its latency requirement, d n is set to c n /f l n if its randomly generated value is less than c n /f l n . We set the time interval, in which UEs' trajectories can be predicted, i.e., t P , to 4 seconds. The power consumption coefficients, i.e., ξ and γ, and the Taylor order parameter, i.e., K, are set in accordance with [17] and [29], respectively.</p>
        <p>The proposed HMAOA is compared with the following baseline algorithms.</p>
        <p>r Exhaustive Search Method (ESM): In this method, all the 2 N combinations of offloading decisions are evaluated to find out the optimal solution with the highest utility. Because of the enormous computational complexity, it takes a huge amount of time to run this method.</p>
        <p>r Genetic Algorithm (GA): As a meta-heuristic algorithm, GA is a practical solution for this kind of combinatorial optimizations. The GA implementation in 
            <rs type="software">Matlab</rs> global optimization toolbox is adopted. The offloading decision is encoded into the chromosome of each individual. As the algorithm progresses, individuals that contribute higher system utility gain more opportunities for reproduction. When GA terminates, the most adaptable individual is selected as the final offloading decision. The settings of GA are summarized in Table III.
        </p>
        <p>r Stationary Exhaustive Search Method (SESM): This method makes offloading decisions without considering UEs' mobility. It assumes that all UEs are stationary, and adopts ESM to find the optimal offloading solution. Since UEs are actually moving, following SESM's offloading decision may cause task failure. The performance of SESM is the upper bound of all the methods that do not consider UEs' mobility.</p>
        <p>r Independent Decision Execution (IDE): In this method, a UE assumes that the resources in the MEC server are dedicated to its offloaded task, and makes offloading decisions independently. This method takes the mobility of UE into account. When it is possible to gain a higher utility compared with local execution, the UE offloads its task. This is a classic approach that does not consider resource allocation [12], [16]. It is worth noting that, without considering user mobility or resource limitation, the offloading decisions made by SESM, IDE, and AEE may cause task failure and wasted resources. How to deal with the failed tasks in these methods is beyond the scope of this paper. In this experiment, we simply assume that a UE can obtain how many resources are allocated for it from the response of the MEC server. If the allocated resource is not enough for task offloading, the UE executes the task locally, which brings 0 user utility.</p>
        <p>With different numbers of UEs (N = 5, 10, . . ., 30), the simulation is run for 200 iterations. In each iteration, the randomly generated parameters, under which all the algorithms run, are the same. Then, the average outcome is adopted as the simulation result.</p>
        <p>System Utility With Varying Number of Users: We first evaluate the average system utility with different numbers of users, and the evaluation results are shown in Fig. 2. Because ALE always produces 0 system utility, we omit it in the figures of this section unless necessary. There are two bound parameters in HMAOA, i.e., Ψ l and Ψ h . The effect of their values is evaluated in later simulation, and at this time, they are set to Ψ l = 0.8 and Ψ h = 0.3, respectively. We can see that the performance of HMAOA is very close to ESM. It always achieves more than 99.5% of the optimal system utility under different numbers of users. The performance of GA and HMAOA is close when N is small. As N increases, the performance gap between GA and HMAOA becomes larger. The average system utility of GA, when N = 30, is only about 75% of HMAOA. When N &gt; 20, because of the huge search space, the utility of GA even decreases. Since mobility is not considered, SESM may offload some inappropriate tasks, which contributes 0 user utility (as mentioned before). Its performance is strictly lower than ESM, HMAOA, and GA. When N ≥ 15, the average system utility of AEE becomes negative, and so does IDE when N ≥ 20. Because of the fierce resource contentions, resources allocated to each UE are not enough to produce positive utility. We omit the negative utility segments in Fig. 2 since the performance of these methods is even worse than ALE.</p>
        <p>Number of Offloaded UEs With Varying Number of Users: Then, we evaluate the average number of offloaded UEs with different numbers of users in the same setting as before, as shown in Fig. 3. Since ALE never offloads, we omit it in this figure . Because AEE always offloads a task, its offloaded UE number increases linearly with the increase of user number. In our simulations, IDE always assumes that a UE can monopolize all the resources in the MEC server. Because the resources on an MEC server are usually adequate for only one task, the performance of IDE is similar to the AEE. ESM, HMAOA, GA, and SESM perform similarly. Constrained by the limited resources, the numbers of their offloaded UEs grow very slowly and are stable at around 10.</p>
        <p>Algorithm Running Time With Varying Number of Users: Fig. 4 shows the average running time of different algorithms with different numbers of users. Due to the extremely high complexity of ESM, SESM, and GA, we set the y-axis in Fig. 4 to a logarithmic scale. From this figure, we can see the exponential complexity of ESM and SESM. GA is always with high complexity. To find the optimal solution, a large population size and many generations are necessary. Since the algorithm logic of IDE and AEE are simple, their running times are negligible. The running time of HMAOA increases with N . Thanks to its polynomial complexity (O(N 3 × (F 0 /step))), its running time is less than 1 second even when N = 30.</p>
        <p>Variation of System Utility: The performance of each offloading method is analyzed across different simulation runs. In each simulation run, the system utility of each method is normalized, which is presented as a ratio of the system utility to the optimal one obtained by ESM. Obviously, this ratio cannot be greater than 1, and the method with a higher ratio performs better in each simulation run. We adopt the cumulative distribution function (CDF) to show the distribution of the ratios across all the simulation runs when N = 30, as shown in Fig. 5. Because the system utility of ALE is always equal to 0, its CDF curve shows a vertical line, i.e., x = 0. When N = 30, because of the heavy resource contention, IDE and AEE nearly always produce negative system utility (only about 10% of the outcome is positive). Since AEE offloads all the tasks, its performance is the worst among all methods. In the worst case, SESM and GA achieve 17.0% and 49.1% of the optimal system utility, respectively. HMAOA shows its significant performance and excellent stability. It can achieve 95.6% of the optimal system utility even in the worst case. Its curve is very close to x = 1, i.e., the curve of ESM (the normalized system utility of ESM is always 1).</p>
        <p>Average System Utility With Varying User Speed: Fig. 6 shows the relation between the average system utility and user speed under different algorithms. The number of UEs is fixed, i.e., N = 20, and the speed of all users varies from 0 m/s (i.e., stationary) to 60 m/s. The average system utility of all the algorithms decreases as the speed of UEs increases because many tasks that can contribute higher system utility cannot be offloaded any more considering the mobility constraint. ESM always brings the highest system utility, and the performance of HMAOA is almost the same as it. The curve of GA is lower than HMAOA, as well as ESM. We omit the curves of IDE and AEE in Fig. 6 since their average system utility is always negative when N = 20, even worse than ALE (always equals to 0). The performance of SESM is the same as ESM when UEs are stationary. As the speed of a UE grows, the probability of it leaving the BS's coverage region before the completion of its offloaded task increases. Without considering this situation, SESM may offload some inappropriate tasks, leading to 0 user utility. Its performance, hence, drops rapidly with the increase of user speed comparing with other methods.</p>
        <p>Performance of HMAOA With Varying Bound Parameters: The performance of HMAOA is affected by two bound parameters, i.e., Ψ l and Ψ h . As introduced before, the value ranges of Ψ l and Ψ h are (0,1], and the less Ψ l or Ψ h is, the more change points is ignored. In this simulation, four pairs of bound parameters are chosen, from (Ψ l = 1, Ψ h = 1) to (Ψ l = 0.5, Ψ h = 0.3). Note that, when both of them are set to be 1, the comparison of tasks degenerates into the comparison of areas under their utility functions. Fig. 7 shows the effects of the two bound parameters to the performance of HMAOA. When N ≤ 15, the HMAOA with higher bound parameters performs slightly better. That is because when the number of users is small, the resource allocation varies greatly, and it is not reasonable to ignore too many change points. When the number of users becomes larger, e.g., N ≥ 20, the severe resource competition makes it unlikely that one UE is allocated with too many resources, and the resource allocation among UEs tends to be even. In this case, a lower bound parameter can achieve a better result. In practical situations, we can adjust the bound parameters with the variation of user numbers to achieve higher performance.</p>
        <p>The first technique to enable MEC is cloudlet proposed in 2009, which deploys the cloud infrastructure to the network edge, bringing satisfactory user experience [2], [7]. To integrate the MEC concept into the mobile network architecture, the European Telecommunications Standards Institute (ETSI) makes a lot of contributions, and many standards regarding ETSI MEC are published [4].</p>
        <p>As introduced before, offloading decision-making in MEC is a challenging problem and receives extensive attention. Many previous studies assume a quasi-static scenario when making offloading decisions. In [11], Lin et al. present a three-step algorithm to minimize energy dissipation of a directed acyclic graph-based application while meeting the application deadline. Mao et al. propose an offloading algorithm to minimize the task execution delay on a device with energy harvesting and frequency scaling function [37]. Reference [38] investigates the offloading problem of a full granularity application to minimize the energy consumption of the application.</p>
        <p>When it comes to multi-user scenarios, how to allocate the limited resources at the network edge becomes a challenge. Reference [15] tries to maximize the system utility of multiple users by jointly optimizing their transmission power and the computation resource allocation in the BS. Chen et al. propose a game theory-based algorithm to make the offloading decision among multiple users in a wireless contention environment to minimize the system-wide overhead [17], [18]. The authors in [39] study the task offloading and resource allocation in a vehicular scenario, where server selection, task partition, and computation resource allocation are jointly considered.</p>
        <p>Other than offloading decision and resource allocation, mobility is also an important research topic in MEC. There are many methods to deal with user mobility from different perspectives. Service is widely researched to ensure service continuity and availability by migrating a service entity closer to its user. For example, Sun et al. propose a novel service placement algorithm for a cloudlet network architecture to optimize the tradeoff between migration gain and migration cost [21]. Since the cost of migrating the virtual disk of a service entity is high, the authors in [22] propose to place multiple virtual disk replicas of a service entity into suitable cloudlets and only migrate the service entity among these cloudlets to reduce the average service delay. Path selection tries to optimize the data delivery paths for task offloading. In [23], the authors propose an algorithm to select the optimal path for offloading data delivery between UE and MEC servers to minimize the transmission delay. Many studies use fine-grained control to ensure the success of a specific offloading task during user movement. Reference [24] offers a cloud-aware power control algorithm to adjust the transmission power of the BS to prevent the handover from happening before the offloading result received. In [25], we propose a GA-based computation allocation algorithm to ensure the success of task offloading before a handover occurs.</p>
        <p>In this paper, we investigate offloading decision and resource allocation among multiple UEs to achieve the optimal system utility. Due to the mobility of UEs, sufficient resources must be allocated to ensure the completion of the offloading process within BS's coverage region.</p>
        <p>As a key technology of Internet of things, MEC enables UEs to support resource-intensive applications with significantly lower latency and less energy consumption. In this paper, we focus on the challenging problem of offloading decision and resource allocation among multiple moving UEs in MEC. A heuristic mobility-aware offloading algorithm is proposed to maximize the system utility under the constraints of user mobility, resource limitation, and task latency. The proposed HMAOA is with polynomial complexity. Extensive simulation results demonstrate that it can achieve offloading performance very close to the optimal solution, but with high efficiency.</p>
        <p>OT j , and OT i , OT j ∈ (N 3 , * ). That means Seq N 3 = (Seq O , Seq O ) is a sorted linear extension of (N 3 , ), and Seq O is the head-subsequence.</p>
        <p>This work was supported in part by the National Natural Science Foundation of China under Grants 61871096 and 61972075, in part by the National Key R&amp;D Program of China under Grant 2018YFB2101300, in part by the EU H2020 Research and Innovation Programme under the Marie Sklodowska-Curie under Grant 752979, and in part by the China Scholarship Council.</p>
        <p>Here, we first introduce 0-1 knapsack problem: there is a knapsack, whose maximum weight capacity is W 0 , and a set of items I. Each item in the set has a weight w n and a value v n . The objective is to maximize the sum of the values of the items packed in the knapsack so that the sum of the weights is less than or equal to the knapsack's capacity. It can be formulated as follows:</p>
        <p>where O is the item set decided for packing. The 0-1 knapsack problem is known as NP-hard [33].</p>
        <p>Let</p>
        <p>there is an algorithm to solve LP2, we can use it to solve the 0-1 knapsack problem. Hence, problem LP2 is NP-hard. Since GP is polynomial-time reducible to LP2, the original problem GP is also NP-hard.</p>
        <p>There are three different cases to be considered:</p>
        <p>The lemma is thus proved.</p>
        <p>We can use any sorting algorithm to build Seq N 3 , denoted as</p>
        <p>The proof is by contradiction. Assume that the optimal offloading decision set, which brings the highest system utility, is not one of Seq N 3 's head-subsequences. We can firstly sort the set, and rewrite it into a subsequence of Seq N 3 as Seq max = (OT 1 , OT 2 , . . . , OT M ), where M denotes the cardinality of the offloading decision set. Algorithm 2 obtains the optimal system utility F unc(Seq max ) and the optimal frequency allocation f max = (f 1 , f 2 , . . . , f M ). Because Seq max is not one of Seq N 3 's head-subsequences, i.e., Seq max = head(Seq, M ), there should be at least one item in head(Seq, M ), which is not in Seq max , and we denote any one of them as OT x . We also can derive that the last item in Seq max , OT M , is not in head(Seq, M ). Obviously,</p>
        <p>Replacing OT M in Seq max with OT x , a higher system utility is obtained since Util OT x (f M ) &gt; Util OT M (f M ). However, Seq max is already the optimal offloading decision, which leads to a contradiction. Therefore, the optimal offloading decision set is one of Seq N 3 's head-subsequences.</p>
        <p>Assume that the optimal offloading decision set, which brings the highest system utility, is O, and the rest tasks in N 3 form a set O. We have O ∪ O = N 3 and O ∩ O = ∅. This lemma will be proved in two steps.</p>
        <p>The proof is by contradiction. Assume that there exist OT i ∈ O and OT j ∈ O, satisfying OT i OT j . Then, we can replace OT j in O with OT i to bring higher system utility. However, O is the optimal offloading decision set, and the utility cannot be higher, which leads to a contradiction. Hence, the proposition is thus proved.</p>
    </text>
</tei>
