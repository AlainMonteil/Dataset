<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-24T11:35+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Date of publication xxxx 00, 0000, date of current version xxxx 00, 0000.</p>
        <p>In recent years, the massive growth of computationally intensive and delay sensitive mobile applications, such as online gaming, image or signal processing (e.g., facial recognition), augmented reality, and real-time translation services, have been imposing heavy computation demands on resource-constrained mobile devices (MDs). As MDs are limited in terms of computation, battery, and storage capacity, there is a growing trend to offload or transfer computation intensive tasks to powerful remote computing platforms. This method is referred to as computation offloading. It reduces energy consumption for local processing and therefore prolongs battery life.</p>
        <p>Mobile cloud computing (MCC) [1] is a well-known computation offloading model for MDs [1]. In MCC, user devices can utilize the resources of dedicated remote cloud servers for executing their tasks. These servers have high power, CPU, and storage capabilities. However, the long distance between the MDs and the cloud server lead to substantial communication costs in terms of latency and energy, negatively influencing real-time applications [2]. Therefore, in recent years, the computation and storage capabilities of the remote cloud have partially migrated to the edge server (near the MDs). This concept is called mobile edge computing (MEC) [3].</p>
        <p>MEC provides information technology services and cloud computing capabilities at the mobile network edge. MEC is implemented by a dense deployment of computational servers or by strengthening already deployed edge entities, such as small cell base stations (BS) with computation and storage resources. The objective of MEC is to ensure efficient network operation and service distribution, reduce latency, and offer an enhanced user experience [3,4]. MEC offloads computation intensive applications to the cellular network edge. Smart cities can benefit from offloading to edge servers in the framework of the so-called cyber-physical-social systems (CPSSs), as in traffic violation tracking cameras, or drone services for delivery or geological survey purposes. Each edge node processes the data itself rather than forwarding them to a central remote cloud. Consequently, MEC can improve user experience quality (QoE) and meet service quality (QoS) requirements, such as low latency and energy consumption. Moreover, unlike MCC, MEC pursues a decentralized framework where the edge servers are deployed in a distributed manner.</p>
        <p>Despite the great potential of MEC, there remain several challenges. As discussed before, real-time mobile applications are highly sensitive in terms of latency and energy consumption. However, owing to the randomness and dynamics of mobile edge networks, the long execution time of these applications can lead to high energy consumption. Most studies indicate that the long execution time is one of the major challenges in MEC [5] [6]. Hence, there is a need for an efficient computation-offloading framework for MEC. Furthermore, MDs determine when offloading should be performed, and what part of a given task should be offload to an edge server. However, developing an effective dynamic partitioning method for accurate offloading decision making is a challenge in MEC. Moreover, determining where to offload a task in a multi-edge network for minimizing the latency of service computing (close proximity edge or adjacent edge network or remote cloud) is another challenge. In addition, the limited computational resources of mobile edge servers should be efficiently utilized so that QoS requirements may be met (e.g., latency requirement). Furthermore, user mobility, the heterogeneity of edge node resources, and the physical distribution of MDs impose additional challenges for computation offloading in edge computing.</p>
        <p>A number of methods have been developed to overcome some of these challenges [13][14][15][16]. However, these studies did not consider the benefit of using adjacent edges to serve offloadable tasks when the nearest edge server cannot serve these tasks. Another limitation is that all these studies used offpolicy-based reinforcement learning techniques for resource allocation management, such as the Q-Learning method. This technique depends on the previous workload state, ignoring the current state. Moreover, current studies lack an efficient dynamic multi-objective optimization decision scheme for selecting the tasks to be offloaded. In the present study, we will resolve these issues and improve the offloading performance by proposing a dynamic framework that considers both servers and users' standpoints. In particular, we are concerned with 1) Computation offloading to the mobile edge using the system utility of the MEC network to balance processing delay and energy consumption, 2) determining which part/module or process of a mobile application should be offloaded using deep reinforcement on-policy learning such as state-action-reward-state-action (SARSA), 3) determining where to offload the part/module or process in a multi-edge network, and 4) ensuring efficient resource management in the MEC servers.</p>
        <p>In this study, we address the question of developing an efficient resource management model for the selected MEC server in a multi-edge network by proposed an offloading decision-based SARSA method (OD-SARSA). Additionally, we consider the problem of managing mobility when the MDs move from one region to another. Accordingly, we should design and develop an efficient resource management model to enhance MEC server utilization through task scheduling and load balancing. As MEC suffers from limited computational resources, compared with central MCC, it becomes imperative to allocate these resources efficiently. The proposed resource allocation will enable meeting QoS requirements (e.g., latency) with minimal effort. Therefore, the main contributions of this study as follows:</p>
        <p>ÔÇ∑ We propose a MEC system model considering both computing time delay and power consumption, and we formulate it as an optimization problem. In particular, we propose an offloading decision-based SARSA (OD-SARSA) using reinforcement learning to make the optimal offloading decision for reducing system cost in terms of energy consumption and computing time delay. ÔÇ∑ We compared our proposed OD-SARSA with RL-QL and concluded that the former performs better than the latter. ÔÇ∑ We analyzed the effect of optimal offloading decision factors and reduced cost by changing the main parameters and analyzing the results, leading to real-world application.</p>
        <p>This paper is organized as follows. Section 2 reviews related work. Section 3 describes RL based on SARSA. Sections 4 describes the system model of MEC as a communication model, model of the task, and model of computation. Section 5 then describes the SARSA learning method based autonomic computation offloading. Finally, Section 6 presents the performance evaluation results and our conclusions.</p>
        <p>With the rapid advancement of communication technology, MEC is emerging as a promising technology. An MD uses remote execution (offloading) to enhance a mobile user's QoS by reducing energy consumption and increasing performance. We will focus on previous studies concerned with the offloading process (how and where to offload), the partition of mobile applications, and resource allocation, which affect offloading efficiency (performance) and energy consumption. Few studies have focused on computation offloading in MEC, although several options can be used on the MEC servers depending on the conditions of the mobile network. Thus, an efficient cloud-path selection method is required to select the best resource.</p>
        <p>Reducing execution time (ùëá) is one of the objectives of computation offloading in MEC. Execution time is the sum of local execution time (ùëá ùëô ) and remote execution time (ùëá ùëú ). The latter can be further divided into transmission delay to the ME (ùëá ùëúùëë ), processing time at the ME (ùëá ùëúùëù ), and receiving time from the ME (ùëá ùëúùëü ). An offloading decision is not taken unless ùëá ùëô &gt; ùëá ùëú . The aim is to minimize computation time, as discussed in [7]. This is achieved by using a one-dimensional search method, so that an effective offloading decision can be made depending on the queuing state buffer of the application, available energy in the MD and the MEC server, and the communication status between the MEC server and the MD. This algorithm was compared with greedy offloading, local execution, and cloud execution. The simulation demonstrated that execution time can be reduced by up to 81% and 44% as the arrival of the applications. The limitation of this method is that to make a decision, the MD as a client requires feedback from the MEC. In [8], the low-complexity Lyapunov optimization dynamic computation offloading algorithm was proposed. In [9], proposed system to leverage from the ability of computing and storage capacity available in the edge servers. In [10], a new computation offloading model in MEC was introduced. Its principle is to enable the use of virtual resources in the edge cloud to reduce resource and energy consumption and improve the performance of the application. In [11], the authors proposed a novel framework for computation offloading from an MD to an edge server considering CPU availability so that execution time may be reduced in both the MD and the server. In [12], an opportunistic computation offloading scheme was proposed for data mining in MDs and the edge network to reduce execution time and power consumption. In [12], the authors developed a distributed computation offloading algorithm that can attain a Nash equilibrium so that superior performance may be achieved, and user size may be reduced through server mode selection [5]. In [13], a computation offloading method to a small cell cloud was analyzed, and its performance was evaluated.</p>
        <p>Minimizing energy consumption (E) and achieving an acceptable execution time is one of the objectives of computation offloading in MEC. If an MD executes all computations locally, ùê∏ ùëô denotes the energy consumption; otherwise, the computation is carried out remotely by offloading to the edge. In this case, ùê∏ ùëú is the energy consumption and is the sum of the transmission energy to the ME (ùê∏ ùëúùëë ), the energy for processing at the ME (ùê∏ ùëúùëù ), and the energy for receiving the result from the edge (ùê∏ ùëúùëü ). The offloading decision is not made unless ùê∏ ùëô &gt; ùê∏ ùëú ùë§‚Ñéùëíùëõ ùëá ùëô &gt; ùëá ùëú when ùëá ùëô &gt; ùëá ùëú . In [14], the authors proposed computation offloading to reduce energy consumption in the MD when the computation time constraint is satisfied. A constrained Markov decision process was proposed to solve the optimization problem. The author of [15] proposed an energyefficient computation offloading algorithm in which the decision making is performed according to the following principles, 1) the MD considers its execution time and power consumption constraints, offloading to the ME is performed when the MD cannot satisfy the computation time constraint, and local execution is selected when the power depletion is below the determined threshold and the execution constraint is satisfied,2) the offloading priority is high. Third, given the radio resource allocation priorities, experiments demonstrated that this algorithm can reduce energy consumption by up to 15%. Using the cloud radio access network (C-RAN) service, the authors of [17] presented a computation offloading algorithm from mobile to remote cloud radio heads to reduce energy consumption and improve user QoE by minimizing the response time of the app. The Lyapunov optimization algorithm makes the offloading decision depending on the frequencies of the CPU-cycle for mobile execution and the transmission energy for computation offloading [8]. In [16], the authors designed an autonomous and energy-efficient offloading scheme that uses a mathematical model for the energy consumption at the ME for the mobile application, considering the energy consumed by the interaction among the tasks in the same application. In [17], the authors proposed a new game theoretic approach to enhance the edge computing throughput and reduce energy consumption on the edge server.</p>
        <p>In [20], it was proposed that the computation offloading decision should satisfy the trade-off between delay and energy consumption at the ME and UE. This study used the Nash equilibrium distributed computation offloading algorithm, in which the computation offloading decision depends on certain weight parameters, and the effective channel is chosen to transmit data. The numerical results demonstrated that this algorithm has superior performance when the application is computed at the MEC server rather than locally. In [18], the authors developed a code offloading model and decisionmaking process that reduce the application's response time and the MDs' energy consumption. The offloading decision is made based on the method of Lagrange multipliers, and a nonlinear optimization solver is used instead of solving a complex linear optimizing problem.</p>
        <p>Proper resource allocation should follow the decisionmaking regarding partial or full offloading. Resource allocation is influenced by the partitioned and paralleled computation offloading ability of the application. If offloading is impossible, then the partitioned and paralleled applications are allocated only one node for the computing. The number of offloaded applications to the ME should satisfy the computing time energy consumption requirements [19]. The application should determine where offloadable task should be placed, depending on the computing resources available at the ME. [20] is similar to [22]; however, it not only minimizes computation time but also reduces energy consumption at the ME. The authors propose several hotspots in the density area of the UEs, which enable the MDs to access the ME using the enhanced node B (eNB). The proposed efficient policy by equivalent discretion is called Markov decision processes (MDP). [21] is similar to [19] and [20], as the main objective is to reduce computation time and energy consumption, as well as reduce channel overload, resource consumption, and computation cost of virtual machine (VM) migration. In [21], the authors use enhanced small cells (SCeNBs) as service nodes at the ME, and each MD is allocated a VM at an SCeNB. This reduces the communication delay because the SNeNBs are characterized by high-quality data transmission.</p>
        <p>RL is a part of machine learning [22]. It consists of taking appropriate action to increase the reward in specific states.</p>
        <p>Various programs and machines/devices use it to find the best behavior or possible path in a given state. RL differs from supervised learning in that the learning data contain the answer key. Thus, in supervised learning, the model is trained on the correct answer itself, whereas in RL, there is no answer, but the reinforcement agent determines how a certain task is to be carried out. When a dataset is not available, learning is performed through experience. The basic principle of RL is the following: The input must be an initial state from which the models start. The output consists of several potential results because there are several solutions to a specific To do this, we use temporal-difference (TD) to update the rule applied at every timestamp by allowing the agent to transition from one pair of state-action to another pair.</p>
        <p>To solve complex, large state-space problems, the deep SARSA function is updated as</p>
        <p>where ùëÑ(ùëÜ ùë° , ùê¥ ùë° ) is the value of Q for the action ùê¥ in system state ùëÜ at time ùë°, ùëÖ(ùëÜ ùë° , ùê¥ ùë° ) is the reward when the agent selects the action ùê¥ ùë° at state ùëÜ ùë° , and ùõæ denotes the discount factor; the epsilon-greedy policy is used to select the best action ùê¥ ùë°+1 in the current state ùëÜ ùë°+1 .</p>
        <p>Numerous traditional reinforcement learning models have been used for computation offloading. For example, in [24], an RL technique was used for complicated video games, and several different RL approaches, such as SARSA learning, Q learning, GQ , actor-critic, and R learning, were compared. The results are shown in Table I, which is reproduced from that paper and shows that the SARSA outperforms other RL algorithms, as it obtained the greatest rewards.</p>
        <p>where ùõº ‚àà (0,1] is a discount factor, and ùëü ùë° is the reward when action ùëé is taken at time ùë°. When the agent takes the action ùëé under the policy ùúã in state ùëÜ at the time ùë°, denoted by ùëÑ ùúã (ùë†, ùëé). Thus,</p>
        <p>where ùê∏ is the expected reward, and ùúã is the policy function for the action ùê¥ ùë° . The aim of the training task is to acquire the maximum rewards and obtain the optimal state and action of ùëÑ ùúã (ùë†, ùëé). There are two methods in RL. One is called Qlearning, and the other SARSA [26]. In this study, we will use SARSA, as it has been demonstrated that this method can select a safe path . This is considered appropriate in the present study, which is concerned with the selection of an optimal and safe path for offloading intensive tasks to the edge cloud.</p>
        <p>SARSA is an on-policy technique, that is, the next action ùëé * depends on the value of the current state ùë† ùë° and current action ùëé ùë° . The equation for updating state and action values is</p>
        <p>In SARSA learning, the training task is a quinary(ùë†, ùëé, ùëü, ùë† * , ùëé * ), which is updated sequentially.</p>
        <p>The mobile edge system (MES) model is shown in Fig. 2. MES is constructed on a telecommunication infrastructure, such as BS/LTE. The MDs (e.g., smartphones, tablets, robots, and drones) connect to the edge computing control at the BS/LTE in the adjacent location (region) to the computation offloading. The edge computing controller in each region manages multi-edge mobile computing, receives the offloaded tasks from the MDs, and chooses an effective edge node to address them as a task model. In the mobility status, when an MD moves from one region to another, the processing results of the offloaded tasks are sent to the corresponding MD over the central edge cloud-computing controller (CE3C) and edgecomputing controller for the adjacent region. The components of the edge network have high storage and computation capabilities, which are used to create a virtual server offering mobile edge services as a computing model. If a workload demands resources beyond what the edge server can support, the request is redirected over the main network (CE3C) to the cloud services on the other side of the network as the resource management model.</p>
        <p>We assume that there are MEC networks (MECNs) in more than one region, as shown in Fig. 2 The communication bandwidths between MDs and offloading location are denoted by ùêµ ùëí , ùêµ ùëé , ùêµ ùëê , which represent edge server bandwidth, adjacent edge server bandwidth, and cloud bandwidth, respectively, as the end-to-end bandwidth. Moreover, the total communication delay for a certain MD is denoted by ùëá ùëõ . Additionally, ùëù ùëõ ùë° represents the power consumption for task transmission, and ùëù ùëõ ùëü the receiving power consumption. Therefore, depending on certain parameters such as edge servers' workloads, response time, or latency and energy consumption, the MD should find an efficient location (nearest the edge server or adjacent to the edge server or remote cloud) to offload its tasks. Eventually, after the offloading process to the nearest edge server or adjacent edge server has been completed, an efficient resource allocation method is required on the edge server.</p>
        <p>We assume that each MD has ùë¥ independent massive realtime tasks, which can be executed locally in the MD or remotely in the MEC network by the computation offloading. Therefore, tasks cannot be partitioned into subtasks to be processed in multiple devices [27]. Task size is denoted by ùë´ ùíè (transferred data size), and ùëπ ùíè denotes the computation resources required to serve this task (CPU cycles number). Therefore, ùë´ ùíè and ùëπ ùíè are positively related:</p>
        <p>Regardless of whether the task is executed locally by the MD or in the MEC network, ùë´ ùíè does not change.</p>
        <p>When the decision unit decides to process a task in the MD (ùëø ùíè = ùüé), the time processing per task is denoted by ùëª ùíç . This includes the computing delay of the local CPU. Therefore, the processing time is</p>
        <p>Similarly, the corresponding power consumption for task ùë¥ ùíè of user ùíè is denoted by ùë∑ ùíç and is defined as</p>
        <p>where ùëù ùëô denotes the power consumption when the task is processed in the MD. Therefore, the cost of local processing is the combination of the local processing time and local power consumption:</p>
        <p>where ùõº and ùõΩ are constant weighting parameters corresponding to the time and power cost of the task.</p>
        <p>When the decision unit decides to offload the task to an edge server (ùëø ùíè = ùüè), the time processing per task is denoted by ùëª ùíÜ . This includes the transmission delay and computing delay.</p>
        <p>The computing delay depends on the CPU frequency of the edge server and other resources. Therefore, the processing time is</p>
        <p>where ùìï ùíÜ and ùìë ùíè denote the CPU frequency of the edge server and the communication bandwidth, respectively. Similarly, the corresponding power cost for task ùë¥ ùíè of user ùíè is denoted by ùíë ùíÜ and is defined as</p>
        <p>Therefore, the processing cost of edge computing is the combination of edge computing time and power consumption, as follows:</p>
        <p>When the decision unit decides to offload a task to an adjacent edge server (ùëã ùëõ = 2), the time processing per task is denoted by ùëá ùëé . This include the transmission delay and computing delay. The computing delay depend on the CPU frequency of the adjacent edge server and other resources. Therefore, the processing time is</p>
        <p>where ‚Ñ± ùëé and ‚Ñ¨ ùëõ represents the CPU frequency of the adjacent edge server and communication bandwidth, respectively. Similarly, the corresponding power cost for task ùëÄ ùëõ of user ùëõ is denoted by ùëù ùëé and is defined as</p>
        <p>Therefore, the processing cost of an adjacent edge computing server is the combination the corresponding computing time and power consumption, as follows:</p>
        <p>When it is decided to offload a task to the remote cloud server (ùëã ùëõ = 3), the time processing per task is denoted by ùëá ùëê . This includes the transmission delay and the computing delay. The former corresponds to two directions: from the ùëÄùê∑ to the edge server or adjacent edge server (ùëá ùëö,ùëí ùëúùëü ùëá ùëö,ùëé ), and from the edge server to the remote cloud (ùëá ùëí,ùëê ùëúùëü ùëá ùëé,ùëê ). We assume that ùëá ùëö,ùëí and ùëá ùëö,a are similar, and thus we neglect one of them. The computing delay depends on the CPU frequency of the assigned remote server and other resources. We can compute the task processing time in the cloud by the following equation, as in [28]:</p>
        <p>where ‚Ñ± ùëê denotes the CPU frequency for processing in the cloud for each user. The total time cost involving the processing and transmission delay is:</p>
        <p>Similarly, the corresponding power cost for task ùëÄ ùëõ of user ùëõ is denoted by ùëù ùëê and is defined as</p>
        <p>Therefore, the processing cost of a remote cloud server is the combination of computing time and power consumption, as follows:</p>
        <p>The total cost ùê∂ ùë°ùëúùë°ùëéùëô of the MEC offloading system can expressed as</p>
        <p>We assume that there are five MDs in the network. MDs 1 and 5 choose to execute tasks locally, that is, ùëã ùëõ = 0, MD chooses to offload tasks to the edge point, that is, ùëã ùëõ = 1, MD 3 chooses to offload tasks to an adjacent edge, that is, ùëã ùëõ = 2, and MD 4 chooses to offload tasks to the remote cloud server, that is, ùëã ùëõ = 3. We use formula (14) to calculate the computing time and power consumption, that is, ùê∂ ùë°ùëúùë°ùëéùëô = ùê∂ ùëõ ùëô + ùê∂ ùëõ ùëí + ùê∂ ùëõ ùëé +ùê∂ ùëõ ùëê . The notations used in this study are defined in Table II.</p>
        <p>Our objective to minimize processing and transmission delay and reduce the power consumption for these two operations. The minimized cost is denoted by ùëÑ ùëöùëñùëõ . We assume that the transmission and receiving bandwidth are equal ùõΩ ùëõ ùë° = ùõΩ ùëõ ùëü . The optimization problem of system utilization is formulated as follows:</p>
        <p>where</p>
        <p>ùëã ùëõ = {ùëã 1 , ùëã 2 , ‚Ä¶ , ùëã ùëõ } is the offloading decision; it has four modes and takes four values: 0, 1, 2, and 3. Additionally, the bandwidth is limited by constraint ( 16) on transmission tasks and receiving results to prevent congestion on the server, which may cause significant delays. The optimization problem ( 15) is considered a mixed-integer problem, which is generally difficult to solve. To minimize the system utilization cost, we propose a reinforcement learning technique based on deep SARSA.</p>
        <p>We assume that there multiple options for executing an offloadable task at the nearest edge, at an adjacent edge, or in the remote cloud. To determine the optimal location, we used deep reinforcement learning (SARSA). Thus, the performance of the edge server (ES) depends on the resource allocation mechanism and improves the simultaneous execution of tasks. However, the scheduling and resource allocation on the edge server are NP-hard scheduling problems. Most current studies use game theory and reinforcement learning. Therefore, we will develop an efficient resource allocation mechanism to enhance MEC server utilization owing to the limited power and computational resources compared with cloud-computing servers. In our mechanism, the offloading decision algorithm (OD-SARSA) will be used for solving the resource management problem on the ES based on parameters derived from its environment, such as data size, bandwidth, edgeserver workload, signal strength, and energy consumption. OD-SARSA is an effective method to achieve high utilization on the ES, owing to its ability to function as an on-policy technique, that is, it considers the current resource consumption state in the ES environment, which is highly important for resource management. For example, the current state obtained from the SARSA algorithm is used to determine whether current VMs should be employed or new VMs should be created on the ES. In the latter case, the VM manager on the ES is responsible for creating the VMs and assigns VMs to each offloaded task. One approach for the VM manager could be to activate VMs only on a few servers, depending on the offloaded tasks, whereas the other servers are put into sleep Combined cost for computing time and power consumption mode to save energy. However, the VM manager should also consider the users' latency requirements, as the servers may be overload with many offloaded tasks, resulting in a load balancing issue. This will be more challenging when there is uncertainty in task arrival, and there is no central controller.</p>
        <p>We should solve the optimization problem (19) and meet the QoS (e.g., energy consumption, or delay) requirements so that a deep SARSA function may be used to make an efficient decision ùëã ùëõùëö for offloading of each task to the appropriate location . The input of the SARSA function is the uploading bandwidth ùõΩ ùëõùëö ùë° and downloading bandwidth ùõΩ ùëõùëö ùëü as states.</p>
        <p>The output of the system is the value of ùëÑ for each state ùëÜ ùë° of the corresponding action ùê¥ ùë° . Each time, the agent selects the suitable action with regard to the Q value. The result of the action is to make identical adjustment to the offloading decision ùëã ùëõùëö and determine the appropriate location (nearest to the edge server or adjacent to the edge server or remote cloud), as well as resource allocation ùõΩ ùëõùëö ùë° and ùõΩ ùëõùëö ùëü .</p>
        <p>The SARSA function considers an on-policy mechanism, which implies that the agent learns based on its up-to-date action as a consequence of the current policy. OD-SARSA is described in Algorithm 1. It performs offloading and is trained through deep leaning. In SARSA, an epsilon-greedy policy is used for state transition; the Q value in the preceding state is updated by Equation (15), where the next action is selected by an epsilon-greedy policy. In the system, there are a target network and an evaluation network. The input system is the current state, and the following or next state are obtained after the selection of an action. We can choose the action based on the epsilon greedy (ùúÄ) policy. We use a probability of 1 -ùúÄ and select the best action, and thus the output of the target network is changed according to the reward, and the parameters are updated in each state, and a new policy is imposed.</p>
        <p>Therefore, the actions ùëé of the agent can be defined as offloading to valid locations (nearest, adjacent, and remote). We assume 10 possible actions, as a follows: ùê¥ ùëô is local processing, ùê¥ ùëÅ is offloading to the nearest edge, ùê¥ ùëé is offloading to an adjacent edge, ùê¥ ùëÖ is offloading to the remote cloud, ùê¥ ùëÅùê¥ is migration from the nearest edge to an adjacent edge, ùê¥ ùê¥ùëÅ is migration from an adjacent edge to the nearest edge, ùê¥ ùëÅùëÖ is migration from the nearest edge to the remote cloud, ùê¥ ùëÖùëÅ is migration from the remote cloud to the nearest edge, ùê¥ ùê¥ùëÖ is migration from an adjacent edge to the remote cloud, and ùê¥ ùê¥ùëÖ is migration from the remote cloud to an adjacent edge. Thus, the actions of the agent can be represented as ùê¥(ùë°) = {ùê¥ 1 (ùë°), ùê¥ 2 (ùë°) ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ùê¥ ùëò (ùë°) }, where ùê¥ ùëò (ùë°) denotes the ùëò-th offloading decision. If ùê¥ ùëò (ùë°) = 0, the task is processed locally, if ùê¥ ùëò (ùë°) = 1 , the task is offloadable and processed on the edge server, if ùê¥ ùëò (ùë°) = 2, task is executed at the adjacent node, and if the ùê¥ ùëò (ùë°) = 3, the task is processed on the remote server. The agent learning state ùëÜ can be defined as the resources of the edge computing: processing (ùëÜ ùëù ), memory (ùëÜ ùëö ), and network bandwidth (ùëÜ ùëè ). Thus, the current system state can be represented as (ùë°) = {ùëÜ 1 (ùë°), ùëÜ 2 (ùë°) ‚Ä¶ ‚Ä¶ ùëÜ ùëõ (ùë°) } , where ùëÜ ùëñ = (ùëÜ ùëùùëñ , ùëÜ ùëöùëñ , ùëÜ ùëèùëñ ) , ùëñ = 1 ‚Ä¶ ‚Ä¶ ùëõ.</p>
        <p>In this system, a particular learning agent does not have information regarding the overall state of all nearest edges; the agent only has information regarding its local state. There is collaboration and communication between the agents to offload tasks to appropriate locations at the edge network (nearest or adjacent edge) or in a public cloud.</p>
        <p>Reward function: The main objective of computation offloading is to reduce the processing delay of intensive tasks. This primarily depends on the capability of the edge network, that is, processing, memory, and bandwidth. CE3C determines its processing capability by detecting its state, estimates the response time, and chooses the appropriate location accordingly. After an action is performed, result ùëÜ(ùë°) is obtained. If ùëÜ(ùë°) is smaller than ùëÜ(ùë° -1), a positive reward ùëÖ(ùë°) = +1 is given. If ùëÜ ùë° is larger than ùëÜ ùë°+1 , we give a negative reward ùëÖ(ùë°) = -1; otherwise, ùëÖ(ùë°) = 0. The reward allows the agent to learn efficient decision making for resource allocation and offloading for reduced energy consumption.</p>
        <p>The value of Q for a given state and action should be as close to the right-hand of the Bellman equation as possible so that the Q-value will finally converge to a safe value ùëû * .</p>
        <p>ùëû * (ùë† ùë°+1 , ùëé ùë°+1 ) -ùëû(ùë†, ùëé) &lt; 0 , system state; non -offloading (22)</p>
        <p>The method for computing the new value of Q for the state and action pair (s, a) at a certain time is</p>
        <p>We will now evaluate the proposed OD-SARSA algorithm.</p>
        <p>The model uses ùëÅ task of ùëÄ users to determine if the best action at a given time is to offload or not (local processing). We give data sizes as input and output for each user. We aim to find an optimal policy offloading function œÄ. The offloading size can by expressed by ùëÅùëÄ, which increase with the number of tasks ùëÄ per user ùëÅ in MEC networks. We assume that the number of mobile users is ùëÅ = 5, and each user has five tasks. Table 1 shows all parameters that are used in reinforcement learning. We set the local processing time for an MD to 3.75 √ó 10 -7 ùë†/ùëèùëñt, and the corresponding power consumption to 3.55 √ó 10 -6 J/bit. We assume that the size of all tasks is distributed between 10 and 35 MB. Regarding the other network parameters, such as bandwidth, we assume that the bandwidth for both uplink and downlink between a user and an edge server is 150 MB and may change depending on network conditions. The rate of the CPU of an edge sever is 9 √ó 10 8 cycle/s. The MDs' transmission and receiving energy consumption are both 1.60 √ó 10 -6 J/bit. We train the model using 100 episodes.</p>
        <p>There is close similarity between Q-learning and SARSA, but SARSA uses an on-policy technique. This encouraged us to use it for improved offloading performance to the ES, particularly because it does not depend on explicitly learning the agent's policy function. The results are shown in Fig. 3 and demonstrate that SARSA outperforms Q-learning, with an improvement rate of up to 8%. When the number of iterations increases, the improvement increases as well. It is noted that QL is better than SARSA in a faster training scenario (when the number of iterations is less than 50), but for more than 60 iterations, SARSA is consistently better than QL. We can conclude for increased the training iterations, the gap between SARSA and Q widens, with increased gain rewards. This affects performance in favor of the SARSA method.</p>
        <p>The system utility under the different parameters ùõæ and Œº, which denote learning rate and weight rate respectively, are shown in Fig. 4 by comparing the proposed OD-SARSA with other algorithms: Q-learning, edge processing, and local processing. The results indicate the superiority of OD-SARSA to the other algorithms. The main problem with deep learning modules is choosing a learning rate and optimizer (the hyperparameters). Therefore, we study our algorithm under different learning rates. After 100 iterations, we notice that a learning rate of 0.001 is stable and appropriate for the proposed method (Fig. 5). In contrast, the results for other values are unstable, and large dispersion are observed, particularly when LR = 0.01.</p>
        <p>Based on the comparison between various different learning rates, we studied the performance cost corresponding to 0.001 and 0.0001. We notice that the total cost of DO-SARS for a learning rate of 0.001 is significantly lower than that for 0.0001 (Fig. 6). At the beginning of the training, we notice that the gap is large owing to the increased performance cost. Nevertheless, as iterations increase, this gap decreases, and the costs are equal in the last iteration.</p>
        <p>We observe that Q-learning correctly selects the optimal path in several applications, but it occasionally fails in critical stages, which require an important and critical decision, owing to the ùúÄ-greedy action selection. In our study, we demonstrated that SARS is better at making decisions in critical situations, as it is considered stable, particularly because it learns the safe path. This is highly important in making critical decisions. To attain better results in practice with on-policy RL techniques, the epsilon parameter should be reduced over time. Fig. 7 shows the effect of varying epsilon on the offloading decision. We notice that when ùúÄ = 0.80, we obtain satisfactory results, and maximum rewards are achieved; thus, this value was adopted in this study. Degenerate levels (0.20: 75) of course yield suboptimal results. It is conceivable that this caused by the short timescale the agent actions.</p>
        <p>The result of the optimization problem (eq. 19) is shown in Fig. 8, where the number of offloadable and non-offloadable tasks can be seen. We notice that as the training iterations increase, the "offloadable" decisions increase, regardless of the offloading location (edge server, adjacent edge server, or a remote server). At the beginning of the training, the difference between these numbers is small, but subsequently, it gradually increases.</p>
        <p>In this paper, we assumed that there are MECNs in more than one region, consisting of multiple APs, multi-edge servers, and ùëÅ MDs, where each MD has independent massive realtime tasks. The MD can connect to an MECN through an AP or a mobile network. Each task can be processed locally by the MD itself or remotely. There are three offloading options: nearest edge server, adjacent edge server, and remote cloud. We propose a reinforcement-learning-based SARSA method to solve the optimization problem for making decisions regarding offloading to one of the previously mentioned locations to reduce system cost, including energy consumption and computing time delay. It was demonstrated that on this problem, OD-SARSA performed better than RL-QL. Therefore, in offloading to adjacent edge servers, the proposed method resolves most challenges faced by CPSSs and achieves optimal results in terms of volume, variety, velocity, and veracity. In future, we will consider the code offloading on edge devices with GPUs that connected with mobile devices.</p>
        <p>VOLUME XX,2017</p>
        <p>This work is supported by the Deanship of Scientific Research at King Saud University through the Vice Deanship of Scientific Research Chairs. Chair of Smart Technologies. The authors also thank the RSSU at King Saud University for their technical support.</p>
    </text>
</tei>
