<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc xml:id="_1"/>
        <encodingDesc>
            <appInfo>
                <application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-06-13T16:17+0000">
                    <ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
                </application>
            </appInfo>
        </encodingDesc>
    </teiHeader>
    <text xml:lang="en">
        <p>Stencil computations are a key part of many high-performance computing applications, such as image processing, convolutional neural networks, and finite-difference solvers for partial differential equations. 
            <rs type="software">Devito</rs> is a framework capable of generating highly-optimized code given symbolic equations expressed in Python, specialized in, but not limited to, affine (stencil) codes. The lowering process-from mathematical equations down to C++ code-is performed by the 
            <rs type="software">Devito</rs> compiler through a series of intermediate representations.
        </p>
        <p>Several performance optimizations are introduced, including advanced common sub-expressions elimination, tiling and parallelization. Some of these are obtained through well-established stencil optimizers, integrated in the back-end of the 
            <rs type="software">Devito</rs> compiler. The architecture of the 
            <rs type="software">Devito</rs> compiler, as well as the performance optimizations that are applied when generating code, are presented. The effectiveness of such performance optimizations is demonstrated using operators drawn from seismic imaging applications.
        </p>
        <p>platforms. 
            <rs type="software">Devito</rs> also performs high-level transformations for floating-point operation (FLOP) reduction based on symbolic manipulation, as well as loop-level optimizations as implemented in Devito's own optimizer, or using a third-party stencil compiler such as 
            <rs type="software">YASK</rs> [42]. The 
            <rs type="software">Devito</rs> compiler is presented in detail in Sections 4, 5, and 6.
        </p>
        <p>After the presentation of the Devito compiler, we show test cases in Section 7 that are inspired by real-world seismic-imaging problems. The paper finishes with directions for future work and conclusions in Sections 8 and 9.After the presentation of the Devito compiler, we show test cases in Section 7 that are inspired by real-world seismic-imaging problems. The paper finishes with directions for future work and conclusions in Sections 8 and 9.</p>
        <p>The objective of maximizing productivity and performance through frameworks based upon DSLs has long been pursued. In addition to well-known systems such as 
            <rs type="software">Mathematica</rs> ® and 
            <rs type="software">Matlab</rs> ® , which span broad mathematical areas, there is a number of tools specialized in numerical methods for PDEs, some dating back to the 1970s [6,7,36,37].
        </p>
        <p>One noteworthy contemporary framework centered on DSLs is FEniCS [23], which allows the specification of weak variational forms, via UFL [2], and finite-element methods, through a highlevel syntax. Firedrake [31] implements the same languages as FEniCS, although it differs from it in a number of features and architectural choices. Devito is heavily influenced by these two successful projects, in particular by their philosophy and design. Since solving a PDE is often a small step of a larger workflow, the choice of Python to implement this software provides access to a wide ecosystem of scientific packages. Firedrake also follows the principle of graceful degradation, by providing a very simple lower-level API to escape the abstraction when non-standard calculations (i.e., unrelated to the finite-element formulation) are required. Likewise, Devito allows injecting arbitrary expressions into the finite-difference specification; this feature has been used in real-life cases, for example for interpolation in seismic imaging operators. On the other hand, a major difference is that Devito lacks a formal specification language such us UFL in FEniCS/Firedrake. This is partly because there is no systematic foundation underpinning FD, as opposed to FE which relies upon the theory of Hilbert spaces [5]. Yet another distinction is that, for performance reasons, Devito takes control of the time-stepping loop. Other examples of embedded DSLs are provided by the OpenFOAM project, with a language for FV [14], and by 
            <rs type="software">PyFR</rs>, which targets flux reconstruction methods [38].
        </p>
        <p>Due to its simplicity, the FD method has been the subject of multiple research projects, chiefly targeting the design of effective software abstraction and/or the generation of high performance code [3,15,17,22]. Devito distinguishes itself from previous work in a number of ways, including support for the principle of graceful degradation for when the DSL does not cover a feature required by an application; incorporation of a symbolic mathematics engine; using actual compiler technology rather than template-based code generation; and adoption of a native Python 
            <rs type="software">interface</rs> that naturally allows composition into complex workflows such as optimization and machinelearning frameworks.
        </p>
        <p>At a lower level of abstraction there are a number of tools targeting "stencil" computation (FD codes belong to this class), whose major objective is the generation of efficient code. Some of them provide a DSL [30,32,42,44], whereas others are compilers or user-driven code generation systems, often based upon a polyhedral model, such as [4,19]. From the Devito standpoint, the aim is to harness these tools-for example by integrating them-to maximize performance portability. As a proof of concept, we shall discuss the integration of one such tool, namely YASK [42], with Devito.At a lower level of abstraction there are a number of tools targeting "stencil" computation (FD codes belong to this class), whose major objective is the generation of efficient code. Some of them provide a DSL [30,32,42,44], whereas others are compilers or user-driven code generation systems, often based upon a polyhedral model, such as [4,19]. From the Devito standpoint, the aim is to harness these tools-for example by integrating them-to maximize performance portability. As a proof of concept, we shall discuss the integration of one such tool, namely YASK [42], with Devito.</p>
        <p>Devito is a general purpose system, not restricted to specific PDEs, so it can be used for any form of the wave equation. Thus, unlike software specialized in seismic exploration, like 
            <rs type="software">IWAVE</rs> [33] and 
            <rs type="software">Madagascar</rs> [13], it suffers neither from the restriction to a small set of wave equations and discretizations, nor from the lack of portability and composability typical of a pure C/Fortran environment.
        </p>
        <p>The 
            <rs type="software">Devito</rs> compiler can introduce three types of performance optimizations: FLOP reduction, data locality, and parallelism. Typical FLOP reduction transformations are common sub-expressions elimination, factorization, and code motion. A thorough review is provided in [11]. 
            <rs type="software">Devito</rs> applies all of these techniques (see Section 5.1). Particularly relevant for stencil computation is the search for redundancies across consecutive loop iterations [9,10,21]. This is at the core of the strategy described in Section 6, which essentially extends these ideas with optimizations for data locality. Typical loop transformations for parallelism and data locality [18] are also automatically introduced by the 
            <rs type="software">Devito</rs> compiler (e.g., loop blocking, vectorization); more details will be provided in Sections 5.2 and 5.3.
        </p>
        <p>The Devito DSL allows concise expression of FD and general stencil operations using a mathematical notation. It uses 
            <rs type="software">SymPy</rs> [28] for the specification and manipulation of stencil expressions. In this section, we describe the use of Devito's DSL to build PDE solvers. Although the examples used here are for FD, the DSL can describe a large class of operations, such as convolutions or basic linear algebra operations (e.g., chained tensor multiplications).
        </p>
        <p>The key steps to implement a numerical kernel with Devito are shown in Figure 1. We describe this workflow, as well as fundamental features of the Devito API, using the acoustic wave equation, also known as d'Alembertian or Box operator. Its continuous form is given by:The key steps to implement a numerical kernel with Devito are shown in Figure 1. We describe this workflow, as well as fundamental features of the Devito API, using the acoustic wave equation, also known as d'Alembertian or Box operator. Its continuous form is given by:</p>
        <p>where the variables of this expression are defined as follows:where the variables of this expression are defined as follows:</p>
        <p>is the parametrization of the subsurface with c(x, y, z) being the speed of sound as a function of the three space coordinates (x, y, z); • u(x, y, z, t), is the spatially varying acoustic wavefield, with the additional dimension of time t; • q s is the source term, which is a point source in this case.is the parametrization of the subsurface with c(x, y, z) being the speed of sound as a function of the three space coordinates (x, y, z); • u(x, y, z, t), is the spatially varying acoustic wavefield, with the additional dimension of time t; • q s is the source term, which is a point source in this case.</p>
        <p>The first step towards solving this equation is the definition of a discrete computational grid on which the model parameters, wavefields, and source are defined. The computational grid is defined as a Grid(shape) object, where shape is the number of grid points in each spatial dimension. Optional arguments for instantiating a Grid are extent, which defines the extent in physical units, and origin, the origin of the coordinate system, with respect to which all other coordinates are defined.The first step towards solving this equation is the definition of a discrete computational grid on which the model parameters, wavefields, and source are defined. The computational grid is defined as a Grid(shape) object, where shape is the number of grid points in each spatial dimension. Optional arguments for instantiating a Grid are extent, which defines the extent in physical units, and origin, the origin of the coordinate system, with respect to which all other coordinates are defined.</p>
        <p>The next step is the symbolic definition of the squared slowness, wavefield, and source. For this, we introduce some fundamental types.The next step is the symbolic definition of the squared slowness, wavefield, and source. For this, we introduce some fundamental types.</p>
        <p>• Function represents a discrete spatially varying function, such as the velocity. A Function is instantiated for a defined name and a given Grid. • TimeFunction represents a discrete function that is both spatially varying and time dependent, such as wavefields. Again, a TimeFunction object is defined on an existing Grid and is identified by its name. • SparseFunction and SparseTimeFunction represent sparse functions, that is functions that are only defined over a subset of the grid, such as a seismic point source. The corresponding object is defined on a Grid, identified by a name, and also requires the coordinates defining the location of the sparse points. Apart from the grid information, these objects carry their respective FD discretization information in space and time. They also have a data field that contains values of the respective function at the defined grid points. By default, data is initialized with zeros and therefore automatically satisfies the initial conditions from Equation 1. The initialization of the fields to solve the wave equation over a one-dimensional grid is displayed in Listing 1.• Function represents a discrete spatially varying function, such as the velocity. A Function is instantiated for a defined name and a given Grid. • TimeFunction represents a discrete function that is both spatially varying and time dependent, such as wavefields. Again, a TimeFunction object is defined on an existing Grid and is identified by its name. • SparseFunction and SparseTimeFunction represent sparse functions, that is functions that are only defined over a subset of the grid, such as a seismic point source. The corresponding object is defined on a Grid, identified by a name, and also requires the coordinates defining the location of the sparse points. Apart from the grid information, these objects carry their respective FD discretization information in space and time. They also have a data field that contains values of the respective function at the defined grid points. By default, data is initialized with zeros and therefore automatically satisfies the initial conditions from Equation 1. The initialization of the fields to solve the wave equation over a one-dimensional grid is displayed in Listing 1.</p>
        <p>&gt;&gt;&gt; from devito import Grid , TimeFunction , Function , SparseTimeFunction &gt;&gt;&gt; g = Grid ( shape =( nx ,) , origin =( ox ,) , extent =( sx ,) ) &gt;&gt;&gt; u = TimeFunction ( name =" u", grid =g , space_order =2 , time_order =2) # Wavefield &gt;&gt;&gt; m = Function ( name =" m", grid =g) # Physical parameter &gt;&gt;&gt; q = SparseTimeFunction ( name =" q", grid =g , coordinates = coordinates ) # Source Listing 1. Setup Functions to express and solve the acoustic wave equation.&gt;&gt;&gt; from devito import Grid , TimeFunction , Function , SparseTimeFunction &gt;&gt;&gt; g = Grid ( shape =( nx ,) , origin =( ox ,) , extent =( sx ,) ) &gt;&gt;&gt; u = TimeFunction ( name =" u", grid =g , space_order =2 , time_order =2) # Wavefield &gt;&gt;&gt; m = Function ( name =" m", grid =g) # Physical parameter &gt;&gt;&gt; q = SparseTimeFunction ( name =" q", grid =g , coordinates = coordinates ) # Source Listing 1. Setup Functions to express and solve the acoustic wave equation.</p>
        <p>With symbolic objects that represent the discrete velocity model, wavefields, and source function, we can now define the full discretized wave equation. As mentioned earlier, one of the main features of Devito is the possibility to formulate stencil computations as concise mathematical expressions.With symbolic objects that represent the discrete velocity model, wavefields, and source function, we can now define the full discretized wave equation. As mentioned earlier, one of the main features of Devito is the possibility to formulate stencil computations as concise mathematical expressions.</p>
        <p>To do so, we provide shortcuts to classic FD stencils, as well as the functions to define arbitrary stencils. The shortcuts are accessed as object properties and are supported by TimeFunction and Function objects. For example, we can take spatial and temporal derivatives of the wavefield u via the shorthand expressions u.dx and u.dt (Listing 2).To do so, we provide shortcuts to classic FD stencils, as well as the functions to define arbitrary stencils. The shortcuts are accessed as object properties and are supported by TimeFunction and Function objects. For example, we can take spatial and temporal derivatives of the wavefield u via the shorthand expressions u.dx and u.dt (Listing 2).</p>
        <p>Listing 2. Example of spatial and temporal FD stencil creation.Listing 2. Example of spatial and temporal FD stencil creation.</p>
        <p>Furthermore, 
            <rs type="software">Devito</rs> provides shortcuts for common differential operations such as the Laplacian via u.laplace. The full discrete wave equation can then be implemented in a single line of Python (Listing 3).
        </p>
        <p>Listing 3. Expressing the wave equation.Listing 3. Expressing the wave equation.</p>
        <p>To solve the time-dependent wave equation with an explicit time-stepping scheme, the symbolic expression representing our PDE has to be rearranged such that it yields an update rule for the wavefield u at the next time step: u(t + dt) = f (u(t), u(tdt))). Devito allows to rearrange the PDE expression automatically using the solve function, as shown in Listing 4.To solve the time-dependent wave equation with an explicit time-stepping scheme, the symbolic expression representing our PDE has to be rearranged such that it yields an update rule for the wavefield u at the next time step: u(t + dt) = f (u(t), u(tdt))). Devito allows to rearrange the PDE expression automatically using the solve function, as shown in Listing 4.</p>
        <p>&gt;&gt;&gt; from devito import Eq , INTERIOR , solve &gt;&gt;&gt; stencil = Eq ( u . forward , solve ( wave_equation , u . forward ) , region = INTERIOR ) &gt;&gt;&gt; stencil Eq (u( t + dt , x ) , - Listing 4. Time-stepping scheme for the acoustic wave equation. region=INTERIOR ensures that the Dirichlet boundary conditions at the edges of the Grid are satisfied.&gt;&gt;&gt; from devito import Eq , INTERIOR , solve &gt;&gt;&gt; stencil = Eq ( u . forward , solve ( wave_equation , u . forward ) , region = INTERIOR ) &gt;&gt;&gt; stencil Eq (u( t + dt , x ) , - Listing 4. Time-stepping scheme for the acoustic wave equation. region=INTERIOR ensures that the Dirichlet boundary conditions at the edges of the Grid are satisfied.</p>
        <p>Note that the stencil expression in Listing 4 does not yet contain the point source q. This could be included as a regular Function which has zeros all over the grid except for a few points, but it would obviously be wasteful. Instead, SparseFunctions allow to perform operations, such as injecting a source or sampling the wavefield, at a subset of points determined by coordinates. In general, receivers (where the solution is to sampled) are not co-located with grid points. Therefore, an interpolation operator is needed (e.g. trilinear interpolation for 3D). To ensure a consistent discrete adjoint, source terms are implemented as the adjoint of the interpolation operator used, that is the gather operation for interpolation becomes a scatter operation for source injection. Equation 2 gives the expressions for linear interpolation in 1D assuming the origin is zero for readability.Note that the stencil expression in Listing 4 does not yet contain the point source q. This could be included as a regular Function which has zeros all over the grid except for a few points, but it would obviously be wasteful. Instead, SparseFunctions allow to perform operations, such as injecting a source or sampling the wavefield, at a subset of points determined by coordinates. In general, receivers (where the solution is to sampled) are not co-located with grid points. Therefore, an interpolation operator is needed (e.g. trilinear interpolation for 3D). To ensure a consistent discrete adjoint, source terms are implemented as the adjoint of the interpolation operator used, that is the gather operation for interpolation becomes a scatter operation for source injection. Equation 2 gives the expressions for linear interpolation in 1D assuming the origin is zero for readability.</p>
        <p>Find the two closest indices:Find the two closest indices:</p>
        <p>To inject a point source defined at the physical location q_coords into the stencil expression, we use the inject function of the SparseTimeFunction object that represents our seismic source (Listing 5). Listing 5. Expressing the injection of a source into a field.To inject a point source defined at the physical location q_coords into the stencil expression, we use the inject function of the SparseTimeFunction object that represents our seismic source (Listing 5). Listing 5. Expressing the injection of a source into a field.</p>
        <p>The inject function takes the field being updated as an input argument (in this case u.forward), while expr=dt**2 * q / m is the expression being injected. The result of the inject function is a list of symbolic expressions that correspond to the different steps of Equation 2. As we shall see, these expressions are eventually joined together and used to create an Operator object-the solver of our PDE.The inject function takes the field being updated as an input argument (in this case u.forward), while expr=dt**2 * q / m is the expression being injected. The result of the inject function is a list of symbolic expressions that correspond to the different steps of Equation 2. As we shall see, these expressions are eventually joined together and used to create an Operator object-the solver of our PDE.</p>
        <p>Simple boundary conditions (BCs), such as Dirichlet BCs, can be imposed on individual equations through special keywords (see Listing 4). For more exotic schemes, instead, the BCs need to be explicitly written (e.g., Higdon BCs [16]), just like any of the symbolic expressions defined in the Listings above. For reasons of space, this aspect is not elaborated further; the interested reader may refer to [27].Simple boundary conditions (BCs), such as Dirichlet BCs, can be imposed on individual equations through special keywords (see Listing 4). For more exotic schemes, instead, the BCs need to be explicitly written (e.g., Higdon BCs [16]), just like any of the symbolic expressions defined in the Listings above. For reasons of space, this aspect is not elaborated further; the interested reader may refer to [27].</p>
        <p>By default, the extent of a TimeFunction in the time dimension is limited by its time order. Hence, the shape of u in Listing 1 is (time_order + 1, nx) = (3, nx). The iterative method will then access u via modulo iteration, that is u[t%3, ...]. In many scenarios, however, the entire time history, or at least periodic time slices, should be saved (e.g., for inversion algorithms). Listing 6 expands our running example with an equation that saves the content of u every 4 iterations, up to a maximum of save = 100 time slices. 1 More complicated interpolation schemes can be defined by precomputing the grid points corresponding to each sparse point, and their respective coefficients. The result can then be used to create a PrecomputedSparseFunction, which behaves like a SparseFunction at the symbolic level.By default, the extent of a TimeFunction in the time dimension is limited by its time order. Hence, the shape of u in Listing 1 is (time_order + 1, nx) = (3, nx). The iterative method will then access u via modulo iteration, that is u[t%3, ...]. In many scenarios, however, the entire time history, or at least periodic time slices, should be saved (e.g., for inversion algorithms). Listing 6 expands our running example with an equation that saves the content of u every 4 iterations, up to a maximum of save = 100 time slices. 1 More complicated interpolation schemes can be defined by precomputing the grid points corresponding to each sparse point, and their respective coefficients. The result can then be used to create a PrecomputedSparseFunction, which behaves like a SparseFunction at the symbolic level.</p>
        <p>&gt;&gt;&gt; from devito import ConditionalDimension &gt;&gt;&gt; ts = ConditionalDimension ( 'ts ' , parent =g. time_dim , factor =4) &gt;&gt;&gt; us = TimeFunction ( name = 'us ', grid =g , save =100 , time_dim = ts ) &gt;&gt;&gt; save = Eq ( us , u) Listing 6. Implementation of time sub-sampling.&gt;&gt;&gt; from devito import ConditionalDimension &gt;&gt;&gt; ts = ConditionalDimension ( 'ts ' , parent =g. time_dim , factor =4) &gt;&gt;&gt; us = TimeFunction ( name = 'us ', grid =g , save =100 , time_dim = ts ) &gt;&gt;&gt; save = Eq ( us , u) Listing 6. Implementation of time sub-sampling.</p>
        <p>In general, all equations that access Functions (or TimeFunctions) employing one or more ConditionalDimensions will be conditionally executed. The condition may be a number indicating how many iterations should pass between two executions of the same equation, or even an arbitrarily complex expression.In general, all equations that access Functions (or TimeFunctions) employing one or more ConditionalDimensions will be conditionally executed. The condition may be a number indicating how many iterations should pass between two executions of the same equation, or even an arbitrarily complex expression.</p>
        <p>A Function internally distinguishes between three regions of points. Domain Represents the computational domain of the Function and is inferred from the input Grid. This includes any elements added to the physical domain purely for computational purposes, e.g. absorbing boundary layers. Halo The grid points surrounding the domain region, i.e., "ghost" points that are accessed by the stencil when iterating in proximity of the domain boundary. Padding The grid points surrounding the halo region, which are allocated for performance optimizations, such as data alignment. Normally this region should be of no interest to a user of Devito, except for precise measurement of memory allocated for each Function.A Function internally distinguishes between three regions of points. Domain Represents the computational domain of the Function and is inferred from the input Grid. This includes any elements added to the physical domain purely for computational purposes, e.g. absorbing boundary layers. Halo The grid points surrounding the domain region, i.e., "ghost" points that are accessed by the stencil when iterating in proximity of the domain boundary. Padding The grid points surrounding the halo region, which are allocated for performance optimizations, such as data alignment. Normally this region should be of no interest to a user of Devito, except for precise measurement of memory allocated for each Function.</p>
        <p>In Devito, an Operator carries out three fundamental tasks: generation of low-level code, JIT compilation, and execution. The Operator input consists of one or more symbolic equations. In the generated code, these equations are scheduled within loop nests of suitable depth and extent. The Operator also accepts substitution rules (to replace symbols with constant values) and optimization levels for the 
            <rs type="software">Devito Symbolic Engine</rs> (DSE) and the 
            <rs type="software">Devito</rs> Loop 
            <rs type="software">Engine</rs> (DLE). By default, all DSE and DLE optimizations that are known to unconditionally improve performance are automatically applied. The same Operator may be reused with different input data; JIT-compilation occurs only once, triggered by the first execution. Overall, this lowering process-from high-level equations to dynamically compiled and executable code-consists of multiple compiler passes, summarized in Figure 2 and discussed in the following sections (a minimal background in data dependence-analysis is recommended; the unfamiliar reader may refer to a classic textbook such as [1]).
        </p>
        <p>In this pass, three main tasks are carried out: indexification, substitution, and domain-alignment.In this pass, three main tasks are carried out: indexification, substitution, and domain-alignment.</p>
        <p>• As explained in Section 3, the input equations typically involve one or more indexed Functions.• As explained in Section 3, the input equations typically involve one or more indexed Functions.</p>
        <p>The indexification consists of converting such objects into actual arrays. An array always keeps a reference to its originating Function. For instance, all accesses to u such as u[t, x + 1] and u[t + 1, x -2] would store a pointer to the same, user-defined Function u(t, x). This metadata is exploited throughout the various compilation passes. • During substitution, the user-provided substitution rules are applied. These may be given for any literal appearing in the input equations, such as the grid spacing symbols. Applying a substitution rule increases the chances of constant folding, but it makes the Operator less generic. The values of symbols for which no substitution rule is available are provided at execution time. • The domain-alignment step shifts the array accesses deriving from Functions having non-empty halo and padding regions. Thus, the array accesses become logically aligned to the equation's natural domain. For instance, given the usual Function u(t, x) having two points on each side of the x halo region, the array accesses u[t, x] and u[t, x + 2] are transformed, respectively, into u[t, x + 2] and u[t, x + 4]. When x = 0, therefore, the values u[t, 2] and u[t, 4] are fetched, representing the first and third points in the computational domain.The indexification consists of converting such objects into actual arrays. An array always keeps a reference to its originating Function. For instance, all accesses to u such as u[t, x + 1] and u[t + 1, x -2] would store a pointer to the same, user-defined Function u(t, x). This metadata is exploited throughout the various compilation passes. • During substitution, the user-provided substitution rules are applied. These may be given for any literal appearing in the input equations, such as the grid spacing symbols. Applying a substitution rule increases the chances of constant folding, but it makes the Operator less generic. The values of symbols for which no substitution rule is available are provided at execution time. • The domain-alignment step shifts the array accesses deriving from Functions having non-empty halo and padding regions. Thus, the array accesses become logically aligned to the equation's natural domain. For instance, given the usual Function u(t, x) having two points on each side of the x halo region, the array accesses u[t, x] and u[t, x + 2] are transformed, respectively, into u[t, x + 2] and u[t, x + 4]. When x = 0, therefore, the values u[t, 2] and u[t, 4] are fetched, representing the first and third points in the computational domain.</p>
        <p>The lowered equations are analyzed to collect information relevant for the Operator construction and execution. In this pass, an equation is inspected "in isolation", ignoring its relationship with the rest of the input. The following metadata are retrieved and/or computed:The lowered equations are analyzed to collect information relevant for the Operator construction and execution. In this pass, an equation is inspected "in isolation", ignoring its relationship with the rest of the input. The following metadata are retrieved and/or computed:</p>
        <p>• input and output Functions;• input and output Functions;</p>
        <p>• Dimensions, which are topologically ordered based on how they appear in the various array index functions; and • two notable Spaces: the iteration space, ISpace, and the data space, DSpace.• Dimensions, which are topologically ordered based on how they appear in the various array index functions; and • two notable Spaces: the iteration space, ISpace, and the data space, DSpace.</p>
        <p>A Space is a collection of points given by the product of n compact intervals on Z. As an example, consider the equation stencil in Listing 4. Immediately we see thatA Space is a collection of points given by the product of n compact intervals on Z. As an example, consider the equation stencil in Listing 4. Immediately we see that</p>
        <p>The first entry t[0, 0] + indicates that, along t, the equation should run between t m + 0 and t M + 0 (extremes included) in the forward direction, as indicated by the symbol +. This is due to the fact that there is a flow dependency in t, so only a unitary positive stepping increment (i.e., t = t + 1) allows a correct propagation of information across consecutive iterations. The only difference along x is that the iteration direction is now arbitrary, as indicated by * . The DSpace is [t[0, 1], x[0, 0]]; intuitively, the entry t[0, 1] is used right before running an Operator to provide a default value for t M -in particular, t M will be set to the largest possible value that does not cause out-of-domain accesses (i.e., out-of-bounds array accesses).The first entry t[0, 0] + indicates that, along t, the equation should run between t m + 0 and t M + 0 (extremes included) in the forward direction, as indicated by the symbol +. This is due to the fact that there is a flow dependency in t, so only a unitary positive stepping increment (i.e., t = t + 1) allows a correct propagation of information across consecutive iterations. The only difference along x is that the iteration direction is now arbitrary, as indicated by * . The DSpace is [t[0, 1], x[0, 0]]; intuitively, the entry t[0, 1] is used right before running an Operator to provide a default value for t M -in particular, t M will be set to the largest possible value that does not cause out-of-domain accesses (i.e., out-of-bounds array accesses).</p>
        <p>A Cluster is a sequence of equations having (i) same ISpace, (ii) same control flow (i.e., same ConditionalDimensions), and (iii) no dimension-carried "true" anti-dependencies among them.A Cluster is a sequence of equations having (i) same ISpace, (ii) same control flow (i.e., same ConditionalDimensions), and (iii) no dimension-carried "true" anti-dependencies among them.</p>
        <p>As an example, consider again the setup in Section 3. The equation stencil cannot be "clusterized" with the equations in the injection list as their ISpaces are different. On the other hand, the equations in injection can be grouped together in the same Cluster as (i) they have same ISpace [t[0, 0] * , p q [0, 0] * ], (ii) same control flow, and (iii) there are no true anti-dependencies among them (note that the second equation in injection does write to u[t + 1, ...], but as explained later this is in fact a reduction, that is a "false" anti-dependency).As an example, consider again the setup in Section 3. The equation stencil cannot be "clusterized" with the equations in the injection list as their ISpaces are different. On the other hand, the equations in injection can be grouped together in the same Cluster as (i) they have same ISpace [t[0, 0] * , p q [0, 0] * ], (ii) same control flow, and (iii) there are no true anti-dependencies among them (note that the second equation in injection does write to u[t + 1, ...], but as explained later this is in fact a reduction, that is a "false" anti-dependency).</p>
        <p>First, each equation is assigned a new ISpace, based upon a global analysis. Any of the iteration directions that had been marked as "arbitrary" ( * ) during local analysis may now be enforced to forward (+) or backward (-). This process exploits data dependence analysis.First, each equation is assigned a new ISpace, based upon a global analysis. Any of the iteration directions that had been marked as "arbitrary" ( * ) during local analysis may now be enforced to forward (+) or backward (-). This process exploits data dependence analysis.</p>
        <p>For instance, consider the flow dependency between stencil and the injection equations. If we want u to be up-to-date when evaluating injection, then we eventually need all equations to be scheduled sequentially within the t loop. For this, the ISpaces of the injection equations are specialized by enforcing the direction forward along the Dimension t.For instance, consider the flow dependency between stencil and the injection equations. If we want u to be up-to-date when evaluating injection, then we eventually need all equations to be scheduled sequentially within the t loop. For this, the ISpaces of the injection equations are specialized by enforcing the direction forward along the Dimension t.</p>
        <p>Algorithm 1 illustrates how the enforcement of iteration directions is achieved in general. Whenever a clash is detected (i.e., two equations with ISpace [d[0, 0] + , ...] and [d[0, 0] -, ...]), the original direction determined by the local analysis pass is kept (lines 11 and 13), which will eventually lead to generating different loops.Algorithm 1 illustrates how the enforcement of iteration directions is achieved in general. Whenever a clash is detected (i.e., two equations with ISpace [d[0, 0] + , ...] and [d[0, 0] -, ...]), the original direction determined by the local analysis pass is kept (lines 11 and 13), which will eventually lead to generating different loops.</p>
        <p>Grouping. This step performs the actual clustering, checking ISpaces and anti-dependencies, as well as handling control flow. The procedure is shown in Algorithm 2; some explanations follow.Grouping. This step performs the actual clustering, checking ISpaces and anti-dependencies, as well as handling control flow. The procedure is shown in Algorithm 2; some explanations follow.</p>
        <p>• Robust data-dependence analysis, capable of tracking flow-, anti-, and output-dependencies at the level of array accesses, is necessary. In particular, it must be able to tell whether two generic array accesses induce a dependency or not. The data-dependence analysis performed is conservative; that is, a dependency is always assumed when a test is inconclusive. Dependence testing is based on the standard Lamport test [1]. In Algorithm 2, data-dependence analysis is carried out by the function get_dependencies. • If an anti-dependency is detected along a Dimension i, then i is marked as atomic-meaning that no further clustering can occur along i. This information is also exploited by later Operator passes (see Section 4.5). • Reductions, and in particular increments, are treated specially. They represent a special form of anti-dependency, as they do not break clustering. get_dependences detects reductions and removes them from the set of anti-dependencies.• Robust data-dependence analysis, capable of tracking flow-, anti-, and output-dependencies at the level of array accesses, is necessary. In particular, it must be able to tell whether two generic array accesses induce a dependency or not. The data-dependence analysis performed is conservative; that is, a dependency is always assumed when a test is inconclusive. Dependence testing is based on the standard Lamport test [1]. In Algorithm 2, data-dependence analysis is carried out by the function get_dependencies. • If an anti-dependency is detected along a Dimension i, then i is marked as atomic-meaning that no further clustering can occur along i. This information is also exploited by later Operator passes (see Section 4.5). • Reductions, and in particular increments, are treated specially. They represent a special form of anti-dependency, as they do not break clustering. get_dependences detects reductions and removes them from the set of anti-dependencies.</p>
        <p>but not with its immediate predecessor E 2 (e.g., due to a different ISpace). However, this can only happen when there are no flow or anti-dependences between E 2 and E 3 ; i.e. when the if commands at lines 10 and 13 are not entered, thus allowing the search to proceed with the next equation. This optimization was originally motivated by gradient operators in seismic imaging kernels. • The routine control_flow, omitted for brevity, creates additional Clusters if one or more ConditionalDimensions are encountered. These are tracked in a special Cluster field, guards, as also required by later passes (see Section 4.5).but not with its immediate predecessor E 2 (e.g., due to a different ISpace). However, this can only happen when there are no flow or anti-dependences between E 2 and E 3 ; i.e. when the if commands at lines 10 and 13 are not entered, thus allowing the search to proceed with the next equation. This optimization was originally motivated by gradient operators in seismic imaging kernels. • The routine control_flow, omitted for brevity, creates additional Clusters if one or more ConditionalDimensions are encountered. These are tracked in a special Cluster field, guards, as also required by later passes (see Section 4.5).</p>
        <p>The DSE-Devito Symbolic Engine-is a macro-pass reducing the arithmetic strength of Clusters (e.g., their operation count). It consists of a series of passes, ranging from standard common subexpression elimination (CSE) to more advanced rewrite procedures, applied individually to each Cluster. The DSE output is a new ordered sequence of Clusters: there may be more or fewer Clusters than in the input, and both the overall number of equations as well as the sequence of arithmetic operations might differ. The DSE passes are discussed in Section 5.1. We remark that the DSE only operates on Clusters (i.e., on collections of equations); there is no concept of "loop" at this stage yet. However, by altering Clusters, the DSE has an indirect impact on the final loop-nest structure.The DSE-Devito Symbolic Engine-is a macro-pass reducing the arithmetic strength of Clusters (e.g., their operation count). It consists of a series of passes, ranging from standard common subexpression elimination (CSE) to more advanced rewrite procedures, applied individually to each Cluster. The DSE output is a new ordered sequence of Clusters: there may be more or fewer Clusters than in the input, and both the overall number of equations as well as the sequence of arithmetic operations might differ. The DSE passes are discussed in Section 5.1. We remark that the DSE only operates on Clusters (i.e., on collections of equations); there is no concept of "loop" at this stage yet. However, by altering Clusters, the DSE has an indirect impact on the final loop-nest structure.</p>
        <p>In this pass, the intermediate representation is lowered to an Iteration/Expression Tree (IET). An IET is an abstract syntax tree in which Iterations and Expressions-two special node types-are the main actors. Equations are wrapped within Expressions, while Iterations represent loops.In this pass, the intermediate representation is lowered to an Iteration/Expression Tree (IET). An IET is an abstract syntax tree in which Iterations and Expressions-two special node types-are the main actors. Equations are wrapped within Expressions, while Iterations represent loops.</p>
        <p>Loop nests embedding such Expressions are constructed by suitably nesting Iterations. Each Cluster is eventually placed in its own loop (Iteration) nest, although some (outer) loops may be shared by multiple Clusters. Consider again our running acoustic wave-equation example. There are three Clusters in total: C 1 for stencil, C 2 for save, and C 3 for the equations in injection. We use Algorithm 3-an excerpt of the actual cluster scheduling algorithm-to explain how this sequence of Clusters is turned into an IET. Initially, the schedule list is empty, so when C 1 is handled two nested Iterations are created (line 15), respectively for the Dimensions t and x. Subsequently, C 2 's ISpace and the current schedule are compared (line 5). It turns out that t appears among C 2 's guards, hence the for loop is exited at line 12 without inspecting the second and last iteration. Thus, index = 1, and the previously built Iteration over t is reused. Finally, when processing C 3 , the for loop is exited at the second iteration due to line 6, since p q x. Again, the t Iteration is reused, while a new Iteration is constructed for the Dimension p q . Eventually, the constructed IET is as in Listing 7.Loop nests embedding such Expressions are constructed by suitably nesting Iterations. Each Cluster is eventually placed in its own loop (Iteration) nest, although some (outer) loops may be shared by multiple Clusters. Consider again our running acoustic wave-equation example. There are three Clusters in total: C 1 for stencil, C 2 for save, and C 3 for the equations in injection. We use Algorithm 3-an excerpt of the actual cluster scheduling algorithm-to explain how this sequence of Clusters is turned into an IET. Initially, the schedule list is empty, so when C 1 is handled two nested Iterations are created (line 15), respectively for the Dimensions t and x. Subsequently, C 2 's ISpace and the current schedule are compared (line 5). It turns out that t appears among C 2 's guards, hence the for loop is exited at line 12 without inspecting the second and last iteration. Thus, index = 1, and the previously built Iteration over t is reused. Finally, when processing C 3 , the for loop is exited at the second iteration due to line 6, since p q x. Again, the t Iteration is reused, while a new Iteration is constructed for the Dimension p q . Eventually, the constructed IET is as in Listing 7.</p>
        <p>The newly constructed IET is analyzed to determine Iteration properties such as sequential, parallel, and vectorizable, which are then attached to the relevant nodes in the IET. These properties are used for loop optimization, but only by a later pass (see Section 4.7). To determine whether an Iteration is parallel or sequential, a fundamental result from compiler theory is Algorithm 3: An excerpt of the cluster scheduling algorithm, turning a list (of Clusters) into a tree (IET). Here, the fact that different Clusters may eventually share some outer Iterations is highlighted.The newly constructed IET is analyzed to determine Iteration properties such as sequential, parallel, and vectorizable, which are then attached to the relevant nodes in the IET. These properties are used for loop optimization, but only by a later pass (see Section 4.7). To determine whether an Iteration is parallel or sequential, a fundamental result from compiler theory is Algorithm 3: An excerpt of the cluster scheduling algorithm, turning a list (of Clusters) into a tree (IET). Here, the fact that different Clusters may eventually share some outer Iterations is highlighted.</p>
        <p>This macro-pass transforms the IET for performance optimization. Apart from runtime performance, this pass also optimizes for rapid JIT compilation with the underlying C compiler. A number of loop optimizations are introduced, including loop blocking, minimization of remainder loops, SIMD vectorization, shared-memory (hierarchical) parallelism via 
            <rs type="software">OpenMP</rs>, software prefetching. These will be detailed in Section 5. A backend (see Section 4.9) might provide its own loop optimization engine.
        </p>
        <p>Finally, the IET adds variable declarations and header files, as well as instrumentation for performance profiling, in particular, to collect execution times of specific code regions. Declarations are injected into the IET, ensuring they appear as close as possible to the scope in which the relative variables are used, while honoring the OpenMP semantics of private and shared variables. To generate C code, a suitable tree visitor inspects the IET and incrementally builds a CGen tree [20], which is ultimately translated into a string and written to a file. Such files are stored in a software cache of Devito-generated Operators, JIT-compiled into a shared object, and eventually loaded into the Python environment. The compiled 
            <rs type="software">code</rs> has a default entry point (a special function), which is called directly from Python at Operator application time.
        </p>
        <p>In Devito, a backend is a mechanism to specialize data types as well as Operator passes, while preserving software modularity (inspired by [26]).In Devito, a backend is a mechanism to specialize data types as well as Operator passes, while preserving software modularity (inspired by [26]).</p>
        <p>One of the main objectives of the backend infrastructure is promoting software composability. As explained in Section 2, there exist a significant number of interesting tools for stencil optimization, which we may want to integrate with 
            <rs type="software">Devito</rs>. For example, one of the future goals is to support GPUs, and this might be achieved by writing a new backend implementing the interface between 
            <rs type="software">Devito</rs> and third-party software specialized for this particular architecture.
        </p>
        <p>Currently, two backends exist: core the default backend, which relies on the DLE for loop optimization. yask an alternative backend using the 
            <rs type="software">YASK</rs> stencil compiler to generate optimized C++ code for Intel ® Xeon ® and Intel ® Xeon Phi TM architectures [42]. Devito transforms the IET into a format suitable for YASK, and uses its API for data management, JIT-compilation, and execution. Loop optimization is performed by 
            <rs type="software">YASK</rs> through the 
            <rs type="software">YASK</rs> Loop Engine (YLE).
        </p>
        <p>The core and yask backends share the compilation pipeline in Figure 2 until the loop optimization stage.The core and yask backends share the compilation pipeline in Figure 2 until the loop optimization stage.</p>
        <p>As discussed in Section 4, 
            <rs type="software">Devito</rs> performs symbolic optimizations to reduce the arithmetic strength of the expressions, as well as loop transformations for data locality and parallelism. The former are implemented as a series of compiler passes in the DSE, while for the latter there currently are two alternatives, namely the DLE and the YLE (depending on the chosen execution backend). 
            <rs type="software">Devito</rs> abstracts away the single optimizations passes by providing users with a certain number of optimization levels, called "modes", which trigger pre-established sequences of optimizationsanalogous to what general-purpose compilers do with, for example, -O2 and -O3. In Sections 5.1, 5.2, and 5.3 we describe the individual passes provided by the DSE, DLE, and YLE respectively, while in Section 7.1 we explain how these are composed into modes.
        </p>
        <p>The DSE passes attempt to reduce the arithmetic strength of the expressions through FLOP-reducing transformations [11]. They are illustrated in Listings 8-11, which derive from the running example used throughout the article. A detailed description follows.The DSE passes attempt to reduce the arithmetic strength of the expressions through FLOP-reducing transformations [11]. They are illustrated in Listings 8-11, which derive from the running example used throughout the article. A detailed description follows.</p>
        <p>• Common sub-expression elimination (CSE). Two implementations are available: one based upon 
            <rs type="software">SymPy</rs>'s cse routine and one built on top of more basic 
            <rs type="software">SymPy</rs> routines, such as xreplace.
        </p>
        <p>The former is more powerful, being aware of key arithmetic properties such as associativity; hence it can discover more redundancies. The latter is simpler, but avoids a few critical issues: (i) it has a much quicker turnaround time; (ii) it does not capture integer index expressions (for increased quality of the generated code); and (iii) it tries not to break factorization opportunities. A generalized common sub-expressions elimination routine retaining the features and avoiding the drawbacks of both implementations is still under development. By default, the latter implementation is used when the CSE pass is selected. • Factorization. This pass visits each expression tree and tries to factorize FD weights. Factorization is applied without altering the expression structure (e.g., without expanding products) and without performing any heuristic search across groups of expressions. This choice is based on the observation that a more aggressive approach is only rarely helpful (never in the test cases in Section 7), while the increase in symbolic processing time could otherwise be significant. The implementation exploits the 
            <rs type="software">SymPy</rs> collect routine. However, while collect only searches for common factors across the immediate children of a single node, the DSE implementation recursively applies collect to each Add node (i.e., an addition) in the expression tree, until the leaves are reached. • Extraction. The name stems from the fact that sub-expressions matching a certain condition are pulled out of a larger expression, and their values are stored into suitable scalar or tensor temporaries. For example, a condition could be "extract all time-varying sub-expressions whose operation count is larger than a given threshold". A tensor temporary may be preferred over a scalar temporary if the intention is to let the IET construction pass (see Section 4.5) place the pulled sub-expressions within an outer loop nest. Obviously, this comes at the price of additional storage. This peculiar effect-trading operations for memory-will be thoroughly analyzed in Sections 6 and 7. • Detection of shift-invariants. In essence, a shift-invariant is a sub-expression that is redundantly computed at multiple iteration points. Because of its key role in the Shift-invariants Elimination algorithm, the explanation of how shift-invariants are detected is postponed until Section 6.
        </p>
        <p>The DLE transforms the IET via classic loop optimizations for parallelism and data locality [18]. These are summarized below. • SIMD Vectorization. Implemented by enforcing compiler auto-vectorization via special pragmas from the OpenMP 4.0 language. With this approach, the DLE aims to be performance-portable across different architectures. However, this strategy causes a significant fraction of vector loads/stores to be unaligned to cache boundaries, due to the stencil offsets. As we shall see, this is a primary cause of performance loss. • Loop Blocking. Also known as "tiling", this technique implemented by replacing Iteration trees in the IET. The current implementation only supports blocking over fully-parallel Iterations. Blocking over dimensions characterized by flow-or anti-dependencies, such as the time dimension in typical explicit finite difference schemes, is instead work in progress (this would require a preliminary pass known as loop skewing; see Section 8 for more details). On the other hand, a feature of the present implementation is the capability of blocking across particular sequences of loop nests. This is exploited by the Shift-invariants Elimination algorithm, as shown in Section 6.3. To determine an optimal block shape, an Operator resorts to empirical auto-tuning. • Parallelism. Shared-memory parallelism is introduced by decorating Iterations with suitable OpenMP pragmas. The OpenMP static scheduling is used. Normally, only the outermost fully-parallel Iteration is annotated with the parallel pragma. However, heuristically nested fully-parallel Iterations are collapsed if the core count is greater than a certain threshold. This pass also ensures that all array temporaries allocated in the scope of the parallel Iteration are declared as private and that storage is allocated where appropriate (stack, heap). Summarizing, the DLE applies a sequence of typical stencil optimizations, aiming to reach a minimum level of performance across different architectures. As we shall see, the effectiveness of this approach, based on simple transformations, deteriorates on architectures strongly conceived for hierarchical parallelism. This is one of the main reasons behind the development of the 
            <rs type="software">yask</rs> backend (see Section 4.9), described in the following section.
        </p>
        <p>YASK-Yet Another Stencil Kit 2 -is an open-source C++ software framework for generating highperformance implementations of stencil codes for Intel ® Xeon ® and Intel ® Xeon Phi TM processors. Previous publications on YASK have discussed its overall structure [42] and its application to the Intel ® Xeon Phi TM x100 family (code-named Knights Corner) [39] and Intel ® Xeon Phi TM x200 family (code-named Knights Landing) [12,35,40] many-core CPUs. Unlike Devito, it does not expose a symbolic language to the programmer or create stencils from finite-difference approximations of differential equations. Rather, the programmer provides simple declarative descriptions of the stencil equations using a C++ or Python API. Thus, 
            <rs type="software">Devito</rs> operates at a level of abstraction higher than that of YASK, while YASK provides performance portability across Intel architectures and is more focused on low-level optimizations. Following is a sample of some of the optimizations provided by YASK:
        </p>
        <p>• Vector-folding. In traditional SIMD vectorization, such as that provided by an auto-vectorizing compiler, the vector elements are arranged sequentially along the unit-stride dimension of the grid, which is also the dimension iterated over in the inner-most loop of the stencil kernel. Vector-folding is an alternative data-layout method whereby neighboring elements are arranged in small multi-dimensional tiles. Figure 3 illustrates three ways to pack eight double-precision floating-point values into a 512-bit SIMD register. Figure 3a shows a traditional 1D "in-line" layout, and 3b and 3c show alternative 2D and 3D "folded" layouts. Furthermore, these tiles may be ordered in memory in a dimension independent of the dimensions used in vectorization [39]. The combination of these two techniques can significantly increase overlap and reuse between successive stencil-application iterations, reducing the memory-bandwidth demand. For stencils that are bandwidth-bound, this can provide significant performance gains [35,39]. • Software prefetching. Many high-order or staggered-grid stencils require multiple streams of data to be read from memory, which can overwhelm the hardware prefetchers. 
            <rs type="software">YASK</rs> can automatically generate software-prefetch instructions to improve the cache hit rates, especially on Xeon Phi CPUs. • Hierarchical parallelism. Dividing the spatial domain into tiles to increase temporal cache locality is a common stencil optimization as discussed earlier. When implementing this technique, sometimes called "cache-blocking", it is typical to assign each thread to one or more small rectilinear subsets of the domain in which to apply the stencil(s). However, if these threads share caches, one thread's data will often evict data needed later by another thread, reducing the effective capacity of the cache. 
            <rs type="software">YASK</rs> addresses this by employing two levels of OpenMP parallelization: the outer level of parallel loops are applied across the cache-blocks, and an inner level is applied across sub-blocks within those tiles. In the case of the Xeon Phi, the eight hyper-threads that share each L2 cache can now cooperate on filling and reusing the data in the cache, rather than evicting each other's data.
        </p>
        <p>
            <rs type="software">YASK</rs> also provides other optimizations, such as temporal tiling and MPI support that are not exploited by 
            <rs type="software">Devito</rs> at the time of writing. The interested reader may refer to [40,41]. To leverage both the symbolic processing of 
            <rs type="software">Devito</rs> and the low-level optimizations of 
            <rs type="software">YASK</rs>, we have integrated the 
            <rs type="software">YASK</rs> framework into the 
            <rs type="software">Devito</rs> package. In essence, the Devito 
            <rs type="software">yask</rs> backend exploits the intermediate representation of an Operator to generate 
            <rs type="software">YASK</rs> kernels. In 
            <rs type="software">Devito</rs> v
            <rs type="version">3.1</rs>, roughly 70% of the Devito API is supported by the 
            <rs type="software">yask</rs> backend. 3
        </p>
        <p>Shift-invariants, or "cross-iteration redundancies" (informally introduced in Section 5.1), in FD operators depend on the differential operators used in the PDE(s) and the chosen discretization scheme. From a performance viewpoint, the presence of shift-invariants is a non-issue as long as the operator is memory-bound, while it becomes relevant in kernels with a high arithmetic intensity. In Devito, the Shift-invariants Elimination (SIE) algorithm attempts to remove shift-invariants with the goal of reducing the operation count. As shown in Section 7, the SIE algorithm has considerable impact in seismic imaging kernels. The algorithm is implemented through the orchestration of multiple DSE and DLE/YLE passes, namely extraction of candidate expressions (DSE), detection of shift-invariants (DSE), loop blocking (DLE/YLE).Shift-invariants, or "cross-iteration redundancies" (informally introduced in Section 5.1), in FD operators depend on the differential operators used in the PDE(s) and the chosen discretization scheme. From a performance viewpoint, the presence of shift-invariants is a non-issue as long as the operator is memory-bound, while it becomes relevant in kernels with a high arithmetic intensity. In Devito, the Shift-invariants Elimination (SIE) algorithm attempts to remove shift-invariants with the goal of reducing the operation count. As shown in Section 7, the SIE algorithm has considerable impact in seismic imaging kernels. The algorithm is implemented through the orchestration of multiple DSE and DLE/YLE passes, namely extraction of candidate expressions (DSE), detection of shift-invariants (DSE), loop blocking (DLE/YLE).</p>
        <p>The criteria for extraction of candidate sub-expressions are:The criteria for extraction of candidate sub-expressions are:</p>
        <p>• Any maximal time-invariant whose operation count is greater than Thr 0 = 10 (floating point arithmetic only). The term "maximal" means that the expression is not embedded within a larger time-invariant. The default value Thr 0 = 10, determined empirically, provides systematic performance improvements in a series of seismic imaging kernels. Transcendental functions are given a weight in the order of tens of operations, again determined empirically. • Any maximal time-varying whose operation count is greater than Thr 1 = 10. Such expressions often lead to shift-invariants, since they typically result from taking spatial and time derivatives on TimeFunctions. In particular, cross-derivatives are a major cause of shift-invariants.• Any maximal time-invariant whose operation count is greater than Thr 0 = 10 (floating point arithmetic only). The term "maximal" means that the expression is not embedded within a larger time-invariant. The default value Thr 0 = 10, determined empirically, provides systematic performance improvements in a series of seismic imaging kernels. Transcendental functions are given a weight in the order of tens of operations, again determined empirically. • Any maximal time-varying whose operation count is greater than Thr 1 = 10. Such expressions often lead to shift-invariants, since they typically result from taking spatial and time derivatives on TimeFunctions. In particular, cross-derivatives are a major cause of shift-invariants.</p>
        <p>This pass leverages the extraction routine described in Section 5.1.This pass leverages the extraction routine described in Section 5.1.</p>
        <p>To define the concept of shift-invariant expressions, we first need to formalize the notion of shifted operands. Here, an operand is regarded as the arithmetic product of a scalar value (or "coefficient") and one or more indexed objects. An indexed object is characterized by a label (i.e., its name), a vector of n dimensions, and a vector of n displacements (one for each dimension). We say that an operand o 1 is shifted with respect to an operand o 0 if o 0 and o 1 have same coefficient, label, and dimensions, and if their displacement vectors are such that one is the translation of the other (in the classic geometric sense). For example, the operand 2 * u[x, y, z] is shifted with respect to the operand 2 * u[x + 1, y + 2, z + 3] since they have same coefficient (2), label (u), and dimensions ([x, y, z]), while the displacement vectors [0, 0, 0] and [1,2,3] are expressible by means of a translation. Now consider two expressions e 0 and e 1 in fully-expanded form (i.e., a non-nested sum-ofoperands). We say that e 0 is shifted with respect to e 1 if the following conditions hold:To define the concept of shift-invariant expressions, we first need to formalize the notion of shifted operands. Here, an operand is regarded as the arithmetic product of a scalar value (or "coefficient") and one or more indexed objects. An indexed object is characterized by a label (i.e., its name), a vector of n dimensions, and a vector of n displacements (one for each dimension). We say that an operand o 1 is shifted with respect to an operand o 0 if o 0 and o 1 have same coefficient, label, and dimensions, and if their displacement vectors are such that one is the translation of the other (in the classic geometric sense). For example, the operand 2 * u[x, y, z] is shifted with respect to the operand 2 * u[x + 1, y + 2, z + 3] since they have same coefficient (2), label (u), and dimensions ([x, y, z]), while the displacement vectors [0, 0, 0] and [1,2,3] are expressible by means of a translation. Now consider two expressions e 0 and e 1 in fully-expanded form (i.e., a non-nested sum-ofoperands). We say that e 0 is shifted with respect to e 1 if the following conditions hold:</p>
        <p>• the operands in e 0 (e 1 ) are shifted with respect to the operands in e 1 (e 0 );• the operands in e 0 (e 1 ) are shifted with respect to the operands in e 1 (e 0 );</p>
        <p>• the same arithmetic operators are applied to the involved operands.• the same arithmetic operators are applied to the involved operands.</p>
        <p>For example, consider e = u[x] + v[x], having two operands u[x] and v[x]; then:For example, consider e = u[x] + v[x], having two operands u[x] and v[x]; then:</p>
        <p>is not shifted with respect to e, due to a different dimension vector.is not shifted with respect to e, due to a different dimension vector.</p>
        <p>• u[x] + w[x] is not shifted with respect to e, due to a different label.• u[x] + w[x] is not shifted with respect to e, due to a different label.</p>
        <p>is not shifted with respect to e, since it cannot be expressed as a translation of e.is not shifted with respect to e, since it cannot be expressed as a translation of e.</p>
        <p>• u[x+2] + v[x+2] is shifted with respect to e, as it can be expressed through the translation• u[x+2] + v[x+2] is shifted with respect to e, as it can be expressed through the translation</p>
        <p>The relation "e 0 is shifted with respect to e 1 " is an equivalence relation, as it is at the same time reflexive, symmetric, and transitive. Thanks to these properties, the turnaround times for detecting shift-invariants are extremely quick (less than 2 seconds running on an Intel ® Xeon ® E5-2620 v4 for the challenging tti test case with so=16, described in Section 7.2), despite the O(n 2 ) computational complexity (with n representing the number of candidate expressions, see Section 6.1).The relation "e 0 is shifted with respect to e 1 " is an equivalence relation, as it is at the same time reflexive, symmetric, and transitive. Thanks to these properties, the turnaround times for detecting shift-invariants are extremely quick (less than 2 seconds running on an Intel ® Xeon ® E5-2620 v4 for the challenging tti test case with so=16, described in Section 7.2), despite the O(n 2 ) computational complexity (with n representing the number of candidate expressions, see Section 6.1).</p>
        <p>Algorithm 4 highlights the fundamental steps of shift-invariants detection. In the worst case scenario, all pairs of candidate expressions are compared by applying the shift-invariant definition given above. Aggressive pruning, however, is applied to minimize the cost of the search. The algorithm uses some auxiliary functions: (i) calculate_displacements returns a mapper associating, to each candidate, its displacement vectors (one for each indexed object); (ii) compare_ops(e 1 , e 2 ) evaluates to true if e 1 and e 2 perform the same operations on the same operands; (iii) is_translated(d 1 , d 2 ) evaluates to true if the displacement vectors in d 2 are pairwise-shifted with respect to the vectors in d 1 by the same factor. Together, (ii) and (iii) are used to establish whether two expressions are shifted (line 8). From an implementation point of view, these functions exploit key 
            <rs type="software">SymPy</rs> expression properties (e.g., immutability, deterministic ordering of operands) and operators (e.g., for structural equality testing), so they eventually result rather simple.
        </p>
        <p>Eventually, m sets of shift-invariants are determined. For each of these sets G 0 , ..., G m-1 , a pivota special shift-invariant -is constructed. This is the key for operation count reduction: the pivot p i of G i = {e 0 , ..., e k-1 } will be used in place of e 0 , ..., e k -1 (thus obtaining a reduction proportional to k). A simple example is illustrated in Listing 11. Several optimizations for data locality, not shown in Algorithm 4, are also applied. The interested reader may refer to the documentation and the examples of Devito v3.1 for more details; below, we only mention the underlying ideas.Eventually, m sets of shift-invariants are determined. For each of these sets G 0 , ..., G m-1 , a pivota special shift-invariant -is constructed. This is the key for operation count reduction: the pivot p i of G i = {e 0 , ..., e k-1 } will be used in place of e 0 , ..., e k -1 (thus obtaining a reduction proportional to k). A simple example is illustrated in Listing 11. Several optimizations for data locality, not shown in Algorithm 4, are also applied. The interested reader may refer to the documentation and the examples of Devito v3.1 for more details; below, we only mention the underlying ideas.</p>
        <p>• The pivot of G i is constructed, rather than selected out of e 0 , ..., e k -1 , so that it could coexist with as many other pivots as possible within the same Cluster. For example, consider again Listing 11: there are infinite possible pivots temp[x + s] = 9.0*temp0*u[t, x + s], and the one with s = 0 is chosen. However, this choice is not random. The pivots are chosen based on a global optimization strategy, which takes into account all of the m sets of shift-invariants. The objective function consists of choosing s so that multiple pivots will have identical ISpace, and thus be scheduled to the same Cluster (and, eventually, to the same loop nest). • Conservatively, the chosen pivots are assigned to array variables. A second optimization pass, called index bumping and array contraction in 
            <rs type="software">Devito</rs> v3.
            <rs type="version">1</rs>, attempts to turn these arrays into scalar variables, thus reducing memory consumption. This pass is based on data-dependence analysis, which essentially checks whether a given pivot is required only within its Cluster or by later Clusters as well. In the former case, the optimization is applied.
        </p>
        <p>In essence, the SIE algorithm trades operation for memory-the (array) temporaries to store the shift-invariants. From a run-time performance viewpoint, this is convenient only in arithmeticintensive kernels. Unsurprisingly, we observed that storing temporary arrays spanning the entire grid rarely provides benefits (e.g., only when the operation count reductions are exceptionally high). We then considered the following options.In essence, the SIE algorithm trades operation for memory-the (array) temporaries to store the shift-invariants. From a run-time performance viewpoint, this is convenient only in arithmeticintensive kernels. Unsurprisingly, we observed that storing temporary arrays spanning the entire grid rarely provides benefits (e.g., only when the operation count reductions are exceptionally high). We then considered the following options.</p>
        <p>(1) Capturing redundancies arising along the innermost dimension only. Thus, only scalar temporaries would be necessary. This approach presents three main issues, however: (i) only a small percentage of all redundancies are captured; (ii) the implementation is non-trivial, due to the need for circular buffers in the generated code; (iii) SIMD vectorization is affected, since inner loop iterations are practically serialised. Some previous articles followed this path [9,10]. (2) A generalization of the previous approach: using both scalar and array temporaries, without searching for redundancies across the outermost loop(s). This mitigates issue (i), although the memory pressure is still severely affected. Issue (iii) is also unsolved. This strategy was discussed in [21]. (3) Using loop blocking. Redundancies are sought and captured along all available dimensions, although they are now assigned to array temporaries whose size is a function of the block shape. A first loop nest produces the array temporaries, while a subsequent loop nest consumes them, to compute the actual output values. The block shape should be chosen so that writes and reads to the temporary arrays do not cause high latency accesses to the DRAM. An illustrative example is shown in Listing 12. The SIE algorithm uses the third approach, based on cross-loop-nest blocking. This pass is carried out by the DLE, which can introduce blocking over sequences of loops (see Section 5.2). Listing 12. The loop nest produced by the SIE algorithm for the example in Listing 11. Note that the block loop (line 2) wraps both the producer (line 3) and consumer (line 5) loops. For clarity, unnecessary information is omitted.(1) Capturing redundancies arising along the innermost dimension only. Thus, only scalar temporaries would be necessary. This approach presents three main issues, however: (i) only a small percentage of all redundancies are captured; (ii) the implementation is non-trivial, due to the need for circular buffers in the generated code; (iii) SIMD vectorization is affected, since inner loop iterations are practically serialised. Some previous articles followed this path [9,10]. (2) A generalization of the previous approach: using both scalar and array temporaries, without searching for redundancies across the outermost loop(s). This mitigates issue (i), although the memory pressure is still severely affected. Issue (iii) is also unsolved. This strategy was discussed in [21]. (3) Using loop blocking. Redundancies are sought and captured along all available dimensions, although they are now assigned to array temporaries whose size is a function of the block shape. A first loop nest produces the array temporaries, while a subsequent loop nest consumes them, to compute the actual output values. The block shape should be chosen so that writes and reads to the temporary arrays do not cause high latency accesses to the DRAM. An illustrative example is shown in Listing 12. The SIE algorithm uses the third approach, based on cross-loop-nest blocking. This pass is carried out by the DLE, which can introduce blocking over sequences of loops (see Section 5.2). Listing 12. The loop nest produced by the SIE algorithm for the example in Listing 11. Note that the block loop (line 2) wraps both the producer (line 3) and consumer (line 5) loops. For clarity, unnecessary information is omitted.</p>
        <p>We outline in Section 7.1 the compiler setup, computer architectures, and measurement procedure that we used for our performance experiments. Following that, we outline the physical model and numerical setup that define the problem being solved in Section 7.2. This leads to performance results, presented in Sections 7.3 and 7.4.We outline in Section 7.1 the compiler setup, computer architectures, and measurement procedure that we used for our performance experiments. Following that, we outline the physical model and numerical setup that define the problem being solved in Section 7.2. This leads to performance results, presented in Sections 7.3 and 7.4.</p>
        <p>We analyze the performance of generated code using enriched roofline plots. Since the DSE transformations may alter the operation count by allocating extra memory, only by looking at GFlops/s performance and runtime jointly can a quality measure of code syntheses be derived.We analyze the performance of generated code using enriched roofline plots. Since the DSE transformations may alter the operation count by allocating extra memory, only by looking at GFlops/s performance and runtime jointly can a quality measure of code syntheses be derived.</p>
        <p>For the roofline plots, Stream TRIAD was used to determine the attainable memory bandwidth of the node. Two peaks for the maximum floating-point performance are shown: the ideal peak, calculated asFor the roofline plots, Stream TRIAD was used to determine the attainable memory bandwidth of the node. Two peaks for the maximum floating-point performance are shown: the ideal peak, calculated as</p>
        <p>and a more realistic one, given by the 
            <rs type="software">LINPACK</rs> benchmark. The reported runtimes are the minimum of three runs (the variance was negligible). The model used to calculate the operational intensity assumes that the time-invariant Functions are reloaded at each time iteration. This is a more realistic setting than a "compulsory-traffic-only" model (i.e., an infinite cache).
        </p>
        <p>We had exclusive access to two architectures: an Intel ® Xeon ® Platinum 8180 (formerly codenamed Skylake) and an Intel ® Xeon Phi TM 7250 (formerly code-named Knights Landing), which will be referred to as skl8180 and knl7250. Thread pinning was enabled with the program 
            <rs type="software">numactl</rs>. The 
            <rs type="creator">Intel</rs> ® compiler icc version 18
            <rs type="version">.0</rs> was used to compile the generated code. The experiments were run with 
            <rs type="software">Devito</rs> v
            <rs type="version">3.1</rs> [43]. The experimentation framework with instructions for reproducibility is available at [34]. All floating point operations are performed in single precision, which is typical for seismic imaging applications.
        </p>
        <p>Any arbitrary sequence of DSE and DLE/YLE transformations is applicable to an Operator. Devito, provides three preset optimization sequences, or "modes", which vary in aggressiveness and affect code generation in three major ways:Any arbitrary sequence of DSE and DLE/YLE transformations is applicable to an Operator. Devito, provides three preset optimization sequences, or "modes", which vary in aggressiveness and affect code generation in three major ways:</p>
        <p>• the time required by the 
            <rs type="software">Devito</rs> compiler to generate the code,
        </p>
        <p>• the potential reduction in operation count, and • the potential amount of additional memory that might be allocated to store (scalar, tensor) temporaries.• the potential reduction in operation count, and • the potential amount of additional memory that might be allocated to store (scalar, tensor) temporaries.</p>
        <p>A more aggressive mode might obtain a better operation count reduction than a non-aggressive one, although this does not necessarily imply a better time to solution as the memory pressure might also increase. The three optimization modes-basic, advanced, and aggressive-apply the same sequence of DLE/YLE transformations, which includes OpenMP parallelism, SIMD vectorization, and loop blocking. However, they vary in the number, type, and order of DSE transformations. In particular, basic enables: common sub-expressions elimination. advanced enables: factorization; extraction of time-invariant shift-invariants; detection of shiftinvariants; all basic passes. aggressive enables: extraction of time-varying shift-invariants; all advanced passes. Thus, aggressive triggers the full-fledged SIE algorithm, while advanced uses only a relaxed version (based on time invariants). All runs used loop tiling with a block shape that was determined individually for each case using auto-tuning. The auto-tuning phase, however, was not included in the measured experiment runtime. Likewise, the code generation phase is not included in the reported runtime.A more aggressive mode might obtain a better operation count reduction than a non-aggressive one, although this does not necessarily imply a better time to solution as the memory pressure might also increase. The three optimization modes-basic, advanced, and aggressive-apply the same sequence of DLE/YLE transformations, which includes OpenMP parallelism, SIMD vectorization, and loop blocking. However, they vary in the number, type, and order of DSE transformations. In particular, basic enables: common sub-expressions elimination. advanced enables: factorization; extraction of time-invariant shift-invariants; detection of shiftinvariants; all basic passes. aggressive enables: extraction of time-varying shift-invariants; all advanced passes. Thus, aggressive triggers the full-fledged SIE algorithm, while advanced uses only a relaxed version (based on time invariants). All runs used loop tiling with a block shape that was determined individually for each case using auto-tuning. The auto-tuning phase, however, was not included in the measured experiment runtime. Likewise, the code generation phase is not included in the reported runtime.</p>
        <p>In the following sections, we benchmark the performance of operators modeling the propagation of acoustic waves in two different models: isotropic and Tilted Transverse Isotropy (TTI, [45]), henceforth isotropic and tti, respectively. These operators were chosen for their relevance in seismic imaging techniques [45].In the following sections, we benchmark the performance of operators modeling the propagation of acoustic waves in two different models: isotropic and Tilted Transverse Isotropy (TTI, [45]), henceforth isotropic and tti, respectively. These operators were chosen for their relevance in seismic imaging techniques [45].</p>
        <p>Acoustic isotropic modeling is the most commonly used technique for seismic inverse problems, due to the simplicity of its implementation, as well as the comparatively low computational cost in terms of FLOPs. The tti wave equation provides a more realistic simulation of wave propagation and accounts for local directional dependency of the wave speed, but comes with increased computational cost and mathematical complexity. For our numerical tests, we use the tti wave equation as defined in [45]. The full specification of the equation as well as the finite difference schemes and its implementation using 
            <rs type="software">Devito</rs> are provided in [24,25]. Essentially, the tti wave equation consists of two coupled acoustic wave equations, in which the Laplacians are constructed from spatially rotated first derivative operators. As indicated by Figure 4, these spatially rotated Laplacians have a significantly larger number of stencil coefficients in comparison to its isotropic equivalent which comes with an increased operational intensity.
        </p>
        <p>The tti and isotropic equations are discretized with second order in time and varying space orders of 4, 8, 12 and 16. For both test cases, we use zero initial conditions, Dirichlet boundary conditions and absorbing boundaries with a 10 point mask (Section 3.5). The waves are excited by injecting a time-dependent, but spatially-localized seismic source wavelet into the subsurface model, using Devito's sparse point interpolation and injection as described in Section 3.1. We carry out performance measurements for two velocity models of 512 3 and 768 3 grid points with a grid spacing of 20 m. Wave propagation is modeled for 1000 ms, resulting in 327 time steps for isotropic, and 415 time steps for tti. The time-stepping interval is chosen according to the Courant-Friedrichs-Lewy (CFL) condition [8], which guarantees stability of the explicit time-marching scheme and is determined by the highest velocity of the subsurface model and the grid spacing.The tti and isotropic equations are discretized with second order in time and varying space orders of 4, 8, 12 and 16. For both test cases, we use zero initial conditions, Dirichlet boundary conditions and absorbing boundaries with a 10 point mask (Section 3.5). The waves are excited by injecting a time-dependent, but spatially-localized seismic source wavelet into the subsurface model, using Devito's sparse point interpolation and injection as described in Section 3.1. We carry out performance measurements for two velocity models of 512 3 and 768 3 grid points with a grid spacing of 20 m. Wave propagation is modeled for 1000 ms, resulting in 327 time steps for isotropic, and 415 time steps for tti. The time-stepping interval is chosen according to the Courant-Friedrichs-Lewy (CFL) condition [8], which guarantees stability of the explicit time-marching scheme and is determined by the highest velocity of the subsurface model and the grid spacing.</p>
        <p>This section illustrates the performance of isotropic with the core and yask backends. To simplify the exposition, we show results for the DSE in advanced mode only; the aggressive has no impact on isotropic, due to the memory-bound nature of the code [24].This section illustrates the performance of isotropic with the core and yask backends. To simplify the exposition, we show results for the DSE in advanced mode only; the aggressive has no impact on isotropic, due to the memory-bound nature of the code [24].</p>
        <p>The performance of core on skl8180, illustrated in Figure 5a (yask uses slightly smaller grids than core due to a flaw in the API of 
            <rs type="software">Devito</rs> v
            <rs type="version">3.1</rs>, which will be fixed in Devito v3.2), degrades as the space order (henceforth, so) increases. In particular, it drops from 59% of the attainable machine peak to 36% in the case of so=16. This is the result of multiple issues. As so increases, the number of streams of unaligned virtual addresses also increases, causing more pressure on the memory system. Intel ® VTune ™ revealed that the lack of split registers to efficiently handle split loads was a major source of performance degradation. Another major issue for isotropic on core concerns the quality of the generated SIMD code. The in-line vectorization performed by the auto-vectorizer produces a large number of pack/unpack instructions to move data between vector registers, which introduces substantial overhead. Intel ® VTune ™ also confirmed that, unsurprisingly, isotropic is a memory-bound kernel. Indeed, switching off the DSE basically did not impact the runtime, although it did increase the operational intensity of the four test cases.
        </p>
        <p>The performance of core on knl7250 is not as good as that on skl8180. Figure 5b shows an analogous trend to that on skl8180, with the attainable machine peak systematically dropping as so increases. The issue is that here the distance from the peak is even larger. This simply suggests that core is failing at exploiting the various levels of parallelism available on knl7250.The performance of core on knl7250 is not as good as that on skl8180. Figure 5b shows an analogous trend to that on skl8180, with the attainable machine peak systematically dropping as so increases. The issue is that here the distance from the peak is even larger. This simply suggests that core is failing at exploiting the various levels of parallelism available on knl7250.</p>
        <p>The yask backend overcomes all major limitations to which core is subjected. On both skl8180 and knl7250, yask outperforms core, essentially since it does not suffer from the issues presented above. Vector folding reduces memory-read streams; software prefetching helps especially for larger values of so; and hierarchical OpenMP parallelism is fundamental to leverage shared caches. The speed-up on knl7250 is remarkable, since even in the best scenario for core (so=4), yask is roughly 3× faster, and more than 4× faster when so=12.The yask backend overcomes all major limitations to which core is subjected. On both skl8180 and knl7250, yask outperforms core, essentially since it does not suffer from the issues presented above. Vector folding reduces memory-read streams; software prefetching helps especially for larger values of so; and hierarchical OpenMP parallelism is fundamental to leverage shared caches. The speed-up on knl7250 is remarkable, since even in the best scenario for core (so=4), yask is roughly 3× faster, and more than 4× faster when so=12.</p>
        <p>This sections illustrates the performance of tti with the core backend. tti cannot be run on the yask backend in Devito v3.1 as some fundamental features are still missing; this is part of our future work (more details in Section 8).This sections illustrates the performance of tti with the core backend. tti cannot be run on the yask backend in Devito v3.1 as some fundamental features are still missing; this is part of our future work (more details in Section 8).</p>
        <p>Unlike isotropic, tti significantly benefits from different levels of DSE optimizations, which play a key role in reducing the operation count as well as the register pressure. Figure 6 displays the performance of tti for the usual range of space orders on skl8180 and knl7250, for two different cubic grids.Unlike isotropic, tti significantly benefits from different levels of DSE optimizations, which play a key role in reducing the operation count as well as the register pressure. Figure 6 displays the performance of tti for the usual range of space orders on skl8180 and knl7250, for two different cubic grids.</p>
        <p>Generally, tti does not reach the same level of performance as isotropic. This is not surprising given the complexity of the PDEs (e.g., in terms of differential operators), which translates into code with much higher arithmetic intensity. In tti, the memory system is stressed by a considerably larger number of loads per loop iteration than in isotropic. On skl8180, we ran performanceprofiling analyses using Intel ® 
            <rs type="software">VTune</rs> ™ . We determined that the major issues are pressure on both L1 cache (lack of split registers, insufficient "fill buffers" to handle requests to the other levels of the hierarchy) and DRAM (bandwidth and latency). Clearly, this is only a summary from some sample kernels-the actual situation varies depending on the DSE optimizations as well as the so employed.
        </p>
        <p>It is notable that on both skl8180 and knl7250, and on both grids, the cutoff point beyond which advanced results in worse runtimes than aggressive is so=8. One issue with aggressive is that to avoid redundant computation, not only additional memory is required, but also more data communication may occur through caches, rather than through registers. In Figure 12, for example, we can easily deduce that temp is first stored, and then reloaded in the subsequent loop nest. This is an overhead that advanced does not pay, since temporaries are communicated through registers, for as much as possible. Beyond so=8, however, this overhead is overtaken by the reduction in operation count, which grows almost quadratically with so, as reported in Table 1.It is notable that on both skl8180 and knl7250, and on both grids, the cutoff point beyond which advanced results in worse runtimes than aggressive is so=8. One issue with aggressive is that to avoid redundant computation, not only additional memory is required, but also more data communication may occur through caches, rather than through registers. In Figure 12, for example, we can easily deduce that temp is first stored, and then reloaded in the subsequent loop nest. This is an overhead that advanced does not pay, since temporaries are communicated through registers, for as much as possible. Beyond so=8, however, this overhead is overtaken by the reduction in operation count, which grows almost quadratically with so, as reported in Table 1.</p>
        <p>The performance on knl7250 is overall disappointing. This is unfortunately caused by multiple factors-some of which already discussed in the previous sections. These results, and more in general, the need for performance portability across future (Intel ® or non-Intel ® ) architectures, motivated the ongoing yask project. Here, the overarching issue is the inability to exploit the multiple levels of parallelism typical of architectures such as knl7250. Approximately 17% of the attainable peak is obtained when so=4 with advanced (best runtime out of the three DSE modes for the given space order). This occurs when using 512 3 points per grid, which allows the working set to completely fit in MCDRAM (our calculations estimated a size of roughly 7.5GB). With the larger grid size (Figure 6d), the working set increases up to 25.5GB, which exceeds the MCDRAM capacity. This partly accounts for the 5× slow down in runtime (from 34s to 173s) in spite of only a 3× increase in number of grid points computed per time iteration.The performance on knl7250 is overall disappointing. This is unfortunately caused by multiple factors-some of which already discussed in the previous sections. These results, and more in general, the need for performance portability across future (Intel ® or non-Intel ® ) architectures, motivated the ongoing yask project. Here, the overarching issue is the inability to exploit the multiple levels of parallelism typical of architectures such as knl7250. Approximately 17% of the attainable peak is obtained when so=4 with advanced (best runtime out of the three DSE modes for the given space order). This occurs when using 512 3 points per grid, which allows the working set to completely fit in MCDRAM (our calculations estimated a size of roughly 7.5GB). With the larger grid size (Figure 6d), the working set increases up to 25.5GB, which exceeds the MCDRAM capacity. This partly accounts for the 5× slow down in runtime (from 34s to 173s) in spite of only a 3× increase in number of grid points computed per time iteration.</p>
        <p>To run an Operator, there are four major sources of overhead:To run an Operator, there are four major sources of overhead:</p>
        <p>The phase during which the high-level symbolic specification is lowered into C/C++. Compilation into a shared object The generated C/C++ file is compiled into a shared object by a C/C++ compiler with optimizations enabled. The time spent in this phase highly depends on the quality of the generated code. Calling the shared object This requires analyzing the user input, provided at Operator application time, and forwarding it to the loaded shared object. Auto-tuning This step is optional. Its impact varies greatly across different problem sizes and even across backends (core, 
            <rs type="software">yask</rs>).
        </p>
        <p>On skl8180, Devito's turnaround times for all of these four phases are extremely quick, even in the most complex problems in which hundreds of lines of code are generated (e.g., high-order tti). The Intel ® compiler took less than 7 seconds to build tti so=16 at the maximum optimization level, while the Operator required around 3 seconds to emit the C code (with DSE aggressive). Calling the loaded shared object from Python takes negligible time, despite the extensive checks to validate the arguments. Auto-tuning took 3 minutes to complete (heuristic-based search); however, from a user perspective, this is hardly relevant as auto-tuning is disabled (by default) until production or benchmark runs. All these times improves, even significantly, as the arithmetic complexity of a problem decreases (e.g., at lower orders or when considering isotropic).On skl8180, Devito's turnaround times for all of these four phases are extremely quick, even in the most complex problems in which hundreds of lines of code are generated (e.g., high-order tti). The Intel ® compiler took less than 7 seconds to build tti so=16 at the maximum optimization level, while the Operator required around 3 seconds to emit the C code (with DSE aggressive). Calling the loaded shared object from Python takes negligible time, despite the extensive checks to validate the arguments. Auto-tuning took 3 minutes to complete (heuristic-based search); however, from a user perspective, this is hardly relevant as auto-tuning is disabled (by default) until production or benchmark runs. All these times improves, even significantly, as the arithmetic complexity of a problem decreases (e.g., at lower orders or when considering isotropic).</p>
        <p>On knl7250, due to weaker single-core performance, the overheads are more pronounced. It took slightly more than one minute to produce a shared object for tti so=16. Auto-tuning took around 15 minutes. Since it is unlikely that a knl7250 will ever be used as a development platform, these overheads are easily amortized out during production runs.On knl7250, due to weaker single-core performance, the overheads are more pronounced. It took slightly more than one minute to produce a shared object for tti so=16. Auto-tuning took around 15 minutes. Since it is unlikely that a knl7250 will ever be used as a development platform, these overheads are easily amortized out during production runs.</p>
        <p>With the yask backend the compilation times tend to increase, though the order of magnitude is still the same as with core. All other phases are substantially unchanged.With the yask backend the compilation times tend to increase, though the order of magnitude is still the same as with core. All other phases are substantially unchanged.</p>
        <p>For all experiments, we report the time spent in each of these phases in the logs available at [34].For all experiments, we report the time spent in each of these phases in the logs available at [34].</p>
        <p>While many simulation and inversion problems such as full-waveform inversion only require the solver to run on a single shared memory node, many other applications require support for distributed memory parallelism (typically via MPI) so that the solver can run across multiple compute nodes. The immediate plan is to leverage 
            <rs type="software">yask</rs>'s MPI support, and perhaps to include MPI support into core at a later stage. Another important feature is staggered grids, which are necessary for a wide range of FD discretization methods (e.g. modelling elastic wave propagation). Basic support for staggered grids is already included in 
            <rs type="software">Devito</rs> v
            <rs type="version">3.1</rs>, but currently only through a low-level API-the principle of graceful degradation in action. We plan to make the use of this feature more convenient.
        </p>
        <p>As discussed in Section 7.4, the yask backend is not feature-complete yet; in particular, it cannot run the tti equations in the presence of array temporaries. As tti is among the most advanced models for wave propagation used in industry, extending Devito in this direction has high priority.As discussed in Section 7.4, the yask backend is not feature-complete yet; in particular, it cannot run the tti equations in the presence of array temporaries. As tti is among the most advanced models for wave propagation used in industry, extending Devito in this direction has high priority.</p>
        <p>There also is a range of advanced performance optimization techniques that we want to implement, such as "time tiling" (i.e., loop blocking across the time dimension), on-the-fly data compression, and mixed-precision arithmetic exploiting application knowledge. Finally, there is an on-going effort towards adding an ops [32] backend, which will enable code generation for GPUs and also supports distributed memory parallelism via MPI.There also is a range of advanced performance optimization techniques that we want to implement, such as "time tiling" (i.e., loop blocking across the time dimension), on-the-fly data compression, and mixed-precision arithmetic exploiting application knowledge. Finally, there is an on-going effort towards adding an ops [32] backend, which will enable code generation for GPUs and also supports distributed memory parallelism via MPI.</p>
        <p>
            <rs type="software">Devito</rs> is a system to automate high-performance stencil computations. While 
            <rs type="software">Devito</rs> provides a Python-based syntax to easily express FD approximations of PDEs, it is not limited to finite differences. A Devito Operator can implement arbitrary loop nests, and can evaluate arbitrarily long sequences of heterogeneous expressions such as those arising in FD solvers, linear algebra, or interpolation. The compiler technology builds upon years of experience from other DSL-based systems such as FEniCS and 
            <rs type="software">Firedrake</rs>, and wherever possible 
            <rs type="software">Devito</rs> uses existing software components including 
            <rs type="software">SymPy</rs> and 
            <rs type="software">NumPy</rs>, and 
            <rs type="software">YASK</rs>. The experiments in this article show that 
            <rs type="software">Devito</rs> can generate production-level code with compelling performance on state-of-the-art architectures.
        </p>
        <p>except forced[dim] ← e.directions[dim]; else forced[dim] ← e.directions[dim]; end if end for E ′ .append(e._rebuild(directions=forced)) end for return E ′ Algorithm 2: Clustering: grouping expressions into Clusters (pseudocode) Input: A sequence of equations E. Output: A sequence of clusters C. C ← 
            <rs type="software">ClusterGroup</rs>(); for e in E do grouped ← false; for c in reversed(C) do anti, flow ← get_dependencies(c, e); if e.ispace == c.ispace and anti.carried is empty then c.add(e); grouped ← true; break; else if anti.carried is not empty then c.atomics.update(anti.carried.cause);
        </p>
        <p>, Vol. 1, No. 1, Article . Publication date: August 2019., Vol. 1, No. 1, Article . Publication date: August 2019.</p>
        <p>Formerly, Yet Another Stencil Kernel. , Vol. 1, No. 1, Article . Publication date: August 2019.Formerly, Yet Another Stencil Kernel. , Vol. 1, No. 1, Article . Publication date: August 2019.</p>
        <p>At the time of writing, reaching feature-completeness is one the major on-going development efforts. , Vol. 1, No. 1, Article . Publication date: August 2019.At the time of writing, reaching feature-completeness is one the major on-going development efforts. , Vol. 1, No. 1, Article . Publication date: August 2019.</p>
        <p>This work was supported by the Engineering and Physical Sciences Research Council through grants EP/I00677X/1, EP/L000407/1, EP/I012036/1], by the Imperial College London Department of Computing, by the Imperial College London Intel Parallel Computing Centre (IPCC), and by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research, Applied Mathematics and Computer Science programs under contract number DE-AC02-06CH11357.This work was supported by the Engineering and Physical Sciences Research Council through grants EP/I00677X/1, EP/L000407/1, EP/I012036/1], by the Imperial College London Department of Computing, by the Imperial College London Intel Parallel Computing Centre (IPCC), and by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research, Applied Mathematics and Computer Science programs under contract number DE-AC02-06CH11357.</p>
    </text>
</tei>
